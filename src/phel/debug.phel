(ns phel\debug
  (:require phel\core :refer [print-str str gensym])
  (:require phel\str :as s))

(def- *trace-level* (var 0))
(def- *trace-id* (var 0))
(def- *max-trace-digits* (var 2)) ; default to 2 digits unless overridden

(defn set-trace-id-padding!
  "Sets the number of digits used to left-pad trace IDs.
  Call this once before tracing begins to ensure aligned output.

  Example:
    (set-trace-id-padding! 3)
    # Sets trace IDs to use 3 digits (001, 002, etc.)"
  [estimated-id-padding]
  (swap! *max-trace-digits* (fn [_] estimated-id-padding)))

(defn- next-id []
  (swap! *trace-id* inc))

(defn dotrace
  "Wrap `f` so each call and result are printed with indentation.

  Useful for debugging recursive functions by showing call hierarchy.
  Each call is assigned an ID and indented based on recursion depth.

  Example:
    (def factorial (dotrace \"factorial\" (fn [n] (if (<= n 1) 1 (* n (factorial (- n 1)))))))
    (factorial 3)
    # Prints:
    # TRACE t01: (factorial 3)
    # TRACE t02: |    (factorial 2)
    # TRACE t03: |    |    (factorial 1)
    # TRACE t03: |    |    => 1
    # TRACE t02: |    => 2
    # TRACE t01: => 6"
  [name f]
  (fn [& args]
    (let [id (next-id)
          id-str (s/pad-left (str id) (deref *max-trace-digits*) "0")
          indent (s/repeat "|    " (deref *trace-level*))
          arg-str (if (empty? args)
                    ""
                    (str " " (s/join " " (map print-str args))))
          call-str (str "(" name arg-str ")")]
      (println (str "TRACE t" id-str ": " indent call-str))
      (swap! *trace-level* inc)
      (let [res (apply f args)]
        (swap! *trace-level* dec)
        (println (str "TRACE t" id-str ": " indent "=> " res))
        res))))

(defn reset-trace-state!
  "Resets the internal counters used for tracing.

  Call this between debugging sessions to restart trace IDs from 01.

  Example:
    (reset-trace-state!)
    # Resets trace level to 0, trace ID to 0, and padding to 2 digits"
  []
  (do
    (set! *trace-level* 0)
    (set! *trace-id* 0)
    (set! *max-trace-digits* 2)))

(defmacro dbg
  "Evaluates `expr`, prints the expression and the resulting value.
   Returns the value of `expr`.

  Useful for debugging by showing both the code and its result.

  Example:
    (dbg (+ 1 2))
    # Prints: (+ 1 2) => 3
    # Returns: 3

    (let [x (dbg (* 5 6))])
    # Prints: (* 5 6) => 30
    # Binds x to 30"
  [expr]
  (let [res (gensym)]
    `(let [,res ,expr]
       (println (str (print-str (quote ,expr)) " => " (print-str ,res)))
       ,res)))

(defmacro spy
  "Evaluates `expr`, prints the resulting value with an optional label, and returns it.

  Similar to dbg but with a \"SPY\" prefix. Can include a custom label.

  Examples:
    (spy (+ 1 2))
    # Prints: SPY (+ 1 2) => 3
    # Returns: 3

    (spy \"sum\" (+ 1 2))
    # Prints: SPY \"sum\" => 3
    # Returns: 3

    (map (fn [x] (spy \"doubled\" (* x 2))) [1 2 3])
    # Prints SPY for each value and returns [2 4 6]"
  ([expr]
   (let [res (gensym)]
     `(let [,res ,expr]
        (println (str "SPY " (print-str (quote ,expr)) " => " (print-str ,res)))
        ,res)))
  ([label expr]
   (let [res (gensym)
         label-val (gensym)]
     `(let [,label-val ,label
            ,res ,expr]
        (println (str "SPY " (print-str ,label-val) " => " (print-str ,res)))
        ,res))))

(defn tap
  "Executes optional side-effects on `value` and returns it unchanged.
  Without a handler function the value is printed using `print-str`.

  Useful for inspecting values in a pipeline without breaking the flow.

  Examples:
    (-> 5
        (tap)
        (* 2)
        (tap))
    # Prints: TAP => 5
    # Prints: TAP => 10
    # Returns: 10

    (tap 42 (fn [x] (println \"Custom:\" x)))
    # Prints: Custom: 42
    # Returns: 42"
  ([value]
   (println (str "TAP => " (print-str value)))
   value)
  ([value handler]
   (handler value)
   value))
