(ns phel\debug
  (:require phel\core :refer [print-str str gensym])
  (:require phel\str :as s))

(def- *trace-level* (var 0))
(def- *trace-id* (var 0))
(def- *max-trace-digits* (var 2)) ; default to 2 digits unless overridden

(defn set-trace-id-padding!
  "Sets the number of digits for trace ID padding."
  {:example "(set-trace-id-padding! 3)"}
  [estimated-id-padding]
  (swap! *max-trace-digits* (fn [_] estimated-id-padding)))

(defn- next-id []
  (swap! *trace-id* inc))

(defn dotrace
  "Wraps a function to print each call and result with indentation."
  {:example "(def add (dotrace \"add\" +))"}
  [name f]
  (fn [& args]
    (let [id (next-id)
          id-str (s/pad-left (str id) (deref *max-trace-digits*) "0")
          indent (s/repeat "|    " (deref *trace-level*))
          arg-str (if (empty? args)
                    ""
                    (str " " (s/join " " (map print-str args))))
          call-str (str "(" name arg-str ")")]
      (println (str "TRACE t" id-str ": " indent call-str))
      (swap! *trace-level* inc)
      (let [res (apply f args)]
        (swap! *trace-level* dec)
        (println (str "TRACE t" id-str ": " indent "=> " res))
        res))))

(defn reset-trace-state!
  "Resets trace counters to initial values."
  {:example "(reset-trace-state!)"}
  []
  (do
    (set! *trace-level* 0)
    (set! *trace-id* 0)
    (set! *max-trace-digits* 2)))

(defmacro dbg
  "Evaluates an expression and prints it with its result."
  {:example "(dbg (+ 1 2))"}
  [expr]
  (let [res (gensym)]
    `(let [,res ,expr]
       (println (str (print-str (quote ,expr)) " => " (print-str ,res)))
       ,res)))

(defmacro spy
  "Evaluates an expression and prints it with an optional label."
  {:example "(spy (+ 1 2))"}
  ([expr]
   (let [res (gensym)]
     `(let [,res ,expr]
        (println (str "SPY " (print-str (quote ,expr)) " => " (print-str ,res)))
        ,res)))
  ([label expr]
   (let [res (gensym)
         label-val (gensym)]
     `(let [,label-val ,label
            ,res ,expr]
        (println (str "SPY " (print-str ,label-val) " => " (print-str ,res)))
        ,res))))

(defn tap
  "Prints a value and returns it unchanged. Useful in pipelines."
  {:example "(-> 5 (tap) (* 2))"}
  ([value]
   (println (str "TAP => " (print-str value)))
   value)
  ([value handler]
   (handler value)
   value))

# ---------------------------
# Tap> system (global handlers)
# ---------------------------

(def- *tap-handlers* (var []))

(defn add-tap
  "Registers a function as a tap handler. All values sent via `tap>` will be
  passed to every registered handler. Returns nil."
  {:doc "Register a global tap handler function."
   :see-also ["remove-tap" "tap>"]
   :example "(add-tap println)"}
  [f]
  (swap! *tap-handlers* |(conj $ f))
  nil)

(defn remove-tap
  "Removes a previously registered tap handler. Returns nil."
  {:doc "Unregister a global tap handler function."
   :see-also ["add-tap" "tap>"]
   :example "(remove-tap println)"}
  [f]
  (swap! *tap-handlers* |(vec (filter (fn [h] (not (= h f))) $)))
  nil)

(defn tap>
  "Sends a value to all registered tap handlers. Each handler is called with
  the value. Returns true if there are handlers, false otherwise."
  {:doc "Send a value to all registered tap handlers."
   :see-also ["add-tap" "remove-tap"]
   :example "(tap> {:debug \"some value\"})"}
  [value]
  (let [handlers (deref *tap-handlers*)]
    (if (empty? handlers)
      false
      (do
        (foreach [handler handlers]
          (handler value))
        true))))

(defn reset-taps!
  "Removes all registered tap handlers. Returns nil."
  {:doc "Clear all tap handlers."
   :see-also ["add-tap" "remove-tap"]
   :example "(reset-taps!)"}
  []
  (set! *tap-handlers* [])
  nil)
