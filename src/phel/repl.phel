(ns phel\repl
  (:use Phel)
  (:use Phel\Lang\Symbol)
  (:use Phel\Build\BuildFacade)
  (:use Phel\Compiler\Application\Munge)
  (:use Phel\Compiler\CompilerFacade)
  (:use Phel\Compiler\Infrastructure\CompileOptions)
  (:use Phel\Compiler\Infrastructure\GlobalEnvironmentSingleton)
  (:use Phel\Compiler\Domain\Analyzer\Environment\NodeEnvironment)
  (:use Phel\Printer\Printer))

(def build-facade (php/new BuildFacade))

(def- src-dirs (php/array)) # Will be set by the repl command

(defn- get-global-env []
  (php/:: GlobalEnvironmentSingleton (getInstance)))

(defn loaded-namespaces
  "Returns all namespaces currently loaded in the REPL."
  {:example "(loaded-namespaces) ; => [\"phel\\core\" \"phel\\repl\"]"}
  []
  (php/:: Phel (getNamespaces)))

(defn- eval-file [file]
  (php/-> build-facade (evalFile file)))

(defn- eval-namespace [namespace]
  (let [dependencies (php/-> build-facade (getDependenciesForNamespace src-dirs (php/array namespace)))]
    (foreach [dep dependencies]
      (when-not (php/in_array (php/-> dep (getNamespace)) (loaded-namespaces))
        (eval-file (php/-> dep (getFile)))))))

(defn resolve
  "Resolves the given symbol in the current environment and returns a resolved Symbol with the absolute namespace or nil if it cannot be resolved."
  {:example "(resolve 'map) ; => phel\\core/map"}
  [sym]
  (-> (get-global-env)
      (php/-> (resolveAsSymbol sym (php/:: NodeEnvironment (empty))))))

(defn- clean-doc [str]
  (php/trim (php/str_replace (php/array "```phel\n" "```") "" str)))

(defn- find-doc [namespace name]
  (let [meta (php/:: Phel (getDefinitionMetaData namespace name))]
    (when meta
      (let [doc (or (get meta :doc) "")
            deprecated (get meta :deprecated)
            message (if deprecated
                      (str doc (if (= doc "") "" "\n") "DEPRECATED: " deprecated)
                      doc)]
        (clean-doc message)))))

(defmacro doc
  "Prints the documentation for the given symbol."
  {:example "(doc map)"}
  [sym]
  (let [resolved-sym (resolve sym)]
    (when resolved-sym
      `(println (find-doc ,(namespace resolved-sym) ,(name resolved-sym))))))

(defn- extract-alias [sym options]
  (if (:as options)
    (:as options)
    (let [parts (php/explode "\\" (name sym))
          last (php/array_pop parts)]
      (php/:: Symbol (create last)))))

(defn- set-ns [namespace]
  (set-var *ns* namespace))

(defn- require-namespace
  [namespace alias refers]
  (let [env (get-global-env)
        current-ns *ns*]
    (php/-> env (addRequireAlias current-ns alias namespace))
    (foreach [r refers]
      (php/-> env (addRefer current-ns r namespace)))
    (eval-namespace namespace)
    (php/-> (get-global-env) (setNs current-ns))
    (set-ns current-ns)
    namespace))

(defmacro require
  "Requires a Phel module into the environment."
  {:example "(require phel\http :as http :refer [request]) ; => phel\\http"}
  [sym & args]
  (let [options (apply hash-map args)
        alias (extract-alias sym options)
        refers (or (:refer options) [])]
    `(require-namespace ',sym ',alias ',refers)))

(defn- use-namespace
  [namespace alias]
  (php/-> (get-global-env) (addUseAlias *ns* alias namespace))
  namespace)

(defmacro use
  "Adds a use statement to the environment."
  {:example "(use DateTime :as DT) ; => DateTime"}
  [sym & args]
  (let [options (apply hash-map args)
        alias (extract-alias sym options)]
    `(use-namespace ',sym ',alias)))

(defn- print-colorful-str
  "Same as print-str from core, but with color."
  [& xs]
  (let [len (count xs)
        printer (php/:: Printer (readableWithColor))
        pp |(php/-> printer (print $))]
    (case (count xs)
      0 ""
      1 (pp (first xs))
      (loop [res (pp (first xs))
             seq (next xs)]
        (if seq
          (recur (str res " " (pp (first seq))) (next seq))
          res)))))

(defn print-colorful
  "Prints arguments with colored output."
  {:example "(print-colorful [1 2 3])"}
  [& xs]
  (php/print (apply print-colorful-str xs))
  nil)

(defn println-colorful
  "Prints arguments with colored output followed by a newline."
  {:example "(println-colorful [1 2 3])"}
  [& xs]
  (apply print-colorful xs)
  (php/print "\n")
  nil)

(defn compile-str
  "Compiles a Phel expression string to PHP code."
  {:example "(compile-str \"(+ 1 2)\") ; => \"(1 + 2)\""}
  [s]
  (let [cf (php/new CompilerFacade)
        opts (php/new CompileOptions)
        res (php/-> cf (compile s opts))]
    (php/-> res (getCode))))

(defn- munge-ns
  "Encodes a namespace string for registry lookup."
  [ns-str]
  (let [munge (php/new Munge)]
    (php/-> munge (encodeNs ns-str))))

(defn dir
  "Prints all public definitions in the given namespace string.

  Returns nil. Prints one name per line, sorted alphabetically."
  {:example "(dir \"phel\\core\")"}
  [ns-str]
  (let [encoded (munge-ns ns-str)
        defs (php/:: Phel (getDefinitionInNamespace encoded))
        munge (php/new Munge)
        names (for [fn-name :keys defs
                    :let [meta (php/:: Phel (getDefinitionMetaData encoded fn-name))]
                    :when (not (get meta :private))]
                (php/-> munge (decodeNs fn-name)))]
    (foreach [n (sort names)]
      (println n))
    nil))

(defn apropos
  "Returns a vector of symbols whose name contains the given search string.
  Searches across all loaded namespaces."
  {:example "(apropos \"map\") ; => [phel\\core/flat-map phel\\core/map ...]"}
  [search]
  (let [munge (php/new Munge)
        results (transient [])]
    (foreach [ns (loaded-namespaces)]
      (let [defs (php/:: Phel (getDefinitionInNamespace ns))
            fn-names (php/array_keys defs)]
        (foreach [fn-name fn-names]
          (let [decoded (php/-> munge (decodeNs fn-name))
                meta (php/:: Phel (getDefinitionMetaData ns fn-name))]
            (when (and (not (get meta :private))
                       (php/str_contains decoded search))
              (conj results (str (php/-> munge (decodeNs ns)) "/" decoded)))))))
    (sort (persistent results))))

(defn search-doc
  "Searches docstrings across all loaded namespaces for the given string.
  Prints matching function names and their documentation."
  {:example "(search-doc \"reduce\")"}
  [search]
  (let [munge (php/new Munge)
        search-lower (php/strtolower search)]
    (foreach [ns (loaded-namespaces)]
      (let [defs (php/:: Phel (getDefinitionInNamespace ns))
            fn-names (php/array_keys defs)]
        (foreach [fn-name fn-names]
          (let [meta (php/:: Phel (getDefinitionMetaData ns fn-name))]
            (when meta
              (let [doc (or (get meta :doc) "")
                    doc-lower (php/strtolower doc)
                    decoded-name (php/-> munge (decodeNs fn-name))
                    decoded-ns (php/-> munge (decodeNs ns))]
                (when (and (not (get meta :private))
                           (php/str_contains doc-lower search-lower))
                  (println (str "--- " decoded-ns "/" decoded-name " ---"))
                  (println (clean-doc doc))
                  (println))))))))
    nil))
