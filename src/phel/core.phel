(ns phel\core
  (:use Countable)
  (:use Traversable)
  (:use InvalidArgumentException)
  (:use Phel)
  (:use Phel\Compiler\Application\Munge)
  (:use Phel\Compiler\CompilerFacade)
  (:use Phel\Compiler\Domain\Analyzer\Ast\GlobalVarNode)
  (:use Phel\Compiler\Domain\Analyzer\Environment\NodeEnvironment)
  (:use Phel\Compiler\Infrastructure\GlobalEnvironmentSingleton)
  (:use Phel\Lang\AbstractType)
  (:use Phel\Lang\CdrInterface)
  (:use Phel\Lang\Collections\HashSet\PersistentHashSetInterface)
  (:use Phel\Lang\Collections\HashSet\TransientHashSetInterface)
  (:use Phel\Lang\Collections\LinkedList\PersistentListInterface)
  (:use Phel\Lang\Collections\Map\PersistentMapInterface)
  (:use Phel\Lang\Collections\Map\TransientMapInterface)
  (:use Phel\Lang\Collections\Struct\AbstractPersistentStruct)
  (:use Phel\Lang\Collections\Vector\PersistentVectorInterface)
  (:use Phel\Lang\Collections\Vector\TransientVectorInterface)
  (:use Phel\Lang\ConcatInterface)
  (:use Phel\Lang\ConsInterface)
  (:use Phel\Lang\ContainsInterface)
  (:use Phel\Lang\FirstInterface)
  (:use Phel\Lang\IdenticalInterface)
  (:use Phel\Lang\Keyword)
  (:use Phel\Lang\MetaInterface)
  (:use Phel\Lang\PopInterface)
  (:use Phel\Lang\PushInterface)
  (:use Phel\Lang\RemoveInterface)
  (:use Phel\Lang\RestInterface)
  (:use Phel\Lang\SliceInterface)
  (:use Phel\Lang\Symbol)
  (:use Phel\Lang\Truthy)
  (:use Phel\Lang\Variable)
  (:use Phel\Lang\Generators)
  (:use Phel\Lang\Hasher)
  (:use Phel\Lang\Equalizer)
  (:use Phel\Lang\Collections\LazySeq\LazySeq)
  (:use Phel\Lang\Collections\LazySeq\LazySeqInterface)
  (:use Phel\Lang\Collections\LazySeq\ChunkedSeq)
  (:use Phel\Printer\Printer))

(def *ns*
  "Returns the namespace in the current scope."
  "\\phel\\core")

(def *file*
  "Returns the path to the current source file."
  "")

# --------------------------------------------
# Basic methods for quasiquote and destructure
# --------------------------------------------

(def list
  "Creates a new list. If no argument is provided, an empty list is created.

  Lists are immutable sequential collections optimized for adding elements at the front.
  They are evaluated as function calls in Phel code unless quoted.

  Examples:
    (list 1 2 3)
    # => (1 2 3)

    (list \"a\" \"b\" \"c\")
    # => (\"a\" \"b\" \"c\")

    (list)
    # => ()

    (cons 0 (list 1 2 3))
    # => (0 1 2 3)"
  (fn [& xs] (php/:: Phel (list (apply php/array xs)))))

(def vector
  "Creates a new vector. If no argument is provided, an empty vector is created.

  Vectors are immutable sequential collections with efficient random access and updates.
  Use vectors when you need indexed access to elements.

  Examples:
    (vector 1 2 3)
    # => [1 2 3]

    (vector \"a\" \"b\" \"c\")
    # => [\"a\" \"b\" \"c\"]

    (vector)
    # => []

    (get (vector :a :b :c) 1)
    # => :b"
  (fn [& xs] (php/:: Phel (vector (apply php/array xs)))))

(def hash-map
  "Creates a new hash map. If no argument is provided, an empty hash map is created. The number of parameters must be even."
  (fn [& xs] (php/:: Phel (map (apply php/array xs)))))

(def next
  "Returns the sequence of elements after the first element. If there are no elements, returns nil.

  Unlike `rest`, `next` returns nil when there are no remaining elements rather than an empty sequence.
  This makes it useful in recursive operations where you want to detect the end of a sequence.

  Examples:
    (next [1 2 3])
    # => [2 3]

    (next '(\"a\" \"b\"))
    # => (\"b\")

    (next [1])
    # => nil

    (next [])
    # => nil

    (next nil)
    # => nil

  See also: rest, first"
  (fn [xs]
    (if (php/=== xs nil)
      nil
      (if (php/instanceof xs CdrInterface)
        (php/-> xs (cdr))
        (if (php/is_array xs)
          (let [sliced (php/array_slice xs 1)]
            (if (php/empty sliced)
              nil
              sliced))
          (throw (php/new InvalidArgumentException
                          (php/. "cannot call 'next on " (php/gettype xs)))))))))

(def first
  "Returns the first element of an indexed sequence or nil.

  Works with lists, vectors, arrays, and any collection implementing FirstInterface.
  Returns nil if the sequence is empty or nil.

  Examples:
    (first [1 2 3])
    # => 1

    (first '(\"a\" \"b\" \"c\"))
    # => \"a\"

    (first [])
    # => nil

    (first nil)
    # => nil"
  (fn [xs]
    (if (php/instanceof xs FirstInterface)
      (php/-> xs (first))
      (php/aget xs 0))))

(def concat1
  {:private true
   :doc "Concatenates two sequential data structures."}
  (fn [xs ys]
    (if (php/=== nil ys)
      xs
      (if (php/instanceof xs ConcatInterface)
        (php/-> xs (concat ys))
        (do
          (foreach [y ys]
            (php/apush xs y))
          xs)))))

(def concat
  "Concatenates multiple sequential data structures."
  (fn [arr & others]
    (if (php/=== nil arr)
      '()
      (loop [res arr
             other others]
        (if (php/=== nil other)
          res
          (let [[y & ys] other]
            (recur (concat1 res y) ys)))))))

# quasiquote can be used down here

(def declare
  {:macro true
   :doc "Declare a global symbol before it is defined."}
  (fn [name]
    `(def ,name nil)))

(declare nil?)
(def argv
  "Vector of arguments passed to the script."
  (let [argv-raw (php/aget php/$GLOBALS "argv")]
    (if (php/=== argv-raw nil)
      []
      (php/:: Phel (vector argv-raw)))))

# ------------
# Meta helpers
# ------------

(declare =)
(declare symbol?)
(declare list?)
(declare second)

(def meta
  {:macro true
   :doc "Gets the metadata of the given object or definition."}
  (fn [obj]
    (let [sym (if (symbol? obj)
                obj
                (if (list? obj)
                  (if (= (first obj) 'quote)
                    (if (symbol? (second obj))
                      (second obj)
                      nil)
                    nil)
                  nil))]
      (if sym
        (let [ns (php/-> sym (getNamespace))]
          (if ns
            `(php/:: \Phel (getDefinitionMetaData ,ns ,(php/-> sym (getName))))
            `(php/:: \Phel (getDefinitionMetaData *ns* ,(php/-> sym (getName))))))
        `(let [obj-meta ,obj]
           (if (php/instanceof obj-meta \Phel\Lang\MetaInterface)
             (php/-> obj-meta (getMeta))
             nil))))))

(def set-meta!
  "Sets the metadata to a given object."
  (fn [obj meta]
    (php/-> obj (withMeta meta))))

(def with-meta
  {:private true
   :doc "Returns `target` with the metadata from `source` when both implement `MetaInterface`."}
  (fn [source target]
    (if (php/instanceof source MetaInterface)
      (if (php/instanceof target MetaInterface)
        (php/-> target (withMeta (php/-> source (getMeta))))
        target)
      target)))

# ------------
# Basic macros
# ------------

(def defn-builder
  {:macro true
   :private true}
  (fn [name meta & fdecl]
    (let [meta (if (php/is_string (php/aget fdecl 0))
                 (php/-> meta (put :doc (php/aget fdecl 0)))
                 meta)
          fdecl (if (php/is_string (php/aget fdecl 0))
                  (next fdecl)
                  fdecl)
          meta (if (php/instanceof (php/aget fdecl 0) PersistentMapInterface)
                 (php/-> meta (merge (php/aget fdecl 0)))
                 meta)
          fdecl (if (php/instanceof (php/aget fdecl 0) PersistentMapInterface)
                  (next fdecl)
                  fdecl)
          args (if (php/instanceof (php/aget fdecl 0) PersistentVectorInterface)
                 (php/aget fdecl 0)
                 (php/aget (php/aget fdecl 0) 0))]
      `(def ,name ,meta (fn ,@fdecl)))))

(def defn
  {:macro true
   :doc "Define a new global function."}
  (fn [name & fdecl] (apply defn-builder name {} fdecl)))

(def def-
  {:macro true
   :doc "Define a private value that will not be exported."}
  (fn [name value] `(def ,name {:private true} ,value)))

(def defmacro
  {:macro true
   :doc "Define a macro."}
  (fn [name & fdecl] (apply defn-builder name {:macro true} fdecl)))

(defmacro defn-
  "Define a private function that will not be exported."
  [name & fdecl]
  (apply defn-builder name {:private true} fdecl))

(defmacro defmacro-
  "Define a private macro that will not be exported."
  [name & fdecl]
  (apply defn-builder name {:macro true :private true} fdecl))

(defmacro defstruct
  "Define a new struct."
  [name keys & implementations]
  (let [name-str (php/-> name (getName))
        munge (php/new Munge)
        class-name-str (php/. *ns* "\\" (php/-> munge (encode name-str)))
        is-name (php/:: Symbol (create (php/. name-str "?")))]
    `(do
       (defstruct* ,name ,keys ,@implementations)
       (defn ,name ,(php/. "Creates a new " name " struct.") ,keys (php/new ,class-name-str ,@keys))
       (defn ,is-name ,(php/. "Checks if `x` is an instance of the " name " struct.") [x] (php/is_a x ,class-name-str)))))

(defmacro defexception
  "Define a new exception."
  [name]
  (let [name-str (php/-> name (getName))
        munge (php/new Munge)
        class-name-str (php/. *ns* "\\" (php/-> munge (encode name-str)))
        is-name (php/:: Symbol (create (php/. name-str "?")))]
    `(do
       (defexception* ,name)
       (defn ,name ,(php/. "Creates a new " name " exception.") [& args] (apply php/new ,class-name-str args))
       (defn ,is-name ,(php/. "Checks if `x` is an instance of the " name " exception.") [x] (php/is_a x ,class-name-str)))))

(defmacro comment
  "Ignores the body of the comment."
  [&])

(defn symbol
  "Returns a new symbol for given string with optional namespace.
   Arity-1 returns a symbol without namespace. Arity-2 returns a symbol in given namespace."
  [name-or-ns & [name]]
  (if name
    (php/:: Symbol (createForNamespace name-or-ns name))
    (php/:: Symbol (create name-or-ns))))

(defn gensym
  "Generates a new unique symbol."
  []
  (php/:: Symbol (gen)))

(defn str
  "Creates a string by concatenating values together. If no arguments are
provided an empty string is returned. Nil and false are represented as an empty
string. True is represented as 1. Otherwise, it tries to call `__toString`.
This is PHP equivalent to `$args[0] . $args[1] . $args[2] ...`."
  {:inline (fn [& args] `(php/. "" ,@args))
   :inline-arity (fn [n] (php/> n 0))}
  [& args]
  (if (php/== (php/count args) 0)
    ""
    (apply php/. "" args)))

(defn transient
  "Converts a persistent collection to a transient collection."
  [coll]
  (php/-> coll (asTransient)))

(defn persistent
  "Converts a transient collection to a persistent collection."
  [coll]
  (php/-> coll (persistent)))

# ------------------
# Basic constructors
# ------------------

(defn set
  "Creates a new Set. If no argument is provided, an empty Set is created."
  [& xs]
  (php/:: Phel (set (apply php/array xs))))

(defn keyword
  "Creates a new Keyword from a given string."
  [x]
  (php/:: Keyword (create x)))

(defn php-indexed-array
  "Creates a PHP indexed array from the given values."
  [& xs]
  (apply php/array xs))

(defn php-associative-array
  "Creates a PHP associative array. An even number of parameters must be provided."
  [& xs]
  (let [cnt (php/count xs)
        res (php/array)]
    (if (php/=== 1 (php/% cnt 2))
      (throw (php/new InvalidArgumentException "An even number of parameters must be provided for 'php-associative-array'")))
    (loop [i 0]
      (if (php/< i cnt)
        (do
          (php/aset res (php/aget xs i) (php/aget xs (php/+ i 1)))
          (recur (php/+ i 2)))
        res))))

# ------------------------
# Basic sequence operation
# ------------------------

(defn- equals1 [a b]
  (if (php/instanceof a AbstractType)
    (php/-> a (equals b))
    (php/=== a b)))

(defn cons
  "Prepends `x` to the beginning of `coll`.

  Adds an element to the front of a collection, returning a new collection.
  For lists, this is an O(1) operation. For vectors, it returns a list.
  If `coll` is nil, returns a vector containing just `x`.

  Examples:
    (cons 0 [1 2 3])
    # => [0 1 2 3]

    (cons :a '(:b :c))
    # => (:a :b :c)

    (cons 1 nil)
    # => [1]

    (cons \"first\" (cons \"second\" [\"third\"]))
    # => [\"first\" \"second\" \"third\"]

  See also: first, rest, conj"
  [x coll]
  (if (php/is_array coll)
    (do
      (php/array_unshift coll x)
      coll)
    (if (php/instanceof coll ConsInterface)
      (php/-> coll (cons x))
      (if (php/=== coll nil)
        [x]
        (throw (php/new InvalidArgumentException
                        (php/. "cannot do cons " (php/print_r x true))))))))

(defn ffirst
  "Same as `(first (first coll))`."
  [coll]
  (first (first coll)))

(defn second
  "Returns the second element of an indexed sequence or nil.

  Equivalent to `(first (next coll))`. Returns nil if the sequence
  has fewer than two elements.

  Examples:
    (second [1 2 3])
    # => 2

    (second '(:a :b :c))
    # => :b

    (second [1])
    # => nil

    (second [])
    # => nil

  See also: first, next, third"
  [coll]
  (first (next coll)))

(defn rest
  "Returns the sequence of elements after the first element. If there are no elements, returns an empty sequence.

  Unlike `next`, `rest` always returns a sequence (never nil), making it useful
  when you need to ensure a sequence result. Returns an empty sequence when
  given an empty or single-element collection.

  Examples:
    (rest [1 2 3])
    # => [2 3]

    (rest '(:a :b))
    # => (:b)

    (rest [1])
    # => []

    (rest [])
    # => []

  See also: next, first, cons"
  [coll]
  (if (php/instanceof coll RestInterface)
    (php/-> coll (rest))
    (if (php/is_array coll)
      (php/array_slice coll 1)
      (throw (php/new InvalidArgumentException "cannot do rest")))))

(defn nfirst
  "Same as `(next (first coll))`."
  [coll]
  (next (first coll)))

(defn nnext
  "Same as `(next (next coll))`."
  [coll]
  (next (next coll)))

(defn count
  "Counts the number of elements in a sequence. Can be used on everything that implements the PHP Countable interface.

  Works with lists, vectors, hash-maps, sets, and PHP arrays.
  Returns 0 for nil. Throws an exception for strings (use `php/strlen` or `php/mb_strlen` instead).

  Examples:
    (count [1 2 3])
    # => 3

    (count '(:a :b))
    # => 2

    (count {:name \"Alice\" :age 30})
    # => 2

    (count #{1 2 3 4})
    # => 4

    (count [])
    # => 0

    (count nil)
    # => 0

  See also: empty?, seq"
  [coll]
  (if (php/instanceof coll Countable)
    (php/-> coll (count))
    (if (php/is_array coll)
      (php/count coll)
      (if (php/is_string coll)
        (throw (php/new InvalidArgumentException "strings are not supported. Consider using native PHP functions like `php/strlen` or `php/mb_strlen`."))
        (if (php/=== coll nil)
          0
          (throw (php/new InvalidArgumentException (str "object is not countable: " coll))))))))

# ------------------
# Control structures
# ------------------

(defmacro if-not
  "Shorthand for `(if (not condition) else then)`.

  Evaluates test. If logical false, evaluates and returns then expression,
  otherwise evaluates and returns else expression. The else expression is optional.

  Examples:
    (if-not (< 5 3)
      \"5 is not less than 3\"
      \"5 is less than 3\")
    # => \"5 is not less than 3\"

    (if-not (empty? [1 2 3])
      \"has items\")
    # => \"has items\"

  See also: if, when-not, not"
  [test then & [else]]
  `(if ,test ,else ,then))

(defmacro when
  "Evaluates `test` and if that is logical true, evaluates `body`.

  Unlike `if`, `when` is designed for side effects and does not have an else clause.
  Returns nil if test is logical false. Multiple body expressions are wrapped in a do.

  Examples:
    (when (> 10 5)
      (println \"10 is greater than 5\")
      \"result\")
    # prints \"10 is greater than 5\"
    # => \"result\"

    (when false
      (println \"This won't execute\"))
    # => nil

  See also: when-not, if, unless"
  [test & body]
  `(if ,test (do ,@body)))

(defmacro when-not
  "Evaluates `test` and if that is logical false, evaluates `body`.

  Shorthand for `(when (not test) body...)`. Returns nil if test is logical true.
  Use for side-effect operations that should only occur when a condition is false.

  Examples:
    (when-not (empty? [1 2 3])
      (println \"Vector has items\")
      :non-empty)
    # prints \"Vector has items\"
    # => :non-empty

    (when-not true
      (println \"This won't execute\"))
    # => nil

  See also: when, if-not, unless"
  [test & body]
  `(if ,test nil (do ,@body)))

(defmacro cond
  "Takes a set of test/expression pairs. Evaluates each test one at a time.
  If a test returns logically true, the expression is evaluated and returned.
  If no test matches a final last expression can be provided that is then
  evaluated and returned. Otherwise, nil is returned.

  Use `cond` for multiple conditional branches instead of nested if expressions.
  The final expression without a test serves as a default/else clause.

  Examples:
    (cond
      (< x 0)  \"negative\"
      (> x 0)  \"positive\"
      \"zero\")
    # => \"negative\", \"positive\", or \"zero\" depending on x

    (cond
      (empty? coll)     \"empty\"
      (= (count coll) 1) \"one item\"
      \"many items\")

  See also: case, if, when"
  [& pairs]
  (let [cnt (count pairs)]
    (if (php/=== cnt 0)
      nil
      (if (php/=== cnt 1)
        (first pairs)
        (list 'if
              (first pairs)
              (second pairs)
              (cons 'cond (apply list (next (next pairs)))))))))

(defmacro case
  "Takes an expression `e` and a set of test-content/expression pairs. First
  evaluates `e` and then finds the first pair where the test-constant matches
  the result of `e`. The associated expression is then evaluated and returned.
  If no matches can be found a final last expression can be provided that is
  then evaluated and returned. Otherwise, nil is returned.

  Unlike `cond`, `case` evaluates the test expression only once and compares
  it against constant values. This makes it more efficient for multiple
  comparisons against the same value.

  Examples:
    (case (get-status)
      :pending \"Waiting...\"
      :processing \"Working...\"
      :done \"Completed!\"
      \"Unknown status\")

    (case x
      1 \"one\"
      2 \"two\"
      3 \"three\"
      \"other\")

  See also: cond, if, switch"
  [e & pairs]
  (if (next pairs)
    (let [v (gensym)]
      `(let [,v ,e]
         (if (equals1 ,v ',(first pairs))
           ,(first (next pairs))
           (case ,v ,@(next (next pairs))))))
    (first pairs)))

# -----------------
# Boolean operation
# -----------------

(defmacro or
  "Evaluates each expression one at a time, from left to right. If a form
returns a logical true value, or returns that value and doesn't evaluate any of
the other expressions, otherwise, it returns the value of the last expression.
Calling or without arguments, returns nil.

  Provides short-circuit evaluation - stops at the first truthy value.
  Useful for providing default values or fallback options.

  Examples:
    (or false nil 42 100)
    # => 42

    (or (get-cached-value) (compute-value))
    # Returns cached value if available, otherwise computes it

    (or)
    # => nil

    (or \"first\" \"second\")
    # => \"first\"

  See also: and, some, cond"
  [& args]
  (case (count args)
    0 nil
    1 (first args)
    (let [v (gensym)]
      `(let [,v ,(first args)]
         (if ,v ,v (or ,@(next args)))))))

(defmacro and
  "Evaluates each expression one at a time, from left to right. If a form
returns logical false, `and` returns that value and doesn't evaluate any of the
other expressions, otherwise, it returns the value of the last expression.
Calling the `and` function without arguments returns true.

  Provides short-circuit evaluation - stops at the first falsy value.
  All conditions must be truthy for the last expression to be evaluated and returned.

  Examples:
    (and true 1 \"hello\")
    # => \"hello\"

    (and (valid? data) (save! data))
    # Only saves if data is valid

    (and)
    # => true

    (and true false \"unreachable\")
    # => false

  See also: or, all?, every?"
  [& args]
  (case (count args)
    0 'true
    1 (first args)
    (let [v (gensym)]
      `(let [,v ,(first args)]
         (if ,v (and ,@(next args)) ,v)))))

(defn- id2 [a b]
  (if (php/instanceof a IdenticalInterface)
    (php/-> a (identical b))
    (php/=== a b)))

(defn id
  "Checks if all values are identical. Same as `a === b` in PHP."
  [a & more]
  (case (count more)
    0 true
    1 (id2 a (first more))
    (if (id2 a (first more))
      (recur (first more) (next more))
      false)))

(defn =
  "Checks if all values are equal. Same as `a == b` in PHP.

  Compares values for equality, not identity. For Phel types, uses the equals method.
  Can compare multiple values - returns true only if all values are equal.

  Examples:
    (= 5 5)
    # => true

    (= [1 2 3] [1 2 3])
    # => true

    (= 1 1 1 1)
    # => true

    (= \"hello\" \"world\")
    # => false

    (= {:a 1} {:a 1})
    # => true

  See also: id, not=, equals?"
  [a & more]
  (case (count more)
    0 true
    1 (equals1 a (first more))
    (if (equals1 a (first more))
      (recur (first more) (next more))
      false)))

(defn not
  "The `not` function returns `true` if the given value is logical false and `false` otherwise.

  Returns the logical negation of the given value. In Phel, nil and false are
  considered logical false; all other values are logical true.

  Examples:
    (not true)
    # => false

    (not false)
    # => true

    (not nil)
    # => true

    (not 0)
    # => false (0 is truthy in Phel)

    (not (empty? [1 2 3]))
    # => true

  See also: nil?, false?, if-not, when-not"
  [x]
  (if x false true))

(defn not=
  "Checks if all values are unequal. Same as `a != b` in PHP."
  [a & more]
  (case (count more)
    0 false
    1 (not (= a (first more)))
    (not (apply = a more))))

(defn <
  "Checks if each argument is strictly less than the following argument. Returns a boolean.

  Can compare multiple arguments in a chain. Returns true only if each argument
  is strictly less than the next one.

  Examples:
    (< 1 2)
    # => true

    (< 1 2 3 4)
    # => true

    (< 5 5)
    # => false

    (< 10 5)
    # => false

    (< 1 3 2)
    # => false

  See also: <=, >, >=, compare"
  {:inline (fn [a b] `(php/< ,a ,b))
   :inline-arity (fn [n] (php/=== n 2))}
  [a & more]
  (case (count more)
    0 true
    1 (php/< a (first more))
    (if (php/< a (first more))
      (recur (first more) (next more))
      false)))

(defn <=
  "Checks if each argument is less than or equal to the following argument. Returns a boolean."
  {:inline (fn [a b] `(php/<= ,a ,b))
   :inline-arity (fn [n] (php/=== n 2))}
  [a & more]
  (case (count more)
    0 true
    1 (php/<= a (first more))
    (if (php/<= a (first more))
      (recur (first more) (next more))
      false)))

(defn >
  "Checks if each argument is strictly greater than the following argument. Returns a boolean.

  Can compare multiple arguments in a chain. Returns true only if each argument
  is strictly greater than the next one.

  Examples:
    (> 2 1)
    # => true

    (> 4 3 2 1)
    # => true

    (> 5 5)
    # => false

    (> 1 10)
    # => false

    (> 3 1 2)
    # => false

  See also: >=, <, <=, compare"
  {:inline (fn [a b] `(php/> ,a ,b))
   :inline-arity (fn [n] (php/=== n 2))}
  [a & more]
  (case (count more)
    0 true
    1 (php/> a (first more))
    (if (php/> a (first more))
      (recur (first more) (next more))
      false)))

(defn >=
  "Checks if each argument is greater than or equal to the following argument. Returns a boolean."
  {:inline (fn [a b] `(php/>= ,a ,b))
   :inline-arity (fn [n] (php/=== n 2))}
  [a & more]
  (case (count more)
    0 true
    1 (php/>= a (first more))
    (if (php/>= a (first more))
      (recur (first more) (next more))
      false)))

(defn <=>
  "Alias for the spaceship PHP operator in ascending order. Returns an int."
  {:inline (fn [a b] `(php/<=> ,a ,b))}
  [a b]
  (php/<=> a b))

(defn >=<
  "Alias for the spaceship PHP operator in descending order. Returns an int."
  {:inline (fn [a b] `(php/<=> ,b ,a))}
  [a b]
  (php/<=> b a))

(defn all?
  "Returns true if `(pred x)` is logical true for every `x` in collection `coll`
   or if `coll` is empty. Otherwise returns false.

  Tests each element of the collection against the predicate function.
  Short-circuits on the first false result for efficiency.

  Examples:
    (all? pos? [1 2 3 4])
    # => true

    (all? even? [2 4 6 8])
    # => true

    (all? string? [\"a\" \"b\" 3])
    # => false

    (all? pos? [])
    # => true (vacuous truth)

  See also: every?, some?, not-every?"
  [pred coll]
  (cond
    (php/=== (count coll) 0) true
    (pred (first coll))     (recur pred (next coll))
    false))

(defn every?
  "Alias for `all?`."
  [pred coll]
  (all? pred coll))

(defn not-every?
  "Returns false if `(pred x)` is logical true for every `x` in collection `coll`
   or if `coll` is empty. Otherwise returns true."
  [pred coll]
  (not (every? pred coll)))

(declare empty?)
(declare truthy?)
(declare name)

(defn some?
  "Returns true if `(pred x)` is logical true for at least one `x` in `coll`, else false.

  Tests each element against the predicate until finding a truthy result.
  Short-circuits on the first true result. Returns false for empty collections.

  Examples:
    (some? even? [1 3 5 6 7])
    # => true

    (some? neg? [1 2 3])
    # => false

    (some? #(> % 10) [5 15 8])
    # => true

    (some? pos? [])
    # => false

  See also: some, any?, not-any?, filter"
  [pred coll]
  (if (empty? coll)
    false
    (if (truthy? (pred (first coll)))
      true
      (recur pred (next coll)))))

(defn not-any?
  "Returns true if `(pred x)` is logical false for every `x` in `coll`
   or if `coll` is empty. Otherwise returns false."
  [pred coll]
  (not (some? pred coll)))

(defn some
  "Returns the first logical true value of `(pred x)` for any `x` in `coll`, else nil.

  Unlike `some?`, this returns the actual truthy value, not just true/false.
  Useful when you want to both test and use the result of the predicate.

  Examples:
    (some even? [1 3 5 6 7])
    # => true

    (some #{:a :b} [:x :y :b :z])
    # => :b (sets can be used as predicates)

    (some #(when (> % 10) %) [5 15 8])
    # => 15

    (some pos? [])
    # => nil

  See also: some?, filter, keep"
  [pred coll]
  (if (empty? coll)
    nil
    (let [res (pred (first coll))]
      (if (truthy? res)
        res
        (recur pred (next coll))))))

(defn true?
  "Checks if `x` is true. Same as `x === true` in PHP.

  Checks for the exact value true, not just truthiness.
  Use this when you need to distinguish true from other truthy values.

  Examples:
    (true? true)
    # => true

    (true? false)
    # => false

    (true? 1)
    # => false (1 is truthy but not true)

    (true? nil)
    # => false

  See also: false?, truthy?, boolean"
  [x]
  (id x true))

(defn truthy?
  "Checks if `x` is truthy. Same as `x == true` in PHP."
  [x]
  (php/:: Truthy (isTruthy x)))

(defn false?
  "Checks if `x` is false. Same as `x === false` in PHP.

  Checks for the exact value false, not just falsiness.
  Use this when you need to distinguish false from nil or other falsy values.

  Examples:
    (false? false)
    # => true

    (false? true)
    # => false

    (false? nil)
    # => false (nil is falsy but not false)

    (false? 0)
    # => false

  See also: true?, nil?, truthy?"
  [x]
  (id x false))

(defn nil?
  "Returns true if `x` is nil, false otherwise.

  Checks for the exact value nil. This is the most common way to test
  for absence of value in Phel.

  Examples:
    (nil? nil)
    # => true

    (nil? false)
    # => false

    (nil? 0)
    # => false

    (nil? \"\")
    # => false

    (nil? (get {:a 1} :b))
    # => true

  See also: some?, false?, empty?"
  [x]
  (id x nil))

(defn str-contains?
  "Returns true if str contains s."
  {:deprecated "Use phel\\str\\contains?"}
  [str s]
  (php/str_contains str s))

(defn contains?
  "Returns true if key is present in the given collection, otherwise returns false.

  For maps and sets, checks if the key/element exists.
  For vectors, checks if the index is valid (not the value).
  Note: This checks for key presence, not value presence.

  Examples:
    (contains? {:a 1 :b 2} :a)
    # => true

    (contains? {:a 1 :b 2} :c)
    # => false

    (contains? [10 20 30] 1)
    # => true (index 1 exists)

    (contains? [10 20 30] 20)
    # => false (20 is a value, not an index)

    (contains? #{:a :b :c} :b)
    # => true

  See also: get, in?, some"
  [coll key]
  (cond
    (php/instanceof coll ContainsInterface) (php/-> coll (contains key))
    (php/is_array coll) (php/array_key_exists key coll)
    (throw (php/new InvalidArgumentException (php/. "cannot call 'contains?' on " (php/get_class coll))))))

(defn compare
  "Wrapper for PHP's spaceship operator (`php/<=>`).
  Returns an integer less than, equal to, or greater than zero
  when `x` is less than, equal to, or greater than `y`, respectively."
  {:inline (fn [x y] `(php/<=> ,x ,y))}
  [x y]
  (php/<=> x y))

# --------------
# Type operation
# --------------

(defn type
  "Returns the type of `x`. The following types can be returned:

* `:vector`
* `:list`
* `:struct`
* `:hash-map`
* `:set`
* `:keyword`
* `:symbol`
* `:var`
* `:int`
* `:float`
* `:string`
* `:nil`
* `:boolean`
* `:function`
* `:php/array`
* `:php/resource`
* `:php/object`
* `:unknown`"
  [x]
  (cond
    (php/instanceof x PersistentVectorInterface)  :vector
    (php/instanceof x PersistentListInterface)    :list
    (php/instanceof x AbstractPersistentStruct)   :struct
    (php/instanceof x PersistentMapInterface)     :hash-map
    (php/instanceof x PersistentHashSetInterface) :set
    (php/instanceof x Keyword)                    :keyword
    (php/instanceof x Symbol)                     :symbol
    (php/instanceof x Variable)                   :var
    (php/is_int x)                                :int
    (php/is_float x)                              :float
    (php/is_string x)                             :string
    (php/is_null x)                               :nil
    (php/is_bool x)                               :boolean
    (php/is_callable x)                           :function
    (php/is_array x)                              :php/array
    (php/is_resource x)                           :php/resource
    (php/is_object x)                             :php/object
    :unknown))

(defn float?
  "Returns true if `x` is float point number, false otherwise."
  [x]
  (= (type x) :float))

(defn int?
  "Returns true if `x` is an integer number, false otherwise."
  [x]
  (= (type x) :int))

(defn number?
  "Returns true if `x` is a number, false otherwise."
  [x]
  (or (= (type x) :int) (= (type x) :float)))

(defn string?
  "Returns true if `x` is a string, false otherwise."
  [x]
  (= (type x) :string))

(defn keyword?
  "Returns true if `x` is a keyword, false otherwise."
  [x]
  (= (type x) :keyword))

(defn symbol?
  "Returns true if `x` is a symbol, false otherwise."
  [x]
  (= (type x) :symbol))

(defn function?
  "Returns true if `x` is a function, false otherwise."
  [x]
  (= (type x) :function))

(defn struct?
  "Returns true if `x` is a struct, false otherwise."
  [x]
  (= (type x) :struct))

(defn hash-map?
  "Returns true if `x` is a hash map, false otherwise."
  [x]
  (= (type x) :hash-map))

(defn vector?
  "Returns true if `x` is a vector, false otherwise."
  [x]
  (= (type x) :vector))

(defn list?
  "Returns true if `x` is a list, false otherwise."
  [x]
  (= (type x) :list))

(defn boolean?
  "Returns true if `x` is a boolean, false otherwise."
  [x]
  (= (type x) :boolean))

(defn php-array?
  "Returns true if `x` is a PHP Array, false otherwise."
  [x]
  (= (type x) :php/array))

(defn php-resource?
  "Returns true if `x` is a PHP resource, false otherwise."
  [x]
  (= (type x) :php/resource))

(defn php-object?
  "Returns true if `x` is a PHP object, false otherwise."
  [x]
  (= (type x) :php/object))

(defn empty?
  "Returns true if x would be 0, \"\" or empty collection, false otherwise."
  [x]
  (if (php/is_numeric x)
    (= 0 x)
    (if (php/is_string x)
      (true? (php/empty x))
      (= 0 (count x)))))

(defn not-empty
  "Returns `coll` if it contains elements, otherwise nil."
  [coll]
  (if (empty? coll)
    nil
    coll))

(defn- indexed-php-array?
  [x]
  (and
   (= (type x) :php/array)
   (or
    (php/empty x)
    (php/=== (php/array_keys x) (php/range 0 (php/- (php/count x) 1))))))

(defn indexed?
  "Returns true if `x` is indexed sequence, false otherwise."
  [x]
  (let [t (type x)]
    (or
     (= t :list)
     (= t :vector)
     (indexed-php-array? x))))

(defn associative?
  "Returns true if `x` is an associative data structure, false otherwise."
  [x]
  (let [t (type x)]
    (or
     (= t :hash-map)
     (= t :struct)
     (and (= t :php/array) (not (indexed-php-array? x))))))

(defn set?
  "Returns true if `x` is a set, false otherwise."
  [x]
  (= (type x) :set))

# ------------------
# Sequence operation
# ------------------

(defn peek
  "Returns the last element of a sequence."
  [coll]
  (php/aget coll (php/- (count coll) 1)))


(defn push
  "Inserts `x` at the end of the sequence `coll`."
  [coll x]
  (cond
    (php-array? coll) (do (php/apush coll x) coll)
    (or (vector? coll) (php/instanceof coll TransientVectorInterface)) (php/-> coll (append x))
    (or (set? coll) (php/instanceof coll TransientHashSetInterface)) (php/-> coll (add x))
    (php/instanceof coll PushInterface) (php/-> coll (push x))
    (throw (php/new InvalidArgumentException
                    (str "Cannot push on type " (type coll))))))

(defn pop
  "Removes the last element of the array `coll`. If the array is empty returns nil."
  [^:reference coll]
  (cond
    (php-array? coll) (php/array_pop coll)
    (php/instanceof coll PopInterface) (php/-> coll (pop))
    (throw (php/new InvalidArgumentException "Cannot pop"))))

(defn remove
  "Removes up to `n` element from array `coll` starting at index `offset`."
  [^:reference coll offset & [n]]
  (cond
    (php-array? coll) (if n (php/array_splice coll offset n) (php/array_splice coll offset))
    (php/instanceof coll RemoveInterface) (php/-> coll (remove offset n))
    (throw (php/new InvalidArgumentException "Cannot remove"))))

(defn get
  "Gets the value at key in a collection. Returns default if not found.

  Example:
    (get {:a 1} :a)
    # => 1"
  [ds k & [opt]]
  (cond
    (or (set? ds)
        (php/instanceof ds PersistentHashSetInterface)
        (php/instanceof ds TransientHashSetInterface))
    (if (php/-> ds (contains k))
      k
      opt)

    (php/instanceof ds LazySeqInterface)
    (loop [i k
           s ds]
      (if (or (nil? s) (php/< i 0))
        opt
        (if (php/=== i 0)
          (let [res (first s)]
            (if (nil? res)
              opt
              res))
          (recur (php/- i 1) (next s)))))

    :else
    (let [res (php/aget ds k)]
      (if (nil? res)
        opt
        res))))

(defn assoc
  "Associates a value with a key in a collection.

  Example:
    (assoc {:a 1} :b 2)
    # => {:a 1 :b 2}"
  [ds key value]
  (cond
    (php-array? ds)
    (throw (php/new InvalidArgumentException "Cannot call assoc on pure PHP arrays. Use (php/aset ds key value)"))

    (or (struct? ds) (hash-map? ds) (php/instanceof ds TransientMapInterface))
    (php/-> ds (put key value))

    (or (vector? ds) (php/instanceof ds TransientVectorInterface))
    (php/-> ds (update key value))

    (do
      (php/aset ds key value)
      ds)))

(defn put
  "Puts `value` mapped to `key` on the datastructure `ds`. Returns `ds`.

  Deprecated: Use `assoc` instead."
  {:deprecated "0.25.0"
   :superseded-by "assoc"}
  [ds key value]
  (assoc ds key value))

(defn dissoc
  "Dissociates `key` from the datastructure `ds`. Returns `ds` without `key`."
  [ds key]
  (cond
    (php-array? ds)
    (throw (php/new InvalidArgumentException "Cannot call dissoc on pure PHP arrays. Use (php/aunset ds key)"))

    (or (hash-map? ds) (php/instanceof ds TransientMapInterface))
    (php/-> ds (remove key))

    (or (set? ds) (php/instanceof ds TransientHashSetInterface))
    (php/-> ds (remove key))

    (let [x ds]
      (php/aunset x key)
      x)))

(defn unset
  "Returns `ds` without `key`.

  Deprecated: Use `dissoc` instead."
  {:deprecated "0.25.0"
   :superseded-by "dissoc"}
  [ds key]
  (dissoc ds key))

# --------
# Variable
# --------

(defn var
  "Creates a new variable with the given value."
  [value]
  (php/:: Phel (variable value)))

(defn var?
  "Checks if the given value is a variable."
  [x]
  (php/instanceof x Variable))

(defn set!
  "Sets a new value to the given variable."
  [variable value]
  (php/-> variable (set value)))

(defn deref
  "Return the value inside the variable."
  [variable]
  (php/-> variable (deref)))

(defn swap!
  "Swaps the value of the variable to `(apply f current-value args)`. Returns the values that are swapped in."
  [variable f & args]
  (let [current (deref variable)
        next (apply f current args)]
    (set! variable next)
    next))

# --------
# For loop
# --------

(defn- lazy-seq-from-generator
  "Wraps a PHP Generator in a ChunkedSeq for efficient lazy evaluation.
  ChunkedSeq realizes elements in batches for better performance."
  [generator]
  (php/:: ChunkedSeq (fromGenerator
                      (php/new Hasher)
                      (php/new Equalizer)
                      generator)))

(defn range
  "Creates a lazy sequence of numbers from start to end (exclusive).

  Example:
    (range 5)
    # => (0 1 2 3 4)"
  [a & rest]
  (case (count rest)
    0 (lazy-seq-from-generator (php/:: Generators (range 0 a 1)))
    1 (lazy-seq-from-generator (php/:: Generators (range a (get rest 0) 1)))
    2 (lazy-seq-from-generator (php/:: Generators (range a (get rest 0) (get rest 1))))
    (throw (php/new InvalidArgumentException "Range function expects one, two or three arguments"))))

(def- for-options (set :reduce))

(defn- for-builder-options [head i initial-options]
  (if (<= (count head) i)
    initial-options
    (let [binding (php/aget head i)
          verb (php/aget head (php/+ i 1))]
      (if (keyword? binding)
        (case binding
          :reduce (for-builder-options head (php/+ i 2) (assoc initial-options :reduce verb))
          (for-builder-options head (php/+ i 2) initial-options))
        (for-builder-options head (php/+ i 3) initial-options)))))

(defn- for-builder [body head i]
  (if (<= (count head) i)
    # No more heads, return the body
    body

    # Handle heads
    (let [binding (php/aget head i)
          verb (php/aget head (php/+ i 1))]
      (cond
        # Case 1: Options
        (and (keyword? binding) (contains? for-options binding))
        (for-builder body head (php/+ i 2))

        # Case 2: Modifiers
        (keyword? binding)
        (let [rest (for-builder body head (php/+ i 2))]
          (case binding
            :while  `(if ,verb ,rest php/break)
            :let    `(let ,verb ,rest)
            :when   `(when ,verb ,rest)
            (throw (php/new InvalidArgumentException (str "This modifier is not supported in for loop: " verb)))))

        # Case 3: Verbs
        (let [object (php/aget head (php/+ i 2))
              rest (for-builder body head (php/+ i 3))
              value-sym (gensym)]
          (case verb
            :range  `(foreach [,binding (apply range ,object)] ,rest)
            :in     `(foreach [,value-sym ,object] (let [,binding ,value-sym] ,rest))
            :keys   (let [key-sym (gensym)]
                      `(foreach [,key-sym ,value-sym ,object] (let [,binding ,key-sym] ,rest)))
            :pairs  (let [key-sym (gensym)]
                      `(foreach [,key-sym ,value-sym ,object]
                         (let [,binding [,key-sym ,value-sym]] ,rest)))
            (throw (php/new InvalidArgumentException (str "This verb is not supported in for loop " verb)))))))))

(defmacro for
  "List comprehension. The head of the loop is a vector that contains a
  sequence of bindings modifiers and options. A binding is a sequence of three
  values `binding :verb expr`. Where `binding` is a binding as
  in let and `:verb` is one of the following keywords:

  * `:range` loop over a range by using the range function.
  * `:in` loops over all values of a collection.
  * `:keys` loops over all keys/indexes of a collection.
  * `:pairs` loops over all key-value pairs of a collection.

  After each loop binding, additional modifiers can be applied. Modifiers
  have the form `:modifier argument`. The following modifiers are supported:

  * `:while` breaks the loop if the expression is falsy.
  * `:let` defines additional bindings.
  * `:when` only evaluates the loop body if the condition is true.

  Finally, additional options can be set:

  * `:reduce [accumulator initial-value]` Instead of returning a list,
     it reduces the values into `accumulator`. Initially `accumulator`
     is bound to `initial-value`."
  [head & body]
  (let [res-sym (gensym "res__")
        acc-sym (gensym "acc__")
        options (for-builder-options head 0 {})
        swap-body (if (:reduce options)
                    (let [[sym _] (:reduce options)]
                      `(swap! ,res-sym (fn [,sym] (do ,@body))))
                    `(swap! ,res-sym (fn [,acc-sym] (push ,acc-sym (do ,@body)))))
        init (if (:reduce options)
               (second (:reduce options))
               [])
        loop-body (for-builder swap-body head 0)]
    `(let [,res-sym (var ,init)]
       ,loop-body
       (deref ,res-sym))))

(defmacro dofor
  "Repeatedly executes body for side effects with bindings and modifiers as
  provided by for. Returns nil."
  [head & body]
  (for-builder `(do ,@body) head 0))

(defmacro doseq
  "Alias for `dofor`."
  [seq-exprs & body]
  `(dofor ,seq-exprs ,@body))

# ------------------
# Sequence functions
# ------------------

(defn map
  "Returns a lazy sequence of the result of applying `f` to all of the first items in each coll,
   followed by applying `f` to all the second items in each coll until anyone of the colls is exhausted.

  When given a single collection, applies the function to each element.
  With multiple collections, applies the function to corresponding elements from each collection,
  stopping when the shortest collection is exhausted.

  Examples:
    (map inc [1 2 3])
    # => (2 3 4)

    (map #(* % 2) [1 2 3 4])
    # => (2 4 6 8)

    (map + [1 2 3] [10 20 30])
    # => (11 22 33)

    (map str [\"a\" \"b\" \"c\"] [1 2 3])
    # => (\"a1\" \"b2\" \"c3\")

    (map list [1 2] [3 4] [5 6])
    # => ((1 3 5) (2 4 6))

  See also: filter, reduce, map-indexed, mapcat"
  [f & colls]
  (case (count colls)
    0 (throw (php/new InvalidArgumentException "expected at least one indexed collection in map"))
    1 (let [coll (first colls)]
        (if (empty? coll)
          []
          (with-meta coll (lazy-seq-from-generator (php/:: Generators (map f coll))))))
    (let [result (lazy-seq-from-generator
                  (php/call_user_func_array
                   (php/array "\\Phel\\Lang\\Generators" "mapMulti")
                   (php/array_merge (php/array f) (apply php/array colls))))]
      (if (php/=== nil result)
        []
        (with-meta (first colls) result)))))

(defn map-indexed
  "Applies `f` to each element in `coll`. `f` is a two-argument function. The first argument
  is an index of the element in the sequence and the second element is the element itself.

  Similar to `map`, but the function receives both the index and the element.
  Useful when you need to know the position of each element during transformation.

  Examples:
    (map-indexed (fn [i x] [i x]) [\"a\" \"b\" \"c\"])
    # => ([0 \"a\"] [1 \"b\"] [2 \"c\"])

    (map-indexed * [10 20 30])
    # => (0 20 60)  ; index * value

    (map-indexed (fn [i x] (str i \": \" x)) [\"apple\" \"banana\" \"cherry\"])
    # => (\"0: apple\" \"1: banana\" \"2: cherry\")

  See also: map, keep-indexed, filter"
  [f coll]
  (let [result (for [[k v] :pairs coll] (f k v))]
    (with-meta coll result)))

(defn mapcat
  "Applies `f` on all colls and concatenate the result.

  Maps a function over one or more collections and concatenates the results.
  The function should return a collection for each input element.
  Equivalent to `(apply concat (map f colls))`.

  Examples:
    (mapcat reverse [[1 2] [3 4] [5 6]])
    # => (2 1 4 3 6 5)

    (mapcat (fn [x] [x (- x)]) [1 2 3])
    # => (1 -1 2 -2 3 -3)

    (mapcat list [:a :b] [1 2])
    # => (:a 1 :b 2)

  See also: map, concat, flatten"
  [f & colls]
  (let [result (apply concat [] (apply map f colls))]
    (if (empty? colls)
      result
      (with-meta (first colls) result))))

(defn reduce
  "Reduces a collection to a single value by repeatedly applying a function.

  (reduce f coll) - Applies f to the first 2 items, then to that result and the 3rd item, etc.
    If coll is empty, returns (f) with no arguments.
    If coll has only 1 item, returns that item without calling f.

  (reduce f val coll) - Applies f to val and the first item, then to that result and the 2nd item, etc.
    If coll is empty, returns val without calling f.

  The function f should take 2 arguments: an accumulator and the current element.

  Examples:
    (reduce + [1 2 3 4])
    # => 10

    (reduce * [2 3 4])
    # => 24

    (reduce + 100 [1 2 3])
    # => 106 (starts with 100)

    (reduce conj [] [1 2 3])
    # => [1 2 3]

    (reduce (fn [acc x] (+ acc (* x x))) 0 [1 2 3 4])
    # => 30 (sum of squares)

  See also: map, filter, into, transduce"
  [f & args]
  (case (count args)
    1 (let [coll (first args)]
        (if (empty? coll)
          (f)
          (reduce f (first coll) (next coll))))
    2 (let [val (first args)
            coll (second args)]
        (for [x :in coll :reduce [acc val]]
          (f acc x)))
    (throw (php/new InvalidArgumentException "expected 2 or 3 arguments in reduce"))))

(defn into
  "Returns `to` with all elements of `from` added.

   When `from` is associative, it is treated as a sequence of key-value pairs.
   Supports persistent and transient collections."
  [to & rest]
  (case (count rest)
    0 to
    1 (let [from (first rest)]
        (if (php/=== nil from)
          to
          (let [entries (if (associative? from)
                          (for [entry :pairs from] entry)
                          from)
                assoc-entry (fn [acc entry]
                              (if (indexed? entry)
                                (if (php/!= (count entry) 2)
                                  (throw (php/new InvalidArgumentException
                                                  "into expects a collection of [key value] pairs"))
                                  (let [k (first entry)
                                        v (second entry)]
                                    (if (php-array? acc)
                                      (do
                                        (php/aset acc k v)
                                        acc)
                                      (assoc acc k v))))
                                (throw (php/new InvalidArgumentException
                                                "into expects a collection of [key value] pairs"))))
                map-target? (or (associative? to) (php/instanceof to TransientMapInterface))]
            (cond
              map-target?
              (for [entry :in entries
                    :reduce [acc to]]
                (assoc-entry acc entry))

              (php/instanceof to TransientVectorInterface)
              (for [value :in entries
                    :reduce [acc to]]
                (push acc value))

              (php/instanceof to TransientHashSetInterface)
              (for [value :in entries
                    :reduce [acc to]]
                (push acc value))

              (php/instanceof to PushInterface)
              (for [value :in entries
                    :reduce [acc to]]
                (push acc value))

              (php/instanceof to ConcatInterface)
              (php/-> to (concat (apply php/array entries)))

              (php/is_array to)
              (concat to entries)

              (throw (php/new InvalidArgumentException
                              (php/. "Cannot convert into type " (type to))))))))
    (throw (php/new InvalidArgumentException "into expects one or two arguments"))))

(defn slice
  "Extract a slice of `coll`."
  [coll & [offset & [length]]]
  (cond
    (php-array? coll) (php/array_slice coll offset length)
    (php/instanceof coll SliceInterface) (php/-> coll (slice offset length))
    (throw (php/new InvalidArgumentException "Cannot slice"))))

(defn get-in
  "Access a value in a nested data structure. Looks into the data structure via a sequence of keys."
  [ds ks & [opt]]
  (let [res (reduce get ds ks)]
    (if (nil? res) opt res)))

(defn assoc-in
  "Associates a value in a nested data structure."
  [ds [k & ks] v]
  (if-not (nil? ks)
    (assoc ds k (assoc-in (get ds k {}) ks v))
    (assoc ds k v)))

(defn put-in
  "Puts a value into a nested data structure.

  Deprecated: Use `assoc-in` instead."
  {:deprecated "0.25.0"
   :superseded-by "assoc-in"}
  [ds ks v]
  (assoc-in ds ks v))

(defn update
  "Updates a value in a datastructure by applying `f` to the current element and replacing it with the result of `f`."
  [ds k f & args]
  (assoc ds k (apply f (get ds k) args)))

(defn update-in
  "Updates a value into a nested data structure."
  [ds [k & ks] f & args]
  (if ks
    (assoc ds k (apply update-in (get ds k {}) ks f args))
    (let [current (get ds k)] # Extract value first for possible call-by-reference
      (assoc ds k (apply f current args)))))

(defn dissoc-in
  "Dissociates a value from a nested data structure."
  [ds [k & ks]]
  (if ks
    (let [sub (get ds k)]
      (if (nil? sub)
        ds
        (assoc ds k (dissoc-in sub ks))))
    (dissoc ds k)))

(defn unset-in
  "Removes a value from a nested data structure.

  Deprecated: Use `dissoc-in` instead."
  {:deprecated "0.25.0"
   :superseded-by "dissoc-in"}
  [ds ks]
  (dissoc-in ds ks))

(defn drop
  "Drops the first `n` elements of `coll`. Returns a lazy sequence."
  [n coll]
  (if (nil? coll)
    []
    (let [n (if (php/< n 0) 0 n)]
      (if (php/=== n 0)
        coll
        (let [result (lazy-seq-from-generator (php/:: Generators (drop n coll)))]
          (with-meta coll (or result [])))))))

(defn drop-last
  "Drops the last `n` elements of `coll`."
  [n coll]
  (let [n (if (php/< n 0) 0 n)
        end (php/- (count coll) n)]
    (slice coll 0 (php/max 0 end))))

(defn last
  "Returns the last element of `coll` or nil if `coll` is empty or nil."
  [coll]
  (if (or (php/=== coll nil) (empty? coll))
    nil
    (peek coll)))

(defn butlast
  "Returns all but the last item in `coll`."
  [coll]
  (drop-last 1 coll))

(defn drop-while
  "Drops all elements at the front of `coll` where `(pred x)` is true. Returns a lazy sequence."
  [pred coll]
  (if (nil? coll)
    []
    (let [result (lazy-seq-from-generator (php/:: Generators (dropWhile pred coll)))]
      (with-meta coll (or result [])))))

(defn take
  "Takes the first `n` elements of `coll`.

  Note: Metadata preservation works with inline calls but may be lost when binding
  to variables. Use inline calls or force realization with doall if metadata needed.
  See local/investigate-metadata-binding-issue.md for details."
  [n coll]
  (let [n (if (php/< n 0) 0 n)]
    (if (php/=== n 0)
      []
      (let [result (lazy-seq-from-generator (php/:: Generators (take n coll)))]
        (if (nil? result)
          []
          (with-meta coll result))))))

(defn take-last
  "Takes the last `n` elements of `coll`."
  [n coll]
  (if (php/<= n 0) [] (slice coll (php/* -1 n))))

(defn take-while
  "Takes all elements at the front of `coll` where `(pred x)` is true. Returns a lazy sequence."
  [pred coll]
  (if (nil? coll)
    []
    (let [result (lazy-seq-from-generator (php/:: Generators (takeWhile pred coll)))]
      (with-meta coll (or result [])))))

(defn take-nth
  "Returns every nth item in `coll`. Returns a lazy sequence."
  [n coll]
  (when (< n 1)
    (throw (php/new InvalidArgumentException "First argument of 'take-nth must be greater than 0")))
  (if (nil? coll)
    []
    (let [result (lazy-seq-from-generator (php/:: Generators (takeNth n coll)))]
      (with-meta coll (or result [])))))

(defn filter
  "Returns a lazy sequence of elements of `coll` where `(pred x)` is true.

  Only elements for which the predicate returns a truthy value are included
  in the result. The predicate is called with each element as its argument.

  Examples:
    (filter even? [1 2 3 4 5 6])
    # => (2 4 6)

    (filter pos? [-2 -1 0 1 2])
    # => (1 2)

    (filter #(> % 10) [5 15 8 20 3])
    # => (15 20)

    (filter string? [1 \"hello\" 2 \"world\" 3])
    # => (\"hello\" \"world\")

  Note: Metadata preservation works with inline calls but may be lost when binding
  to variables. Use inline calls or force realization with doall if metadata needed.
  See local/investigate-metadata-binding-issue.md for details.

  See also: remove, keep, map, some"
  [pred coll]
  (let [result (lazy-seq-from-generator (php/:: Generators (filter pred coll)))]
    (if (nil? result)
      []
      (with-meta coll result))))

(defn keep
  "Returns a lazy sequence of non-nil results of `(pred x)`.

  Unlike `filter`, which tests elements with a predicate, `keep` applies a function
  and keeps only the non-nil results. Useful for transforming and filtering in one step.

  Examples:
    (keep #(when (even? %) (* % %)) [1 2 3 4 5])
    # => (4 16)  ; squares of even numbers

    (keep second [[1 2] [3] [4 5]])
    # => (2 5)  ; second elements that exist

    (keep {:a 1 :b 2} [:a :c :b])
    # => (1 2)  ; maps can be used as lookup functions

  See also: filter, map, remove, keep-indexed"
  [pred coll]
  (if (nil? coll)
    []
    (let [result (lazy-seq-from-generator (php/:: Generators (keep pred coll)))]
      (with-meta coll (or result [])))))

(defn keep-indexed
  "Returns a lazy sequence of non-nil results of `(pred i x)`."
  [pred coll]
  (if (nil? coll)
    []
    (let [result (lazy-seq-from-generator (php/:: Generators (keepIndexed pred coll)))]
      (with-meta coll (or result [])))))

(defn find
  "Returns the first item in `coll` where `(pred item)` evaluates to true."
  [pred coll]
  (loop [s coll]
    (if (empty? s)
      nil
      (if (pred (first s))
        (first s)
        (recur (next s))))))

(defn find-index
  "Returns the index of the first item in `coll` where `(pred index item)` evaluates to true."
  [pred coll]
  (loop [s coll
         i 0]
    (if (empty? s)
      nil
      (if (pred (first s))
        i
        (recur (next s) (php/+ i 1))))))

(defn distinct
  "Returns a lazy sequence with duplicated values removed in `coll`."
  [coll]
  (if (nil? coll)
    []
    (let [result (lazy-seq-from-generator (php/:: Generators (distinct coll)))]
      (with-meta coll (or result [])))))


(defn reverse
  "Reverses the order of the elements in the given sequence."
  [coll]
  (let [result
        (for [i :range [(php/- (count coll) 1) -1 -1]
              :reduce [ret []]]
          (push ret (get coll i)))]
    (with-meta coll result)))

(defn interleave
  "Returns a vector with the first items of each col, then the second items, etc."
  [& colls]
  (if (empty? colls)
    []
    (let [first-coll (first colls)
          size (count first-coll)
          result (loop [i 0
                        res []]
                   (let [nths (apply vector (map |(get $ i) colls))]
                     (if (<= size i)
                       res
                       (recur (php/+ i 1) (concat res nths)))))]
      (with-meta first-coll result))))

(defn interpose
  "Returns a vector of elements separated by `sep`."
  [sep coll]
  (let [result
        (persistent
         (for [[k v] :pairs coll
               :reduce [res (transient [])]]
           (when (> k 0)
             (push res sep v))
           (push res v)))]
    (with-meta coll result)))

(defn frequencies
  "Returns a map from distinct items in `coll` to the number of times they appear."
  [coll]
  (let [result (for [x :in coll
                     :reduce [res {}]]
                 (let [n (get res x 0)]
                   (assoc res x (php/+ 1 n))))]
    (with-meta coll result)))

(defn keys
  "Returns a sequence of all keys in a map.

  Example:
    (keys {:a 1 :b 2})
    # => (:a :b)"
  [coll]
  (let [result (for [k :keys coll] k)]
    (with-meta coll result)))

(defn values
  "Returns a sequence of all values in a map.

  Example:
    (values {:a 1 :b 2})
    # => (1 2)"
  [coll]
  (let [result (for [x :in coll] x)]
    (with-meta coll result)))

(defn pairs
  "Gets the pairs of an associative data structure."
  [coll]
  (let [result (for [p :pairs coll] p)]
    (with-meta coll result)))

(defn kvs
  "Returns a vector of key-value pairs like `[k1 v1 k2 v2 k3 v3 ...]`."
  [coll]
  (let [result
        (persistent
         (for [[k v] :pairs coll
               :reduce [res (transient [])]]
           (push res k)
           (push res v)))]
    (with-meta coll result)))

(defn to-php-array
  "Create a PHP Array from a sequential data structure."
  [coll]
  (apply php/array coll))

(defn php-array-to-map
  "Converts a PHP Array to a map."
  [arr]
  (let [res (transient {})]
    (foreach [k v arr]
      (assoc res k v))
    (persistent res)))


(defn phel->php
  "Recursively converts a Phel data structure to a PHP array."
  [x]
  (cond
    (php-array? x)
    (let [arr (php/array)]
      (foreach [k v x]
        (php/aset arr k (phel->php v)))
      arr)

    (indexed? x)
    (let [arr (php/array)]
      (foreach [v x]
        (php/apush arr (phel->php v)))
      arr)

    (associative? x)
    (let [arr (php/array)]
      (foreach [k v x]
        (php/aset arr (name k) (phel->php v)))
      arr)

    (set? x)
    (let [arr (php/array)]
      (foreach [v x]
        (php/apush arr (phel->php v)))
      arr)

    true x))

(defn php->phel
  "Recursively converts a PHP array to Phel data structures."
  [x]
  (cond
    (indexed-php-array? x)
    (let [res (transient [])]
      (foreach [v x]
        (push res (php->phel v)))
      (persistent res))

    (php-array? x)
    (let [res (transient {})]
      (foreach [k v x]
        (assoc res k (php->phel v)))
      (persistent res))

    true x))

(defn contains-value?
  "Returns true if the value is present in the given collection, otherwise returns false."
  [coll val]
  (some? |(= $ val) (values coll)))

(defn sort
  "Returns a sorted vector. If no comparator is supplied compare is used."
  [coll & [comp]]
  (let [php-array (to-php-array coll)]
    (php/usort php-array (or comp compare))
    (with-meta coll (apply vector php-array))))

(defn sort-by
  "Returns a sorted vector where the sort order is determined by comparing
  `(keyfn item)`. If no comparator is supplied compare is used."
  [keyfn coll & [comp]]
  (let [php-array (to-php-array coll)
        cmp (or comp compare)]
    (php/usort php-array |(cmp (keyfn $1) (keyfn $2)))
    (with-meta coll (apply vector php-array))))

(defn shuffle
  "Returns a random permutation of coll."
  [coll]
  (let [php-array (to-php-array coll)]
    (php/shuffle php-array)
    (with-meta coll (apply vector php-array))))

(defn repeat
  "Returns a vector of length n where every element is x.
  With one argument returns an infinite lazy sequence of x."
  [a & rest]
  (case (count rest)
    0 (lazy-seq-from-generator (php/:: Generators (repeat a)))
    1 (for [i :range [a]] (get rest 0))
    (throw (php/new InvalidArgumentException "repeat expects one or two arguments"))))

(defn repeatedly
  "Returns a vector of length n with values produced by repeatedly calling f.
  With one argument returns an infinite lazy sequence of calls to f."
  [a & rest]
  (case (count rest)
    0 (lazy-seq-from-generator (php/:: Generators (repeatedly a)))
    1 (let [n a
            f (get rest 0)]
        (for [i :range [n]] (f)))
    (throw (php/new InvalidArgumentException "repeatedly expects one or two arguments"))))

(defmacro lazy-seq
  "Takes a body of expressions that returns a sequence or nil, and yields
  a LazySeq that will invoke the body only the first time the sequence is accessed,
  caching the result for subsequent accesses.

  This is the fundamental building block for creating custom lazy sequences.
  The body should return either a sequence (list, vector, or another lazy-seq) or nil.

  Example:
    (defn my-range [n]
      (when (> n 0)
        (lazy-seq (cons n (my-range (dec n))))))"
  [& body]
  `(php/new \Phel\Lang\Collections\LazySeq\LazySeq
            (php/new \Phel\Lang\Hasher)
            (php/new \Phel\Lang\Equalizer)
            (fn [] ,@body)))

(defmacro lazy-cat
  "Concatenates the supplied collections into a lazy sequence.

  Note: This macro simply expands to `concat`, so all arguments are evaluated
  eagerly before concatenation. It is suitable for combining already-realized
  or finite lazy sequences, but NOT for building recursive infinite sequences.

  For recursive infinite sequences, use `cons` within `lazy-seq` instead.

  Example:
    (lazy-cat [1 2] [3 4])           # => (1 2 3 4)
    (lazy-cat (range 3) (range 3 6)) # => (0 1 2 3 4 5)

    # For recursive sequences, use cons:
    (defn ints [n] (lazy-seq (cons n (ints (inc n)))))
    (take 5 (ints 0))  # => [0 1 2 3 4]"
  [& colls]
  (apply list 'concat colls))

(defn iterate
  "Returns an infinite lazy sequence of x, (f x), (f (f x)), and so on."
  [f x]
  (lazy-seq-from-generator (php/:: Generators (iterate f x))))

(defn cycle
  "Returns an infinite lazy sequence that cycles through the elements of collection."
  [coll]
  (if (empty? coll)
    []
    (lazy-seq-from-generator (php/:: Generators (cycle coll)))))

(def concat
  "Concatenates multiple sequential data structures. Returns a lazy sequence.

  When given no arguments, returns an empty list.
  When given one or more collections, lazily yields all elements from each in order.
  Works with infinite sequences."
  (fn [& colls]
    (if (php/=== nil colls)
      '()
      (let [result (lazy-seq-from-generator
                    (php/call_user_func_array
                     (php/array "\\Phel\\Lang\\Generators" "concat")
                     (apply php/array colls)))]
        (if (php/=== nil result)
          '()
          result)))))

(def mapcat
  "Maps a function over a collection and concatenates the results. Returns a lazy sequence.

  Applies `f` to each element of the collection, where `f` should return a collection.
  All resulting collections are concatenated into a single lazy sequence.
  Works with infinite sequences.

  Example: (mapcat reverse [[1 2] [3 4]]) ; => (2 1 4 3)"
  (fn [f coll]
    (if (php/=== nil coll)
      '()
      (let [result (lazy-seq-from-generator
                    (php/:: \Phel\Lang\Generators (mapcat f coll)))]
        (if (php/=== nil result)
          '()
          (with-meta coll result))))))

(def interpose
  "Returns elements separated by a separator. Returns a lazy sequence.

  Inserts `sep` between each element of the collection.
  Works with infinite sequences.

  Example: (interpose 0 [1 2 3]) ; => (1 0 2 0 3)"
  (fn [sep coll]
    (if (php/=== nil coll)
      '()
      (let [result (lazy-seq-from-generator
                    (php/:: \Phel\Lang\Generators (interpose sep coll)))]
        (if (php/=== nil result)
          '()
          (with-meta coll result))))))

(def map-indexed
  "Maps a function over a collection with index. Returns a lazy sequence.

  Applies `f` to each element in `xs`. `f` is a two-argument function where
  the first argument is the index (0-based) and the second is the element itself.
  Works with infinite sequences.

  Example: (map-indexed vector [:a :b :c]) ; => ([0 :a] [1 :b] [2 :c])"
  (fn [f coll]
    (if (php/=== nil coll)
      '()
      (let [result (lazy-seq-from-generator
                    (php/:: \Phel\Lang\Generators (mapIndexed f coll)))]
        (if (php/=== nil result)
          '()
          (with-meta coll result))))))

# Redefine interleave as lazy
(def interleave
  "Interleaves multiple collections. Returns a lazy sequence.

  Returns elements by taking one from each collection in turn.
  Pads with nil when collections have different lengths.
  Works with infinite sequences.

  Example: (interleave [1 2 3] [:a :b :c]) ; => (1 :a 2 :b 3 :c)"
  (fn [& colls]
    (if (php/=== nil colls)
      '()
      (let [result (lazy-seq-from-generator
                    (php/call_user_func_array
                     (php/array "\\Phel\\Lang\\Generators" "interleave")
                     (apply php/array colls)))]
        (if (php/=== nil result)
          '()
          (with-meta (first colls) result))))))

(defn doall
  "Forces realization of a lazy sequence and returns it as a vector.
  Useful when you need to force side effects or ensure computation happens immediately.

  Example: (doall (map println [1 2 3])) ; ensures println executes"
  [coll]
  (if (php/instanceof coll LazySeqInterface)
    (let [arr (php/-> coll (toArray))]
      (if (php/empty arr)
        nil
        (apply vector arr)))
    coll))

(defn dorun
  "Forces realization of a lazy sequence for side effects only, returns nil.
  More efficient than doall when you don't need the results.

  Example: (dorun (map println [1 2 3])) ; ensures println executes, returns nil"
  [coll]
  (if (php/instanceof coll LazySeqInterface)
    (do
      (doseq [x :in coll] x)
      nil)
    nil))

(defn realized?
  "Returns true if a lazy sequence has been realized, false otherwise.
  Non-lazy collections (vectors, lists, etc.) always return true.

  Example: (realized? (take 5 (iterate inc 1))) ; => false initially"
  [coll]
  (if (php/instanceof coll LazySeqInterface)
    (php/-> coll (isRealized))
    true))

(defn group-by
  "Returns a map of the elements of coll keyed by the result of
  f on each element."
  [f coll]
  (persistent
   (for [x :in coll
         :let [k (f x)]
         :reduce [res (transient {})]]
     (when-not (get res k)
       (assoc res k []))
     (update-in res [k] push x))))

(defn zipcoll
  "Creates a map from two sequential data structures. Return a new map."
  [a b]
  (apply hash-map (interleave a b)))

(defn zipmap
  "Returns a new map with the keys mapped to the corresponding values. Stops when the shorter of `keys` or `vals` is exhausted."
  [keys vals]
  (loop [ks keys
         vs vals
         res {}]
    (if (or (empty? ks) (empty? vs))
      res
      (recur (next ks) (next vs) (assoc res (first ks) (first vs))))))

(defn merge
  "Merges multiple maps into one new map. If a key appears in more than one
  collection, then later values replace any previous ones."
  [& maps]
  (for [map :in maps
        [k v] :pairs map
        :reduce [res {}]]
    (assoc res k v)))

(defn select-keys
  "Returns a new map including key value pairs from `m` selected with of keys `ks`."
  [m ks]
  (let [result (for [[k v] :pairs m
                     :when (contains-value? ks k)
                     :reduce [acc {}]]
                 (assoc acc k v))]
    (with-meta m result)))

(defn invert
  "Returns a new map where the keys and values are swapped. If map has
  duplicated values, some keys will be ignored."
  [map]
  (for [[k v] :pairs map
        :reduce [res {}]]
    (assoc res v k)))

(defn split-at
  "Returns a vector of `[(take n coll) (drop n coll)]`."
  [n coll]
  [(take n coll) (drop n coll)])

(defn split-with
  "Returns a vector of `[(take-while pred coll) (drop-while pred coll)]`."
  [f coll]
  [(take-while f coll) (drop-while f coll)])

(defn partition-by
  "Returns a lazy sequence of partitions. Applies `f` to each value in `coll`, splitting them each time the return value changes."
  [f coll]
  (cond
    (nil? coll) []
    (and (indexed? coll) (= 0 (count coll))) []
    true (lazy-seq-from-generator (php/:: Generators (partitionBy f coll)))))

(defn dedupe
  "Returns a lazy sequence with consecutive duplicate values removed in `coll`."
  [coll]
  (cond
    (nil? coll) []
    (and (indexed? coll) (= 0 (count coll))) []
    true (lazy-seq-from-generator (php/:: Generators (dedupe coll)))))

(defn partition
  "Partitions a collection into chunks of size n. Returns a lazy sequence.

  Only yields complete partitions. If the final partition has fewer than n elements,
  it is dropped. Works with infinite sequences.

  Example: (partition 3 [1 2 3 4 5 6 7]) ; => ([1 2 3] [4 5 6])"
  [n coll]
  (let [result (lazy-seq-from-generator
                (php/call_user_func_array
                 (php/array "\\Phel\\Lang\\Generators" "partition")
                 (php/array n coll)))]
    (if (php/=== nil result)
      '()
      (with-meta coll result))))

(defn partition-all
  "Partitions a collection into chunks of size n. Returns a lazy sequence.

  Yields all partitions including the final incomplete partition if present.
  Works with infinite sequences.

  Example: (partition-all 3 [1 2 3 4 5 6 7]) ; => ([1 2 3] [4 5 6] [7])"
  [n coll]
  (let [result (lazy-seq-from-generator
                (php/call_user_func_array
                 (php/array "\\Phel\\Lang\\Generators" "partitionAll")
                 (php/array n coll)))]
    (if (php/=== nil result)
      '()
      (with-meta coll result))))

# -------------
# Set operation
# -------------

(defn union
  "Union multiple sets into a new one."
  [& sets]
  (let [target (transient (set))]
    (foreach [s sets]
      (foreach [v s]
        (php/-> target (add v))))
    (persistent target)))

(defn- intersection-pair
  [s1 s2]
  (if (< (count s2) (count s1))
    (recur s2 s1)
    (let [result (transient s1)]
      (foreach [item s1]
        (when-not (php/-> s2 (contains item))
          (php/-> result (remove item))))
      (persistent result))))

(defn intersection
  "Intersect multiple sets into a new one."
  [set & sets]
  (reduce intersection-pair set sets))

(defn difference-pair
  [s1 s2]
  (if (< (count s1) (count s2))
    (let [result (transient s1)]
      (foreach [item s1]
        (when (php/-> s2 (contains item))
          (php/-> result (remove item))))
      (persistent result))

    (let [result (transient s1)]
      (foreach [item s2]
        (php/-> result (remove item)))
      (persistent result))))

(defn difference
  "Difference between multiple sets into a new one."
  [set & sets]
  (reduce difference-pair set sets))

(defn symmetric-difference
  "Symmetric difference between multiple sets into a new one."
  [set & sets]
  (reduce |(union (difference $1 $2) (difference $2 $1)) set sets))

# ------------------
# Function operation
# ------------------

(defn identity
  "Returns its argument."
  [x]
  x)

(defn constantly
  "Returns a function that always returns `x` and ignores any passed arguments."
  [x]
  (fn [& _] x))

(defn comp
  "Takes a list of functions and returns a function that is the composition of those functions."
  [& fs]
  (case (count fs)
    0 identity
    1 (first fs)
    2 |((first fs) (apply (second fs) $&))
    (reduce comp fs)))

(defn complement
  "Returns a function that takes the same arguments as `f` and returns the opposite truth value."
  [f]
  |(not (apply f $&)))

(defn juxt
  "Takes a list of functions and returns a new function that is the juxtaposition of those functions.
  `((juxt a b c) x) => [(a x) (b x) (c x)]`."
  [& fs]
  (fn [& args]
    (reduce
     |(push $1 (apply $2 args))
     []
     fs)))

(defn partial
  "Takes a function `f` and fewer than normal arguments of `f` and returns a function
  that a variable number of additional arguments. When call `f` will be called
  with `args` and the additional arguments."
  [f & args]
  |(apply f (concat [] args $&)))

(defn memoize
  "Returns a memoized version of the function `f`. The memoized function
  caches the return value for each set of arguments."
  [f]
  (let [memoize-cache (var {})]
    (fn [& args]
      (let [c (deref memoize-cache)]
        (if (contains? c args)
          (get c args)
          (let [res (apply f args)]
            (set! memoize-cache (assoc c args res))
            res))))))

# -----------------------
# More sequence operation
# -----------------------

(defn tree-seq
  "Returns a vector of the nodes in the tree, via a depth-first walk.
  branch? is a function with one argument that returns true if the given node
  has children.
  children must be a function with one argument that returns the children of the node.
  root the root node of the tree."
  [branch? children root]
  (let [ret (transient [])]
    (loop [stack (php/array root)]
      (if (> (count stack) 0)
        (let [node (pop stack)]
          (push ret node)
          (if (branch? node)
            (let [reversed-children (reverse (children node))]
              (foreach [child reversed-children]
                (php/apush stack child))
              (recur stack))
            (recur stack)))
        (with-meta root (persistent ret))))))

(defn flatten
  "Takes a nested sequential data structure (tree) and returns a lazy sequence of all leaf values.

  Walks the tree structure and yields all non-indexed (scalar) values.
  Returns a lazy sequence that works with infinite nested structures.

  Example: (flatten [[1 2] [3 [4 5]] 6]) ; => (1 2 3 4 5 6)"
  [coll]
  (filter
   (complement indexed?)
   (rest (tree-seq indexed? identity coll))))

(defn- merge-with-2 [f left right]
  (for [[k v] :pairs right
        :reduce [acc left]]
    (if (contains? acc k)
      (assoc acc k (f (get acc k) v))
      (assoc acc k v))))

(defn merge-with
  "Merges multiple maps into one new map. If a key appears in more than one
   collection, the result of `(f current-val next-val)` is used."
  [f & hash-maps]
  (case (count hash-maps)
    0 {}
    1 (first hash-maps)
    2 (merge-with-2 f (first hash-maps) (second hash-maps))
    (reduce (partial merge-with f) (first hash-maps) (rest hash-maps))))

(declare deep-merge)

(defn- deep-merge-2 [left right]
  (cond
    (nil? left) right
    (nil? right) left
    (and (hash-map? left) (hash-map? right)) (merge-with deep-merge left right)
    (and (set? left) (set? right)) (union left right)
    (and (vector? left) (vector? right)) (apply vector (concat left right))
    right))

(defn deep-merge
  "Recursively merges data structures."
  [& args]
  (case (count args)
    0 {}
    1 (first args)
    2 (deep-merge-2 (first args) (second args))
    (reduce deep-merge (first args) (rest args))))

# ---
# Math helpers
# ---

(defn assert-non-nil
  [& xs]
  (foreach [x xs]
    (when (php/=== nil x)
      (throw (php/new \InvalidArgumentException "Arithmetic functions do not accept nil values")))))

# -----------------
# Bitwise operation
# -----------------

(defn bit-and
  "Bitwise and."
  {:inline (fn [x y & args] `(do (assert-non-nil ,x ,y ,@args) (php/& ,x ,y ,@args)))}
  [x y & args]
  (apply assert-non-nil (concat [x y] args))
  (let [all (concat [x y] args)]
    (reduce |(php/& $1 $2) all)))

(defn bit-or
  "Bitwise or."
  {:inline (fn [x y & args] `(do (assert-non-nil ,x ,y ,@args) (php/| ,x ,y ,@args)))}
  [x y & args]
  (apply assert-non-nil (concat [x y] args))
  (let [all (concat [x y] args)]
    (reduce |(php/| $1 $2) all)))

(defn bit-xor
  "Bitwise xor."
  {:inline (fn [x y & args] `(do (assert-non-nil ,x ,y ,@args) (php/^ ,x ,y ,@args)))}
  [x y & args]
  (apply assert-non-nil (concat [x y] args))
  (let [all (concat [x y] args)]
    (reduce |(php/^ $1 $2) all)))

(defn bit-not
  "Bitwise complement."
  {:inline (fn [x] `(do (assert-non-nil ,x) (php/~ ,x)))}
  [x]
  (assert-non-nil x)
  (php/~ x))

(defn bit-shift-left
  "Bitwise shift left."
  {:inline (fn [x n] `(do (assert-non-nil ,x ,n) (php/<< ,x ,n)))}
  [x n]
  (assert-non-nil x n)
  (php/<< x n))

(defn bit-shift-right
  "Bitwise shift right."
  {:inline (fn [x n] `(do (assert-non-nil ,x ,n) (php/>> ,x ,n)))}
  [x n]
  (assert-non-nil x n)
  (php/>> x n))

(defn bit-set
  "Set bit an index `n`."
  [x n]
  (bit-or x (bit-shift-left 1 n)))

(defn bit-clear
  "Clear bit an index `n`."
  [x n]
  (bit-and x (bit-not (bit-shift-left 1 n))))

(defn bit-flip
  "Flip bit at index `n`."
  [x n]
  (bit-xor x (bit-shift-left 1 n)))

(defn bit-test
  "Test bit at index `n`."
  [x n]
  (php/!= 0 (bit-and x (bit-shift-left 1 n))))

# --------------
# Math operation
# --------------

(def NAN
  "Constant for Not a Number (NAN) values."
  php/NAN)

(defn +
  "Returns the sum of all elements in `xs`. All elements `xs` must be numbers.
  If `xs` is empty, return 0."
  {:inline (fn [& xs] `(do (assert-non-nil ,@xs) (php/+ ,@xs)))
   :inline-arity (fn [n] (> n 0))}
  [& xs]
  (apply assert-non-nil xs)
  (if (empty? xs)
    0
    (apply php/+ xs)))

(defn -
  "Returns the difference of all elements in `xs`. If `xs` is empty, return 0. If `xs`
  has one element, return the negative value of that element."
  {:inline (fn [& xs] `(do (assert-non-nil ,@xs) (php/- ,@xs)))
   :inline-arity (fn [n] (> n 1))}
  [& xs]
  (apply assert-non-nil xs)
  (case (count xs)
    0 0
    1 (php/* -1 (first xs))
    2 (php/- (first xs) (second xs))
    (reduce |(php/- $1 $2) xs)))

(defn *
  "Returns the product of all elements in `xs`. All elements in `xs` must be
numbers. If `xs` is empty, return 1."
  {:inline (fn [& xs] `(do (assert-non-nil ,@xs) (php/* ,@xs)))
   :inline-arity (fn [n] (> n 0))}
  [& xs]
  (apply assert-non-nil xs)
  (case (count xs)
    0 1
    1 (first xs)
    2 (php/* (first xs) (second xs))
    (reduce |(php/* $1 $2) xs)))

(defn /
  "Returns the nominator divided by all the denominators. If `xs` is empty,
returns 1. If `xs` has one value, returns the reciprocal of x."
  {:inline (fn [& xs] `(do (assert-non-nil ,@xs) (php// ,@xs)))
   :inline-arity (fn [n] (> n 1))}
  [& xs]
  (apply assert-non-nil xs)
  (case (count xs)
    0 1
    1 (php// 1 (first xs))
    2 (php// (first xs) (second xs))
    (reduce |(php// $1 $2) xs)))

(defn %
  "Return the remainder of `dividend` / `divisor`."
  {:inline (fn [dividend divisor] `(do (assert-non-nil ,dividend ,divisor) (php/% ,dividend ,divisor)))}
  [dividend divisor]
  (assert-non-nil dividend divisor)
  (php/% dividend divisor))

(defn **
  "Return `a` to the power of `x`."
  {:inline (fn [a x] `(do (assert-non-nil ,a ,x) (php/** ,a ,x)))}
  [a x]
  (assert-non-nil a x)
  (php/** a x))

(defn inc
  "Increments `x` by one."
  {:inline (fn [x] `(do (assert-non-nil ,x) (php/+ ,x 1)))}
  [x]
  (assert-non-nil x)
  (+ x 1))

(defn dec
  "Decrements `x` by one."
  {:inline (fn [x] `(do (assert-non-nil ,x) (php/- ,x 1)))}
  [x]
  (assert-non-nil x)
  (- x 1))

(defn even?
  "Checks if `x` is even."
  [x]
  (= 0 (% x 2)))

(defn odd?
  "Checks if `x` is odd."
  [x]
  (= 1 (% x 2)))

(defn zero?
  "Checks if `x` is zero."
  [x]
  (or (= x 0) (= x 0.0)))

(defn one?
  "Checks if `x` is one."
  [x]
  (or (= x 1) (= x 1.0)))

(defn pos?
  "Checks if `x` is greater than zero."
  [x]
  (> x 0))

(defn neg?
  "Checks if `x` is smaller than zero."
  [x]
  (< x 0))

(defn nan?
  "Checks if `x` is not a number."
  [x]
  (php/is_nan x))

(defn rand
  "Returns a random number between 0 and 1."
  []
  (/ (php/random_int 0 php/PHP_INT_MAX) php/PHP_INT_MAX))

(defn rand-int
  "Returns a random number between 0 and `n`."
  [n]
  (php/random_int 0 n))

(defn rand-nth
  "Returns a random item from xs."
  [xs]
  (get xs (rand-int (dec (count xs)))))

(defn extreme
  "Returns the most extreme value in `args` based on the binary `order` function."
  [order args]
  (reduce |(if (order $1 $2) $1 $2) args))

(defn min
  "Returns the numeric minimum of all numbers."
  [& numbers]
  (extreme < numbers))

(defn max
  "Returns the numeric maximum of all numbers."
  [& numbers]
  (extreme > numbers))

(defn coerce-in
  "Returns `v` if it is in the range, or `min` if `v` is less than `min`, or `max` if `v` is greater than `max`."
  [v min max]
  (when (< max min)
    (throw (php/new \InvalidArgumentException "Max values is bigger than min value")))
  (php/max (php/min v max) min))

(defn sum
  "Returns the sum of all elements is `xs`."
  [xs]
  (apply + xs))

(defn mean
  "Returns the mean of `xs`."
  [xs]
  (/ (sum xs) (count xs)))

(defn median
  "Returns the median of `xs`."
  [xs]
  (let [arr (to-php-array xs)
        cnt (count arr)]
    (when (zero? cnt)
      (throw (php/new \InvalidArgumentException "Cannot compute median of empty sequence")))
    (php/sort arr)
    (let [mid (php/intdiv cnt 2)]
      (if (odd? cnt)
        (php/aget arr mid)
        (/ (+ (php/aget arr (dec mid)) (php/aget arr mid)) 2)))))

# ---------------
# Print operation
# ---------------

(defmacro with-output-buffer
  "Everything that is printed inside the body will be stored in a buffer.
   The result of the buffer is returned."
  [& body]
  (let [res (gensym)]
    `(do
       (php/ob_start)
       ,@body
       (let [,res (php/ob_get_contents)]
         (php/ob_end_clean)
         ,res))))

(defn print-str
  "Same as print. But instead of writing it to an output stream, the resulting string is returned."
  [& xs]
  (let [len (count xs)
        printer (php/:: Printer (nonReadable))
        pp |(php/-> printer (print $))]
    (case (count xs)
      0 ""
      1 (pp (first xs))
      (loop [res (pp (first xs))
             seq (next xs)]
        (if seq
          (recur (str res " " (pp (first seq))) (next seq))
          res)))))

(defn print
  "Prints the given values to the default output stream. Returns nil."
  [& xs]
  (php/print (apply print-str xs))
  nil)

(defn println
  "Same as print followed by a newline."
  [& xs]
  (apply print xs)
  (php/print "\n")
  nil)

(defn format
  "Returns a formatted string. See PHP's [sprintf](https://www.php.net/manual/en/function.sprintf.php) for more information."
  [fmt & xs]
  (apply php/sprintf fmt xs))

(defn printf
  "Output a formatted string. See PHP's [printf](https://www.php.net/manual/en/function.printf.php) for more information."
  [fmt & xs]
  (apply php/printf fmt xs)
  nil)

# ---------------
# File operations
# ---------------

(defn- file-get-contents-silenced
  "Wrapper around file_get_contents that suppresses PHP warnings.
  We handle errors by checking the return value."
  [path use-include-path context offset length]
  (let [old-error-level (php/error_reporting 0)
        content (php/file_get_contents path use-include-path context offset length)]
    (php/error_reporting old-error-level)
    content))

(defn slurp
  "Reads entire file or URL into a string. Accepts both file paths and URLs
  (http://, https://, ftp://). Accepts `opts` map for overriding default
  PHP file_get_contents arguments.

  Examples:
    (slurp \"file.txt\")
    (slurp \"https://example.com/data.txt\")
    (slurp \"file.txt\" {:encoding \"UTF-8\"})

  See PHP's [file_get_contents](https://www.php.net/manual/en/function.file-get-contents.php) for more information."
  [path & [opts]]
  (let [is-url? (php/preg_match "/^(https?|ftp):\/\//i" path)]
    # Validate for non-URLs
    (when-not is-url?
      # Check if path is a directory
      (when (php/is_dir path)
        (throw (php/new \InvalidArgumentException
                        (str "Cannot read directory: " path))))
      # Check if file exists
      (when-not (php/is_file path)
        (throw (php/new \InvalidArgumentException
                        (str "File not found: " path)))))
    # Read content
    (let [opts             (or opts {})
          use-include-path (or (:use-include-path opts) false)
          context          (or (:context opts) nil)
          offset           (or (:offset opts) 0)
          length           (or (:length opts) nil)
          content (file-get-contents-silenced path use-include-path context offset length)]
      # Check if file_get_contents failed
      (when (= content false)
        (throw (php/new \InvalidArgumentException
                        (str "Failed to read from: " path))))
      content)))

(defn spit
  "Writes data to file, returning number of bytest that were written or `nil`
  on failure. Accepts `opts` map for overriding default PHP file_put_contents
  arguments, as example to append to file use {:flags php/FILE_APPEND}.
  See PHP's [file_put_contents](https://www.php.net/manual/en/function.file-put-contents.php) for more information."
  [filename data & [opts]]
  (when (php/is_dir filename)
    (throw (php/new \InvalidArgumentException
                    "Argument filename should be a valid path to a file, directory given.")))
  (let [opts    (or opts {})
        flags   (or (:flags opts) 0)
        context (or (:context opts) nil)
        result (php/file_put_contents filename data flags context)]
    (when (int? result) result)))

(defn line-seq
  "Returns a lazy sequence of lines from a file. Each line is a string with
  line endings removed. The file is read lazily and the file handle is
  automatically closed when the sequence is fully consumed or if an error occurs.

  Works with infinite sequences like tailable log files or named pipes.

  Example: (take 10 (line-seq \"large-file.txt\"))"
  [filename]
  (let [result (lazy-seq-from-generator
                (php/call_user_func_array
                 (php/array "\\Phel\\Lang\\Generators" "fileLines")
                 (php/array filename)))]
    (if (php/=== nil result)
      '()
      result)))

(defn file-seq
  "Returns a lazy sequence of all files and directories in a directory tree.
  Walks the directory recursively, yielding paths as strings. If given a file
  path, returns a sequence containing just that file.

  The sequence includes both files and directories. Follows symbolic links but
  tracks visited inodes to prevent infinite cycles.

  Example: (filter |(php/str_ends_with $ \".phel\") (file-seq \"src/\"))"
  [path]
  (let [result (lazy-seq-from-generator
                (php/call_user_func_array
                 (php/array "\\Phel\\Lang\\Generators" "fileSeq")
                 (php/array path)))]
    (if (php/=== nil result)
      '()
      result)))

(defn read-file-lazy
  "Returns a lazy sequence of byte string chunks from a file. The file is read
  in chunks of the specified size (default 8192 bytes). The file handle is
  automatically closed when the sequence is fully consumed or if an error occurs.

  Useful for processing large binary files, streaming file content, or reading
  files where line-based processing doesn't make sense.

  The optional chunk-size parameter controls how many bytes to read at a time.
  Smaller chunks use less memory but make more system calls; larger chunks are
  more efficient but use more memory.

  Example: (take 5 (read-file-lazy \"large-file.bin\" 1024))"
  ([filename]
   (read-file-lazy filename 8192))
  ([filename chunk-size]
   (let [result (lazy-seq-from-generator
                 (php/call_user_func_array
                  (php/array "\\Phel\\Lang\\Generators" "readFileChunks")
                  (php/array filename chunk-size)))]
     (if (php/=== nil result)
       '()
       result))))

(defn csv-seq
  "Returns a lazy sequence of rows from a CSV file. Each row is a tuple (vector)
  of string values. The file is read lazily and the file handle is automatically
  closed when the sequence is fully consumed or if an error occurs.

  Supports optional parameters for custom CSV formats:
  - separator: field delimiter (default: ',')
  - enclosure: quote character (default: '\"')
  - escape: escape character (default: '\\\\')

  Works with RFC 4180 compliant CSV files and handles quoted fields, embedded
  commas, and newlines within quoted fields.

  Example: (take 10 (csv-seq \"data.csv\"))
  Example: (csv-seq \"data.tsv\" {:separator \"\\t\"})"
  ([filename]
   (csv-seq filename {}))
  ([filename options]
   (let [separator (get options :separator ",")
         enclosure (get options :enclosure "\"")
         escape (get options :escape "\\")
         result (lazy-seq-from-generator
                 (php/call_user_func_array
                  (php/array "\\Phel\\Lang\\Generators" "csvLines")
                  (php/array filename separator enclosure escape)))]
     (if (php/=== nil result)
       '()
       result))))

# ----------------
# Threading macros
# ----------------

(defmacro ->
  "Threads the expr through the forms. Inserts `x` as the second item
  in the first form, making a list of it if it is not a list already.
  If there are more forms, insert the first form as the second item in
  the second form, etc."
  [x & forms]
  (loop [x x
         forms (if (empty? forms) nil forms)]
    (if forms
      (let [form (first forms)
            threaded (if (list? form)
                       (with-meta form `(,(first form) ,x ,@(next form)))
                       (with-meta form (list form x)))]
        (recur threaded (next forms)))
      x)))

(defmacro ->>
  "Threads the expr through the forms. Inserts `x` as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, insert the first form as the
  last item in the second form, etc."
  [x & forms]
  (loop [x x
         forms (if (empty? forms) nil forms)]
    (if forms
      (let [form (first forms)
            threaded (if (list? form)
                       (with-meta form `(,(first form) ,@(next form) ,x))
                       (with-meta form (list form x)))]
        (recur threaded (next forms)))
      x)))

(defmacro some->
  "Threads `x` through the forms like `->` but stops when a form returns `nil`."
  [x & forms]
  (loop [x x
         forms (if (empty? forms) nil forms)]
    (if forms
      (let [form (first forms)
            g (gensym)
            call (if (list? form)
                   (let [rest (next form)
                         args (if rest
                                (cons g rest)
                                [g])]
                     (with-meta form (apply list (cons (first form) args))))
                   (with-meta form (list form g)))
            threaded (list 'let
                           [g x]
                           (list 'if
                                 (list 'php/=== nil g)
                                 nil
                                 call))]
        (recur threaded (next forms)))
      x)))

(defmacro some->>
  "Threads `x` through the forms like `->>` but stops when a form returns `nil`."
  [x & forms]
  (loop [x x
         forms (if (empty? forms) nil forms)]
    (if forms
      (let [form (first forms)
            g (gensym)
            call (if (list? form)
                   (let [rest (next form)
                         args (if rest
                                (concat rest [g])
                                [g])]
                     (with-meta form (apply list (cons (first form) args))))
                   (with-meta form (list form g)))
            threaded (list 'let
                           [g x]
                           (list 'if
                                 (list 'php/=== nil g)
                                 nil
                                 call))]
        (recur threaded (next forms)))
      x)))

(defmacro as->
  "Binds `name` to `expr`, evaluates the first form in the lexical context
  of that binding, then binds name to that result, repeating for each
  successive form, returning the result of the last form."
  [expr name & forms]
  (let [x (gensym)]
    `(let [,name ,expr
           ,@(interleave (repeat (count forms) name) forms)]
       ,name)))

(defmacro doto
  "Evaluates x then calls all of the methods and functions with the
  value of x supplied at the front of the given arguments. The forms
  are evaluated in order. Returns x."
  [x & forms]
  (let [gx (gensym)]
    `(let [,gx ,x]
       ,@(map (fn [f]
                (if (list? f)
                  (with-meta f `(,(first f) ,gx ,@(next f)))
                  (with-meta f `(,f ,gx))))
              forms)
       ,gx)))

# ---------------
# Regex functions
# ---------------

(defn re-seq
  "Returns a sequence of successive matches of pattern in string."
  [re s]
  (let [matches (php/array)
        match-result (php/preg_match_all re s matches)]
    (apply vector (php/aget matches 0))))

# -------
# Binding
# -------

# inspired by Clojure's with-redefs
(defmacro binding
  "Temporary redefines definitions while executing the body.
  The value will be reset after the body was executed."
  [bindings & body]
  (let [names (take-nth 2 bindings)
        vals (take-nth 2 (drop 1 bindings))
        orig-val-syms (map gensym names)
        temp-val-syms (map gensym names)
        binds (map vector names temp-val-syms)
        resets (reverse (map vector names orig-val-syms))
        bind-value (fn [[k v]] (list 'set-var k v))]
    `(let [,@(interleave orig-val-syms names)
           ,@(interleave temp-val-syms vals)]
       ,@(map bind-value binds)
       (try
         (do ,@body)
         (finally
           ,@(map bind-value resets))))))

# ----------
# Interfaces
# ----------

(defmacro definterface
  "Defines an interface."
  [name & fns]
  (let [name-str (php/-> name (getName))
        munge (php/new Munge)
        class-name-str (php/. *ns* "\\" (php/-> munge (encode name-str)))
        defs (for [[fn-name args doc] :in fns
                   :let [fn-name-str (php/-> fn-name (getName))
                         munged-fn-name (php/-> munge (encode fn-name-str))
                         munged-fn-symbol (php/:: Symbol (create munged-fn-name))]]
               `(defn ,fn-name {:doc ,doc} ,args
                  (if (php/is_a ,(first args) ,class-name-str)
                    (php/-> ,(first args) (,munged-fn-symbol ,@(rest args)))
                    (throw (php/new \InvalidArgumentException ,(str "Value doesn't implement interface " name))))))]
    `(do
       (definterface* ,name ,@fns)
       ,@defs)))

(defmacro if-let
  "If test is true, evaluates then with binding-form bound to the value of test,
  if not, yields else"
  [bindings then & [else]]
  (let [err |(throw (php/new \InvalidArgumentException $))]
    (when-not
      (vector? bindings)
      (err (str "if-let requires a vector for it's bindings, "
                (type bindings) " given")))
    (when-not
      (= 2 (count bindings))
      (err (str "if-let requires bindings to have 2 elements, "
                (count bindings) " given"))))

  (let [form (bindings 0) tst (bindings 1) temp-sym (gensym)]
    `(let [temp-sym ,tst]
       (if temp-sym
         (let [,form temp-sym]
           ,then)
         ,else))))

(defmacro when-let
  "When test is true, evaluates body with binding-form bound to the value of test"
  [bindings & body]
  (let [err |(throw (php/new \InvalidArgumentException $))]
    (when-not
      (vector? bindings)
      (err (str "when-let requires a vector for it's bindings, "
                (type bindings) " given")))
    (when-not
      (= 2 (count bindings))
      (err (str "when-let requires bindings to have 2 elements, "
                (count bindings) " given"))))

  (let [form (bindings 0) tst (bindings 1) temp-sym (gensym)]
    `(let [temp-sym ,tst]
       (when temp-sym
         (let [,form temp-sym]
           ,@body)))))

(defmacro time
  "Evaluates expr and prints the time it took. Returns the value of expr."
  [expr]
  `(let [start$ (php/microtime true)
         ret$ ,expr]
     (println "Elapsed time:" (* 1000 (- (php/microtime true) start$)) "msecs")
     ret$))

(defn name
  "Returns the name string of a string, keyword or symbol."
  [x]
  (if (string? x) x (php/-> x (getName))))

(defn namespace
  "Return the namespace string of a symbol or keyword. Nil if not present."
  [x]
  (php/-> x (getNamespace)))

(defn full-name
  "Return the namespace and name string of a string, keyword or symbol."
  [x]
  (if (string? x) x (php/-> x (getFullName))))

(defn read-string
  "Reads the first phel expression from the string s."
  [s]
  (let [cf (php/new CompilerFacade)
        token-stream (php/-> cf (lexString s))
        node (php/-> cf (parseNext token-stream))]
    (when node
      (php/-> (php/-> cf (read node)) (getAst)))))

(defn eval
  "Evaluates a form and return the evaluated results."
  [form]
  (let [cf (php/new CompilerFacade)]
    (php/-> cf (evalForm form))))

(defn compile
  "Returns the compiled PHP code string for the given form."
  [form]
  (let [cf (php/new CompilerFacade)]
    (php/-> (php/-> cf (compileForm form)) (getPhpCode))))

(defn- get-global-env []
  (php/:: GlobalEnvironmentSingleton (getInstance)))

(defn- get-global-var-node [sym]
  (php/-> (get-global-env) (resolve sym (php/:: NodeEnvironment (empty)))))

(defn- inline-call? [meta arity]
  (and (:inline meta)
       (let [af (:inline-arity meta)]
         (if af
           (af arity)
           true))))

(defn macroexpand-1
  "Expands the given form once if it is a macro call."
  [form]
  (if (and (list? form) (not (empty? form)))
    (let [op (first form)]
      (if (symbol? op)
        (let [node (get-global-var-node op)]
          (if (php/instanceof node GlobalVarNode)
            (let [meta (php/-> node (getMeta))
                  ns (php/-> node (getNamespace))
                  name (php/-> (php/-> node (getName)) (getName))
                  args (rest form)]
              (cond
                (inline-call? meta (count args))
                (apply (:inline meta) args)
                (:macro meta)
                (let [macro-fn (php/:: Phel (getDefinition ns name))]
                  (apply macro-fn args))
                :else
                form))
            form))
        form))
    form))

(defn macroexpand
  "Recursively expands the given form until it is no longer a macro call."
  [form]
  (loop [f form]
    (let [e (macroexpand-1 f)]
      (if (= e f)
        e
        (recur e)))))
