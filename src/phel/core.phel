(ns phel\core
  (:use Countable)
  (:use Traversable)
  (:use InvalidArgumentException)
  (:use Phel)
  (:use Phel\Compiler\Application\Munge)
  (:use Phel\Compiler\CompilerFacade)
  (:use Phel\Compiler\Domain\Analyzer\Ast\GlobalVarNode)
  (:use Phel\Compiler\Domain\Analyzer\Environment\NodeEnvironment)
  (:use Phel\Compiler\Infrastructure\GlobalEnvironmentSingleton)
  (:use Phel\Lang\AbstractType)
  (:use Phel\Lang\CdrInterface)
  (:use Phel\Lang\Collections\HashSet\PersistentHashSetInterface)
  (:use Phel\Lang\Collections\HashSet\TransientHashSetInterface)
  (:use Phel\Lang\Collections\LinkedList\PersistentListInterface)
  (:use Phel\Lang\Collections\Map\PersistentMapInterface)
  (:use Phel\Lang\Collections\Map\TransientMapInterface)
  (:use Phel\Lang\Collections\Struct\AbstractPersistentStruct)
  (:use Phel\Lang\Collections\Vector\PersistentVectorInterface)
  (:use Phel\Lang\Collections\Vector\TransientVectorInterface)
  (:use Phel\Lang\ConcatInterface)
  (:use Phel\Lang\ConsInterface)
  (:use Phel\Lang\ContainsInterface)
  (:use Phel\Lang\FirstInterface)
  (:use Phel\Lang\IdenticalInterface)
  (:use Phel\Lang\Keyword)
  (:use Phel\Lang\MetaInterface)
  (:use Phel\Lang\PopInterface)
  (:use Phel\Lang\PushInterface)
  (:use Phel\Lang\RemoveInterface)
  (:use Phel\Lang\RestInterface)
  (:use Phel\Lang\SliceInterface)
  (:use Phel\Lang\Symbol)
  (:use Phel\Lang\Truthy)
  (:use Phel\Lang\Variable)
  (:use Phel\Lang\Generators)
  (:use Phel\Printer\Printer))

(def *ns*
  "Returns the namespace in the current scope."
  "\\phel\\core")

(def *file*
  "Returns the path to the current source file."
  "")

# --------------------------------------------
# Basic methods for quasiquote and destructure
# --------------------------------------------

(def list
  "```phel\n(list & xs)\n```\nCreates a new list. If no argument is provided, an empty list is created."
  (fn [& xs] (php/:: Phel (list (apply php/array xs)))))

(def vector
  "```phel\n(vector & xs)\n```\nCreates a new vector. If no argument is provided, an empty vector is created."
  (fn [& xs] (php/:: Phel (vector (apply php/array xs)))))

(def hash-map
  "```phel\n(hash-map & xs)\n```\nCreates a new hash map. If no argument is provided, an empty hash map is created. The number of parameters must be even."
  (fn [& xs] (php/:: Phel (map (apply php/array xs)))))

(def next
  "```phel\n(next xs)\n```\nReturns the sequence of elements after the first element. If there are no elements, returns nil."
  (fn [xs]
    (if (php/=== xs nil)
      nil
      (if (php/instanceof xs CdrInterface)
        (php/-> xs (cdr))
        (if (php/is_array xs)
          (let [sliced (php/array_slice xs 1)]
            (if (php/empty sliced)
              nil
              sliced))
          (throw (php/new InvalidArgumentException
                          (php/. "cannot call 'next on " (php/gettype xs)))))))))

(def first
  "```phel\n(first xs)\n```\nReturns the first element of an indexed sequence or nil."
  (fn [xs]
    (if (php/instanceof xs FirstInterface)
      (php/-> xs (first))
      (php/aget xs 0))))

(def concat1
  {:private true
   :doc "Concatenates two sequential data structures."}
  (fn [xs ys]
    (if (php/=== nil ys)
      xs
      (if (php/instanceof xs ConcatInterface)
        (php/-> xs (concat ys))
        (do
          (foreach [y ys]
            (php/apush xs y))
          xs)))))

(def concat
  "```phel\n(concat arr & xs)\n```\nConcatenates multiple sequential data structures."
  (fn [arr & others]
    (if (php/=== nil arr)
      '()
      (loop [res arr
             other others]
        (if (php/=== nil other)
          res
          (let [[y & ys] other]
            (recur (concat1 res y) ys)))))))

# quasiquote can be used down here

(def declare
  {:macro true
   :doc "Declare a global symbol before it is defined."}
  (fn [name]
    `(def ,name nil)))

(declare nil?)
(def argv
  "Vector of arguments passed to the script."
  (let [argv-raw (php/aget php/$GLOBALS "argv")]
    (if (php/=== argv-raw nil)
      []
      (php/:: Phel (vector argv-raw)))))

# ------------
# Meta helpers
# ------------

(declare =)
(declare symbol?)
(declare list?)
(declare second)

(def meta
  {:macro true
   :doc "```phel\n(meta obj)\n```\nGets the metadata of the given object or definition."}
  (fn [obj]
    (let [sym (if (symbol? obj)
                obj
                (if (list? obj)
                  (if (= (first obj) 'quote)
                    (if (symbol? (second obj))
                      (second obj)
                      nil)
                    nil)
                  nil))]
      (if sym
        (let [ns (php/-> sym (getNamespace))]
          (if ns
            `(php/:: \Phel (getDefinitionMetaData ,ns ,(php/-> sym (getName))))
            `(php/:: \Phel (getDefinitionMetaData *ns* ,(php/-> sym (getName))))))
        `(let [obj-meta ,obj]
           (if (php/instanceof obj-meta \Phel\Lang\MetaInterface)
             (php/-> obj-meta (getMeta))
             nil))))))

(def set-meta!
  "```phel\n(set-meta! obj)\n```\nSets the metadata to a given object."
  (fn [obj meta]
    (php/-> obj (withMeta meta))))

(def with-meta
  {:private true
   :doc "Returns `target` with the metadata from `source` when both implement `MetaInterface`."}
  (fn [source target]
    (if (php/instanceof source MetaInterface)
      (if (php/instanceof target MetaInterface)
        (php/-> target (withMeta (php/-> source (getMeta))))
        target)
      target)))

# ------------
# Basic macros
# ------------

(def defn-builder
  {:macro true
   :private true}
  (fn [name meta & fdecl]
    (let [meta (if (php/is_string (php/aget fdecl 0))
                 (php/-> meta (put :doc (php/aget fdecl 0)))
                 meta)
          fdecl (if (php/is_string (php/aget fdecl 0))
                  (next fdecl)
                  fdecl)
          meta (if (php/instanceof (php/aget fdecl 0) PersistentMapInterface)
                 (php/-> meta (merge (php/aget fdecl 0)))
                 meta)
          fdecl (if (php/instanceof (php/aget fdecl 0) PersistentMapInterface)
                  (next fdecl)
                  fdecl)
          args (if (php/instanceof (php/aget fdecl 0) PersistentVectorInterface)
                 (php/aget fdecl 0)
                 (php/aget (php/aget fdecl 0) 0))
          docstring (php/aget meta :doc)
          docstring (php/. "```phel\n(" name " " (php/implode " " (apply php/array args)) ")\n```\n" docstring)
          meta (php/-> meta (put :doc docstring))]
      `(def ,name ,meta (fn ,@fdecl)))))

(def defn
  {:macro true
   :doc "```phel\n(defn name & fdecl)\n```\nDefine a new global function."}
  (fn [name & fdecl] (apply defn-builder name {} fdecl)))

(def def-
  {:macro true
   :doc "```phel\n(def- name value)\n```\nDefine a private value that will not be exported."}
  (fn [name value] `(def ,name {:private true} ,value)))

(def defmacro
  {:macro true
   :doc "```phel\n(defmacro name & fdecl)\n```\nDefine a macro."}
  (fn [name & fdecl] (apply defn-builder name {:macro true} fdecl)))

(defmacro defn-
  "Define a private function that will not be exported."
  [name & fdecl]
  (apply defn-builder name {:private true} fdecl))

(defmacro defmacro-
  "Define a private macro that will not be exported."
  [name & fdecl]
  (apply defn-builder name {:macro true :private true} fdecl))

(defmacro defstruct
  "Define a new struct."
  [name keys & implementations]
  (let [name-str (php/-> name (getName))
        munge (php/new Munge)
        class-name-str (php/. *ns* "\\" (php/-> munge (encode name-str)))
        is-name (php/:: Symbol (create (php/. name-str "?")))]
    `(do
       (defstruct* ,name ,keys ,@implementations)
       (defn ,name ,(php/. "Creates a new " name " struct.") ,keys (php/new ,class-name-str ,@keys))
       (defn ,is-name ,(php/. "Checks if `x` is an instance of the " name " struct.") [x] (php/is_a x ,class-name-str)))))

(defmacro defexception
  "Define a new exception."
  [name]
  (let [name-str (php/-> name (getName))
        munge (php/new Munge)
        class-name-str (php/. *ns* "\\" (php/-> munge (encode name-str)))
        is-name (php/:: Symbol (create (php/. name-str "?")))]
    `(do
       (defexception* ,name)
       (defn ,name ,(php/. "Creates a new " name " exception.") [& args] (apply php/new ,class-name-str args))
       (defn ,is-name ,(php/. "Checks if `x` is an instance of the " name " exception.") [x] (php/is_a x ,class-name-str)))))

(defmacro comment
  "Ignores the body of the comment."
  [&])

(defn symbol
  "Returns a new symbol for given string with optional namespace.
   Arity-1 returns a symbol without namespace. Arity-2 returns a symbol in given namespace."
  [name-or-ns & [name]]
  (if name
    (php/:: Symbol (createForNamespace name-or-ns name))
    (php/:: Symbol (create name-or-ns))))

(defn gensym
  "Generates a new unique symbol."
  []
  (php/:: Symbol (gen)))

(defn str
  "Creates a string by concatenating values together. If no arguments are
provided an empty string is returned. Nil and false are represented as an empty
string. True is represented as 1. Otherwise, it tries to call `__toString`.
This is PHP equivalent to `$args[0] . $args[1] . $args[2] ...`."
  {:inline (fn [& args] `(php/. "" ,@args))
   :inline-arity (fn [n] (php/> n 0))}
  [& args]
  (if (php/== (php/count args) 0)
    ""
    (apply php/. "" args)))

(defn transient
  "Converts a persistent collection to a transient collection."
  [coll]
  (php/-> coll (asTransient)))

(defn persistent
  "Converts a transient collection to a persistent collection."
  [coll]
  (php/-> coll (persistent)))

# ------------------
# Basic constructors
# ------------------

(defn set
  "Creates a new Set. If no argument is provided, an empty Set is created."
  [& xs]
  (php/:: Phel (set (apply php/array xs))))

(defn keyword
  "Creates a new Keyword from a given string."
  [x]
  (php/:: Keyword (create x)))

(defn php-indexed-array
  "Creates a PHP indexed array from the given values."
  [& xs]
  (apply php/array xs))

(defn php-associative-array
  "Creates a PHP associative array. An even number of parameters must be provided."
  [& xs]
  (let [cnt (php/count xs)
        res (php/array)]
    (if (php/=== 1 (php/% cnt 2))
      (throw (php/new InvalidArgumentException "An even number of parameters must be provided for 'php-associative-array'")))
    (loop [i 0]
      (if (php/< i cnt)
        (do
          (php/aset res (php/aget xs i) (php/aget xs (php/+ i 1)))
          (recur (php/+ i 2)))
        res))))

# ------------------------
# Basic sequence operation
# ------------------------

(defn- equals1 [a b]
  (if (php/instanceof a AbstractType)
    (php/-> a (equals b))
    (php/=== a b)))

(defn cons
  "Prepends `x` to the beginning of `xs`."
  [x xs]
  (if (php/is_array xs)
    (do
      (php/array_unshift xs x)
      xs)
    (if (php/instanceof xs ConsInterface)
      (php/-> xs (cons x))
      (if (php/=== xs nil)
        [x]
        (throw (php/new InvalidArgumentException
                        (php/. "cannot do cons " (php/print_r x true))))))))

(defn ffirst
  "Same as `(first (first xs))`."
  [xs]
  (first (first xs)))

(defn second
  "Returns the second element of an indexed sequence or nil."
  [xs]
  (first (next xs)))

(defn rest
  "Returns the sequence of elements after the first element. If there are no elements, returns an empty sequence."
  [xs]
  (if (php/instanceof xs RestInterface)
    (php/-> xs (rest))
    (if (php/is_array xs)
      (php/array_slice xs 1)
      (throw (php/new InvalidArgumentException "cannot do rest")))))

(defn nfirst
  "Same as `(next (first xs))`."
  [xs]
  (next (first xs)))

(defn nnext
  "Same as `(next (next xs))`."
  [xs]
  (next (next xs)))

(defn count
  "Counts the number of elements in a sequence. Can be used on everything that implements the PHP Countable interface."
  [xs]
  (if (php/instanceof xs Countable)
    (php/-> xs (count))
    (if (php/is_array xs)
      (php/count xs)
      (if (php/is_string xs)
        (throw (php/new InvalidArgumentException "strings are not supported. Consider using native PHP functions like `php/strlen` or `php/mb_strlen`."))
        (if (php/=== xs nil)
          0
          (throw (php/new InvalidArgumentException (str "object is not countable: " xs))))))))

# ------------------
# Control structures
# ------------------

(defmacro if-not
  "Shorthand for `(if (not condition) else then)`."
  [test then & [else]]
  `(if ,test ,else ,then))

(defmacro when
  "Evaluates `test` and if that is logical true, evaluates `body`."
  [test & body]
  `(if ,test (do ,@body)))

(defmacro when-not
  "Evaluates `test` and if that is logical false, evaluates `body`."
  [test & body]
  `(if ,test nil (do ,@body)))

(defmacro cond
  "Takes a set of test/expression pairs. Evaluates each test one at a time.
  If a test returns logically true, the expression is evaluated and returned.
  If no test matches a final last expression can be provided that is then
  evaluated and returned. Otherwise, nil is returned."
  [& pairs]
  (let [cnt (count pairs)]
    (if (php/=== cnt 0)
      nil
      (if (php/=== cnt 1)
        (first pairs)
        (list 'if
              (first pairs)
              (second pairs)
              (cons 'cond (apply list (next (next pairs)))))))))

(defmacro case
  "Takes an expression `e` and a set of test-content/expression pairs. First
  evaluates `e` and then finds the first pair where the test-constant matches
  the result of `e`. The associated expression is then evaluated and returned.
  If no matches can be found a final last expression can be provided that is
  then evaluated and returned. Otherwise, nil is returned."
  [e & pairs]
  (if (next pairs)
    (let [v (gensym)]
      `(let [,v ,e]
         (if (equals1 ,v ',(first pairs))
           ,(first (next pairs))
           (case ,v ,@(next (next pairs))))))
    (first pairs)))

# -----------------
# Boolean operation
# -----------------

(defmacro or
  "Evaluates each expression one at a time, from left to right. If a form
returns a logical true value, or returns that value and doesn't evaluate any of
the other expressions, otherwise, it returns the value of the last expression.
Calling or without arguments, returns nil."
  [& args]
  (case (count args)
    0 nil
    1 (first args)
    (let [v (gensym)]
      `(let [,v ,(first args)]
         (if ,v ,v (or ,@(next args)))))))

(defmacro and
  "Evaluates each expression one at a time, from left to right. If a form
returns logical false, `and` returns that value and doesn't evaluate any of the
other expressions, otherwise, it returns the value of the last expression.
Calling the `and` function without arguments returns true."
  [& args]
  (case (count args)
    0 'true
    1 (first args)
    (let [v (gensym)]
      `(let [,v ,(first args)]
         (if ,v (and ,@(next args)) ,v)))))

(defn- id2 [a b]
  (if (php/instanceof a IdenticalInterface)
    (php/-> a (identical b))
    (php/=== a b)))

(defn id
  "Checks if all values are identical. Same as `a === b` in PHP."
  [a & more]
  (case (count more)
    0 true
    1 (id2 a (first more))
    (if (id2 a (first more))
      (recur (first more) (next more))
      false)))

(defn =
  "Checks if all values are equal. Same as `a == b` in PHP."
  [a & more]
  (case (count more)
    0 true
    1 (equals1 a (first more))
    (if (equals1 a (first more))
      (recur (first more) (next more))
      false)))

(defn not
  "The `not` function returns `true` if the given value is logical false and `false` otherwise."
  [x]
  (if x false true))

(defn not=
  "Checks if all values are unequal. Same as `a != b` in PHP."
  [a & more]
  (case (count more)
    0 false
    1 (not (= a (first more)))
    (not (apply = a more))))

(defn <
  "Checks if each argument is strictly less than the following argument. Returns a boolean."
  {:inline (fn [a b] `(php/< ,a ,b))
   :inline-arity (fn [n] (php/=== n 2))}
  [a & more]
  (case (count more)
    0 true
    1 (php/< a (first more))
    (if (php/< a (first more))
      (recur (first more) (next more))
      false)))

(defn <=
  "Checks if each argument is less than or equal to the following argument. Returns a boolean."
  {:inline (fn [a b] `(php/<= ,a ,b))
   :inline-arity (fn [n] (php/=== n 2))}
  [a & more]
  (case (count more)
    0 true
    1 (php/<= a (first more))
    (if (php/<= a (first more))
      (recur (first more) (next more))
      false)))

(defn >
  "Checks if each argument is strictly greater than the following argument. Returns a boolean."
  {:inline (fn [a b] `(php/> ,a ,b))
   :inline-arity (fn [n] (php/=== n 2))}
  [a & more]
  (case (count more)
    0 true
    1 (php/> a (first more))
    (if (php/> a (first more))
      (recur (first more) (next more))
      false)))

(defn >=
  "Checks if each argument is greater than or equal to the following argument. Returns a boolean."
  {:inline (fn [a b] `(php/>= ,a ,b))
   :inline-arity (fn [n] (php/=== n 2))}
  [a & more]
  (case (count more)
    0 true
    1 (php/>= a (first more))
    (if (php/>= a (first more))
      (recur (first more) (next more))
      false)))

(defn <=>
  "Alias for the spaceship PHP operator in ascending order. Returns an int."
  {:inline (fn [a b] `(php/<=> ,a ,b))}
  [a b]
  (php/<=> a b))

(defn >=<
  "Alias for the spaceship PHP operator in descending order. Returns an int."
  {:inline (fn [a b] `(php/<=> ,b ,a))}
  [a b]
  (php/<=> b a))

(defn all?
  "Returns true if `(pred x)` is logical true for every `x` in collection `xs`
   or if `xs` is empty. Otherwise returns false."
  [pred xs]
  (cond
    (php/=== (count xs) 0) true
    (pred (first xs))     (recur pred (next xs))
    false))

(defn every?
  "Alias for `all?`."
  [pred xs]
  (all? pred xs))

(defn not-every?
  "Returns false if `(pred x)` is logical true for every `x` in collection `xs`
   or if `xs` is empty. Otherwise returns true."
  [pred xs]
  (not (every? pred xs)))

(declare empty?)
(declare truthy?)
(declare name)

(defn some?
  "Returns true if `(pred x)` is logical true for at least one `x` in `xs`, else false."
  [pred xs]
  (if (empty? xs)
    false
    (if (truthy? (pred (first xs)))
      true
      (recur pred (next xs)))))

(defn not-any?
  "Returns true if `(pred x)` is logical false for every `x` in `xs`
   or if `xs` is empty. Otherwise returns false."
  [pred xs]
  (not (some? pred xs)))

(defn some
  "Returns the first logical true value of `(pred x)` for any `x` in `xs`, else nil."
  [pred xs]
  (if (empty? xs)
    nil
    (let [res (pred (first xs))]
      (if (truthy? res)
        res
        (recur pred (next xs))))))

(defn true?
  "Checks if `x` is true. Same as `x === true` in PHP."
  [x]
  (id x true))

(defn truthy?
  "Checks if `x` is truthy. Same as `x == true` in PHP."
  [x]
  (php/:: Truthy (isTruthy x)))

(defn false?
  "Checks if `x` is false. Same as `x === false` in PHP."
  [x]
  (id x false))

(defn nil?
  "Returns true if `x` is nil, false otherwise."
  [x]
  (id x nil))

(defn str-contains?
  "Returns true if str contains s."
  {:deprecated "Use phel\\str\\contains?"}
  [str s]
  (php/str_contains str s))

(defn contains?
  "Returns true if key is present in the given collection, otherwise returns false."
  [coll key]
  (cond
    (php/instanceof coll ContainsInterface) (php/-> coll (contains key))
    (php/is_array coll) (php/array_key_exists key coll)
    (throw (php/new InvalidArgumentException (php/. "cannot call 'contains?' on " (php/get_class coll))))))

(defn compare
  "Wrapper for PHP's spaceship operator (`php/<=>`).
  Returns an integer less than, equal to, or greater than zero
  when `x` is less than, equal to, or greater than `y`, respectively."
  {:inline (fn [x y] `(php/<=> ,x ,y))}
  [x y]
  (php/<=> x y))

# --------------
# Type operation
# --------------

(defn type
  "Returns the type of `x`. The following types can be returned:

* `:vector`
* `:list`
* `:struct`
* `:hash-map`
* `:set`
* `:keyword`
* `:symbol`
* `:var`
* `:int`
* `:float`
* `:string`
* `:nil`
* `:boolean`
* `:function`
* `:php/array`
* `:php/resource`
* `:php/object`
* `:unknown`"
  [x]
  (cond
    (php/instanceof x PersistentVectorInterface)  :vector
    (php/instanceof x PersistentListInterface)    :list
    (php/instanceof x AbstractPersistentStruct)   :struct
    (php/instanceof x PersistentMapInterface)     :hash-map
    (php/instanceof x PersistentHashSetInterface) :set
    (php/instanceof x Keyword)                    :keyword
    (php/instanceof x Symbol)                     :symbol
    (php/instanceof x Variable)                   :var
    (php/is_int x)                                :int
    (php/is_float x)                              :float
    (php/is_string x)                             :string
    (php/is_null x)                               :nil
    (php/is_bool x)                               :boolean
    (php/is_callable x)                           :function
    (php/is_array x)                              :php/array
    (php/is_resource x)                           :php/resource
    (php/is_object x)                             :php/object
    :unknown))

(defn float?
  "Returns true if `x` is float point number, false otherwise."
  [x]
  (= (type x) :float))

(defn int?
  "Returns true if `x` is an integer number, false otherwise."
  [x]
  (= (type x) :int))

(defn number?
  "Returns true if `x` is a number, false otherwise."
  [x]
  (or (= (type x) :int) (= (type x) :float)))

(defn string?
  "Returns true if `x` is a string, false otherwise."
  [x]
  (= (type x) :string))

(defn keyword?
  "Returns true if `x` is a keyword, false otherwise."
  [x]
  (= (type x) :keyword))

(defn symbol?
  "Returns true if `x` is a symbol, false otherwise."
  [x]
  (= (type x) :symbol))

(defn function?
  "Returns true if `x` is a function, false otherwise."
  [x]
  (= (type x) :function))

(defn struct?
  "Returns true if `x` is a struct, false otherwise."
  [x]
  (= (type x) :struct))

(defn hash-map?
  "Returns true if `x` is a hash map, false otherwise."
  [x]
  (= (type x) :hash-map))

(defn vector?
  "Returns true if `x` is a vector, false otherwise."
  [x]
  (= (type x) :vector))

(defn list?
  "Returns true if `x` is a list, false otherwise."
  [x]
  (= (type x) :list))

(defn boolean?
  "Returns true if `x` is a boolean, false otherwise."
  [x]
  (= (type x) :boolean))

(defn php-array?
  "Returns true if `x` is a PHP Array, false otherwise."
  [x]
  (= (type x) :php/array))

(defn php-resource?
  "Returns true if `x` is a PHP resource, false otherwise."
  [x]
  (= (type x) :php/resource))

(defn php-object?
  "Returns true if `x` is a PHP object, false otherwise."
  [x]
  (= (type x) :php/object))

(defn empty?
  "Returns true if x would be 0, \"\" or empty collection, false otherwise."
  [x]
  (if (php/is_numeric x)
    (= 0 x)
    (if (php/is_string x)
      (true? (php/empty x))
      (= 0 (count x)))))

(defn not-empty
  "Returns `coll` if it contains elements, otherwise nil."
  [coll]
  (if (empty? coll)
    nil
    coll))

(defn- indexed-php-array?
  [x]
  (and
   (= (type x) :php/array)
   (or
    (php/empty x)
    (php/=== (php/array_keys x) (php/range 0 (php/- (php/count x) 1))))))

(defn indexed?
  "Returns true if `x` is indexed sequence, false otherwise."
  [x]
  (let [t (type x)]
    (or
     (= t :list)
     (= t :vector)
     (indexed-php-array? x))))

(defn associative?
  "Returns true if `x` is an associative data structure, false otherwise."
  [x]
  (let [t (type x)]
    (or
     (= t :hash-map)
     (= t :struct)
     (and (= t :php/array) (not (indexed-php-array? x))))))

(defn set?
  "Returns true if `x` is a set, false otherwise."
  [x]
  (= (type x) :set))

# ------------------
# Sequence operation
# ------------------

(defn peek
  "Returns the last element of a sequence."
  [xs]
  (php/aget xs (php/- (count xs) 1)))


(defn push
  "Inserts `x` at the end of the sequence `xs`."
  [xs x]
  (cond
    (php-array? xs) (do (php/apush xs x) xs)
    (or (vector? xs) (php/instanceof xs TransientVectorInterface)) (php/-> xs (append x))
    (or (set? xs) (php/instanceof xs TransientHashSetInterface)) (php/-> xs (add x))
    (php/instanceof xs PushInterface) (php/-> xs (push x))
    (throw (php/new InvalidArgumentException
                    (str "Cannot push on type " (type xs))))))

(defn pop
  "Removes the last element of the array `xs`. If the array is empty returns nil."
  [^:reference xs]
  (cond
    (php-array? xs) (php/array_pop xs)
    (php/instanceof xs PopInterface) (php/-> xs (pop))
    (throw (php/new InvalidArgumentException "Cannot pop"))))

(defn remove
  "Removes up to `n` element from array `xs` starting at index `offset`."
  [^:reference xs offset & [n]]
  (cond
    (php-array? xs) (if n (php/array_splice xs offset n) (php/array_splice xs offset))
    (php/instanceof xs RemoveInterface) (php/-> xs (remove offset n))
    (throw (php/new InvalidArgumentException "Cannot remove"))))

(defn get
  "Get the value mapped to `key` from the datastructure `ds`.
  Returns `opt` or nil if the value cannot be found."
  [ds k & [opt]]
  (cond
    (or (set? ds)
        (php/instanceof ds PersistentHashSetInterface)
        (php/instanceof ds TransientHashSetInterface))
    (if (php/-> ds (contains k))
      k
      opt)

    :else
    (let [res (php/aget ds k)]
      (if (nil? res)
        opt
        res))))

(defn put
  "Puts `value` mapped to `key` on the datastructure `ds`. Returns `ds`."
  [ds key value]
  (cond
    (php-array? ds)
    (throw (php/new InvalidArgumentException "Cannot call put on pure PHP
arrays. Use (php/aset ds key value)"))

    (or (struct? ds) (hash-map? ds) (php/instanceof ds TransientMapInterface))
    (php/-> ds (put key value))

    (or (vector? ds) (php/instanceof ds TransientVectorInterface))
    (php/-> ds (update key value))

    (do
      (php/aset ds key value)
      ds)))

(defn assoc
  "Alias for `put`."
  [ds key value]
  (put ds key value))

(defn unset
  "Returns `ds` without `key`."
  [ds key]
  (cond
    (php-array? ds)
    (throw (php/new InvalidArgumentException "Cannot call unset on pure PHP
arrays. Use (php/aunset ds key)"))

    (or (hash-map? ds) (php/instanceof ds TransientMapInterface))
    (php/-> ds (remove key))

    (or (set? ds) (php/instanceof ds TransientHashSetInterface))
    (php/-> ds (remove key))

    (let [x ds]
      (php/aunset x key)
      x)))

(defn dissoc
  "Alias for `unset`."
  [ds key]
  (unset ds key))

# --------
# Variable
# --------

(defn var
  "Creates a new variable with the given value."
  [value]
  (php/:: Phel (variable value)))

(defn var?
  "Checks if the given value is a variable."
  [x]
  (php/instanceof x Variable))

(defn set!
  "Sets a new value to the given variable."
  [variable value]
  (php/-> variable (set value)))

(defn deref
  "Return the value inside the variable."
  [variable]
  (php/-> variable (deref)))

(defn swap!
  "Swaps the value of the variable to `(apply f current-value args)`. Returns the values that are swapped in."
  [variable f & args]
  (let [current (deref variable)
        next (apply f current args)]
    (set! variable next)
    next))

# --------
# For loop
# --------

(defn range
  "Create an array of values `[start, end)`. If the function has one argument then
  the range `[0, end)` is returned. With two arguments, returns `[start, end)`.
  The third argument is an optional step width (default 1)."
  [a & rest]
  (case (count rest)
    0 (range 0 a 1)
    1 (range a (get rest 0) 1)
    2 (let [res (transient [])
            begin a
            end (get rest 0)
            step (get rest 1)
            cmp (if (< step 0) > <)]
        (loop [i begin]
          (if (cmp i end)
            (do
              (push res i)
              (recur (php/+ i step)))
            (persistent res))))
    (throw (php/new InvalidArgumentException "Range function expects one, two or three arguments"))))

(def- for-options (set :reduce))

(defn- for-builder-options [head i initial-options]
  (if (<= (count head) i)
    initial-options
    (let [binding (php/aget head i)
          verb (php/aget head (php/+ i 1))]
      (if (keyword? binding)
        (case binding
          :reduce (for-builder-options head (php/+ i 2) (put initial-options :reduce verb))
          (for-builder-options head (php/+ i 2) initial-options))
        (for-builder-options head (php/+ i 3) initial-options)))))

(defn- for-builder [body head i]
  (if (<= (count head) i)
    # No more heads, return the body
    body

    # Handle heads
    (let [binding (php/aget head i)
          verb (php/aget head (php/+ i 1))]
      (cond
        # Case 1: Options
        (and (keyword? binding) (contains? for-options binding))
        (for-builder body head (php/+ i 2))

        # Case 2: Modifiers
        (keyword? binding)
        (let [rest (for-builder body head (php/+ i 2))]
          (case binding
            :while  `(if ,verb ,rest php/break)
            :let    `(let ,verb ,rest)
            :when   `(when ,verb ,rest)
            (throw (php/new InvalidArgumentException (str "This modifier is not supported in for loop: " verb)))))

        # Case 3: Verbs
        (let [object (php/aget head (php/+ i 2))
              rest (for-builder body head (php/+ i 3))
              value-sym (gensym)]
          (case verb
            :range  `(foreach [,binding (apply range ,object)] ,rest)
            :in     `(foreach [,value-sym ,object] (let [,binding ,value-sym] ,rest))
            :keys   (let [key-sym (gensym)]
                      `(foreach [,key-sym ,value-sym ,object] (let [,binding ,key-sym] ,rest)))
            :pairs  (let [key-sym (gensym)]
                      `(foreach [,key-sym ,value-sym ,object]
                         (let [,binding [,key-sym ,value-sym]] ,rest)))
            (throw (php/new InvalidArgumentException (str "This verb is not supported in for loop " verb)))))))))

(defmacro for
  "List comprehension. The head of the loop is a vector that contains a
  sequence of bindings modifiers and options. A binding is a sequence of three
  values `binding :verb expr`. Where `binding` is a binding as
  in let and `:verb` is one of the following keywords:

  * `:range` loop over a range by using the range function.
  * `:in` loops over all values of a collection.
  * `:keys` loops over all keys/indexes of a collection.
  * `:pairs` loops over all key-value pairs of a collection.

  After each loop binding, additional modifiers can be applied. Modifiers
  have the form `:modifier argument`. The following modifiers are supported:

  * `:while` breaks the loop if the expression is falsy.
  * `:let` defines additional bindings.
  * `:when` only evaluates the loop body if the condition is true.

  Finally, additional options can be set:

  * `:reduce [accumulator initial-value]` Instead of returning a list,
     it reduces the values into `accumulator`. Initially `accumulator`
     is bound to `initial-value`."
  [head & body]
  (let [res-sym (gensym "res__")
        acc-sym (gensym "acc__")
        options (for-builder-options head 0 {})
        swap-body (if (:reduce options)
                    (let [[sym _] (:reduce options)]
                      `(swap! ,res-sym (fn [,sym] (do ,@body))))
                    `(swap! ,res-sym (fn [,acc-sym] (push ,acc-sym (do ,@body)))))
        init (if (:reduce options)
               (second (:reduce options))
               [])
        loop-body (for-builder swap-body head 0)]
    `(let [,res-sym (var ,init)]
       ,loop-body
       (deref ,res-sym))))

(defmacro dofor
  "Repeatedly executes body for side effects with bindings and modifiers as
  provided by for. Returns nil."
  [head & body]
  (for-builder `(do ,@body) head 0))

(defmacro doseq
  "Alias for `dofor`."
  [seq-exprs & body]
  `(dofor ,seq-exprs ,@body))

# ------------------
# Sequence functions
# ------------------

(defn map
  "Returns an array consisting of the result of applying `f` to all of the first items in each `xs`,
   followed by applying `f` to all the second items in each `xs` until anyone of the `xs` is exhausted."
  [f & xs]
  (case (count xs)
    0 (throw (php/new InvalidArgumentException "expected at least one indexed collection in map"))
    1 (let [coll (first xs)
            result (for [x :in coll] (f x))]
        (with-meta coll result))
    (let [colls xs]
      (loop [res (transient [])
             seq colls]
        (if (some? empty? seq)
          (with-meta (first colls) (persistent res))
          (do
            (push res (apply f (map first seq)))
            (recur res (map next seq))))))))

(defn map-indexed
  "Applies `f` to each element in `xs`. `f` is a two-argument function. The first argument
  is an index of the element in the sequence and the second element is the element itself."
  [f xs]
  (let [result (for [[k v] :pairs xs] (f k v))]
    (with-meta xs result)))

(defn mapcat
  "Applies `f` on all `xs` and concatenate the result."
  [f & xs]
  (let [result (apply concat [] (apply map f xs))]
    (if (empty? xs)
      result
      (with-meta (first xs) result))))

(defn reduce
  "(reduce f coll) (reduce f val coll)
    f should be a function of 2 arguments. If val is not supplied, returns the result of applying f to the first 2 items in coll, then applying f to that result and the 3rd item, etc.
    If coll contains no items, f must accept no arguments as well, and reduce returns the result of calling f with no arguments. If coll has only 1 item, it is returned and f is not called.
    If val is supplied, returns the result of applying f to val and the first item in coll, then applying f to that result and the 2nd item, etc. If coll contains no items, returns val and f is not called."
  [f & xs]
  (case (count xs)
    1 (let [coll (first xs)]
        (if (empty? coll)
          (f)
          (reduce f (first coll) (next coll))))
    2 (let [val (first xs)
            coll (second xs)]
        (for [x :in coll :reduce [acc val]]
          (f acc x)))
    (throw (php/new InvalidArgumentException "expected 2 or 3 arguments in reduce"))))

(defn into
  "Returns `to` with all elements of `from` added.

   When `from` is associative, it is treated as a sequence of key-value pairs.
   Supports persistent and transient collections."
  [to & rest]
  (case (count rest)
    0 to
    1 (let [from (first rest)]
        (if (php/=== nil from)
          to
          (let [entries (if (associative? from)
                          (for [entry :pairs from] entry)
                          from)
                assoc-entry (fn [acc entry]
                              (if (indexed? entry)
                                (if (php/!= (count entry) 2)
                                  (throw (php/new InvalidArgumentException
                                                  "into expects a collection of [key value] pairs"))
                                  (let [k (first entry)
                                        v (second entry)]
                                    (if (php-array? acc)
                                      (do
                                        (php/aset acc k v)
                                        acc)
                                      (put acc k v))))
                                (throw (php/new InvalidArgumentException
                                                "into expects a collection of [key value] pairs"))))
                map-target? (or (associative? to) (php/instanceof to TransientMapInterface))]
            (cond
              map-target?
              (for [entry :in entries
                    :reduce [acc to]]
                (assoc-entry acc entry))

              (php/instanceof to TransientVectorInterface)
              (for [value :in entries
                    :reduce [acc to]]
                (push acc value))

              (php/instanceof to TransientHashSetInterface)
              (for [value :in entries
                    :reduce [acc to]]
                (push acc value))

              (php/instanceof to PushInterface)
              (for [value :in entries
                    :reduce [acc to]]
                (push acc value))

              (php/instanceof to ConcatInterface)
              (concat to entries)

              (php/is_array to)
              (concat to entries)

              (throw (php/new InvalidArgumentException
                              (php/. "Cannot convert into type " (type to))))))))
    (throw (php/new InvalidArgumentException "into expects one or two arguments"))))

(defn slice
  "Extract a slice of `xs`."
  [xs & [offset & [length]]]
  (cond
    (php-array? xs) (php/array_slice xs offset length)
    (php/instanceof xs SliceInterface) (php/-> xs (slice offset length))
    (throw (php/new InvalidArgumentException "Cannot slice"))))

(defn get-in
  "Access a value in a nested data structure. Looks into the data structure via a sequence of keys."
  [ds ks & [opt]]
  (let [res (reduce get ds ks)]
    (if (nil? res) opt res)))

(defn put-in
  "Puts a value into a nested data structure."
  [ds [k & ks] v]
  (if-not (nil? ks)
    (put ds k (put-in (get ds k {}) ks v))
    (put ds k v)))

(defn assoc-in
  "Alias for `put-in`."
  [ds ks v]
  (put-in ds ks v))

(defn update
  "Updates a value in a datastructure by applying `f` to the current element and replacing it with the result of `f`."
  [ds k f & args]
  (put ds k (apply f (get ds k) args)))

(defn update-in
  "Updates a value into a nested data structure."
  [ds [k & ks] f & args]
  (if ks
    (put ds k (apply update-in (get ds k {}) ks f args))
    (let [current (get ds k)] # Extract value first for possible call-by-reference
      (put ds k (apply f current args)))))

(defn unset-in
  "Removes a value from a nested data structure."
  [ds [k & ks]]
  (if ks
    (let [sub (get ds k)]
      (if (nil? sub)
        ds
        (put ds k (unset-in sub ks))))
    (unset ds k)))

(defn dissoc-in
  "Alias for `unset-in`."
  [ds ks]
  (unset-in ds ks))

(defn drop
  "Drops the first `n` elements of `xs`."
  [n xs]
  (slice xs (if (php/< n 0) 0 n)))

(defn drop-last
  "Drops the last `n` elements of `xs`."
  [n xs]
  (let [n (if (php/< n 0) 0 n)
        end (php/- (count xs) n)]
    (slice xs 0 (php/max 0 end))))

(defn last
  "Returns the last element of `xs` or nil if `xs` is empty or nil."
  [xs]
  (if (or (php/=== xs nil) (empty? xs))
    nil
    (peek xs)))

(defn butlast
  "Returns all but the last item in `xs`."
  [xs]
  (drop-last 1 xs))

(defn drop-while
  "Drops all elements at the front `xs` where `(pred x)` is true."
  [pred xs]
  (loop [s xs]
    (if (empty? s)
      (or s [])
      (if (pred (first s))
        (recur (next s))
        s))))

(defn take
  "Takes the first `n` elements of `xs`."
  [n xs]
  (let [n (if (php/< n 0) 0 n)]
    (cond
      (php-array? xs) (php/array_slice xs 0 n)
      (php/instanceof xs SliceInterface) (php/-> xs (slice 0 n))
      (php/instanceof xs Traversable)
      (let [i (var 0)]
        (let [result (for [x :in xs
                            :while (php/< (deref i) n)
                            :let [_ (swap! i |(php/+ $ 1))]]
                        x)]
          (with-meta xs result)))
      (throw (php/new InvalidArgumentException "Cannot take")))))

(defn take-last
  "Takes the last `n` elements of `xs`."
  [n xs]
  (if (php/<= n 0) [] (slice xs (php/* -1 n))))

(defn take-while
  "Takes all elements at the front of `xs` where `(pred x)` is true."
  [pred xs]
  (let [result (for [x :in xs :while (pred x)] x)]
    (with-meta xs result)))

(defn take-nth
  "Returns every nth item in `xs`."
  [n xs]
  (when (< n 1)
    (throw (php/new InvalidArgumentException "First argument of 'take-nth must be greater than 0")))
  (let [result (for [[i x] :pairs xs
                     :when (= (php/% i n) 0)]
                 x)]
    (with-meta xs result)))

(defn filter
  "Returns all elements of `xs` where `(pred x)` is true."
  [pred xs]
  (let [result (for [x :in xs :when (pred x)] x)]
    (with-meta xs result)))

(defn keep
  "Returns a list of non-nil results of `(pred x)`."
  [pred xs]
  (let [result (for [x :in xs
                     :let [res (pred x)]
                     :when (not (nil? res))]
                 res)]
    (with-meta xs result)))

(defn keep-indexed
  "Returns a list of non-nil results of `(pred i x)`."
  [pred xs]
  (let [result (for [[k v] :pairs xs
                     :let [res (pred k v)]
                     :when (not (nil? res))]
                 res)]
    (with-meta xs result)))

(defn find
  "Returns the first item in `xs` where `(pred item)` evaluates to true."
  [pred xs]
  (loop [s xs]
    (if (empty? s)
      nil
      (if (pred (first s))
        (first s)
        (recur (next s))))))

(defn find-index
  "Returns the index of the first item in `xs` where `(pred index item)` evaluates to true."
  [pred xs]
  (loop [s xs
         i 0]
    (if (empty? s)
      nil
      (if (pred (first s))
        i
        (recur (next s) (php/+ i 1))))))

(defn distinct
  "Returns a vector with duplicated values removed in `xs`."
  [xs]
  (let [seen (transient {})
        ret (transient [])]
    (dofor [x :in xs]
      (when-not (get seen x)
        (put seen x true)
        (push ret x)))
    (with-meta xs (persistent ret))))


(defn reverse
  "Reverses the order of the elements in the given sequence."
  [xs]
  (let [result
        (for [i :range [(php/- (count xs) 1) -1 -1]
              :reduce [ret []]]
          (push ret (get xs i)))]
    (with-meta xs result)))

(defn interleave
  "Returns a vector with the first items of each col, then the second items, etc."
  [& xs]
  (if (empty? xs)
    []
    (let [first-coll (first xs)
          size (count first-coll)
          result (loop [i 0
                        res []]
                   (let [nths (map |(get $ i) xs)]
                     (if (<= size i)
                       res
                       (recur (php/+ i 1) (concat res nths)))))]
      (with-meta first-coll result))))

(defn interpose
  "Returns a vector of elements separated by `sep`."
  [sep xs]
  (let [result
        (persistent
         (for [[k v] :pairs xs
               :reduce [res (transient [])]]
           (when (> k 0)
             (push res sep v))
           (push res v)))]
    (with-meta xs result)))

(defn frequencies
  "Returns a map from distinct items in `xs` to the number of times they appear."
  [xs]
  (let [result (for [x :in xs
                     :reduce [res {}]]
                 (let [n (get res x 0)]
                   (put res x (php/+ 1 n))))]
    (with-meta xs result)))

(defn keys
  "Gets the keys of an associative data structure."
  [xs]
  (let [result (for [k :keys xs] k)]
    (with-meta xs result)))

(defn values
  "Gets the values of an associative data structure."
  [xs]
  (let [result (for [x :in xs] x)]
    (with-meta xs result)))

(defn pairs
  "Gets the pairs of an associative data structure."
  [xs]
  (let [result (for [p :pairs xs] p)]
    (with-meta xs result)))

(defn kvs
  "Returns a vector of key-value pairs like `[k1 v1 k2 v2 k3 v3 ...]`."
  [xs]
  (let [result
        (persistent
         (for [[k v] :pairs xs
               :reduce [res (transient [])]]
           (push res k)
           (push res v)))]
    (with-meta xs result)))

(defn to-php-array
  "Create a PHP Array from a sequential data structure."
  [xs]
  (apply php/array xs))

(defn php-array-to-map
  "Converts a PHP Array to a map."
  [arr]
  (let [res (transient {})]
    (foreach [k v arr]
      (put res k v))
    (persistent res)))


(defn phel->php
  "Recursively converts a Phel data structure to a PHP array."
  [x]
  (cond
    (php-array? x)
    (let [arr (php/array)]
      (foreach [k v x]
        (php/aset arr k (phel->php v)))
      arr)

    (indexed? x)
    (let [arr (php/array)]
      (foreach [v x]
        (php/apush arr (phel->php v)))
      arr)

    (associative? x)
    (let [arr (php/array)]
      (foreach [k v x]
        (php/aset arr (name k) (phel->php v)))
      arr)

    (set? x)
    (let [arr (php/array)]
      (foreach [v x]
        (php/apush arr (phel->php v)))
      arr)

    true x))

(defn php->phel
  "Recursively converts a PHP array to Phel data structures."
  [x]
  (cond
    (indexed-php-array? x)
    (let [res (transient [])]
      (foreach [v x]
        (push res (php->phel v)))
      (persistent res))

    (php-array? x)
    (let [res (transient {})]
      (foreach [k v x]
        (put res k (php->phel v)))
      (persistent res))

    true x))

(defn contains-value?
  "Returns true if the value is present in the given collection, otherwise returns false."
  [coll val]
  (some? |(= $ val) (values coll)))

(defn sort
  "Returns a sorted vector. If no comparator is supplied compare is used."
  [xs & [comp]]
  (let [php-array (to-php-array xs)]
    (php/usort php-array (or comp compare))
    (with-meta xs (apply vector php-array))))

(defn sort-by
  "Returns a sorted vector where the sort order is determined by comparing
  `(keyfn item)`. If no comparator is supplied compare is used."
  [keyfn xs & [comp]]
  (let [php-array (to-php-array xs)
        cmp (or comp compare)]
    (php/usort php-array |(cmp (keyfn $1) (keyfn $2)))
    (with-meta xs (apply vector php-array))))

(defn shuffle
  "Returns a random permutation of xs."
  [xs]
  (let [php-array (to-php-array xs)]
    (php/shuffle php-array)
    (with-meta xs (apply vector php-array))))

(defn repeat
  "Returns a vector of length n where every element is x.
  With one argument returns an infinite sequence of x."
  [a & rest]
  (case (count rest)
    0 (php/:: Generators (repeat a))
    1 (for [i :range [a]] (get rest 0))
    (throw (php/new InvalidArgumentException "repeat expects one or two arguments"))))

(defn repeatedly
  "Returns a vector of length n with values produced by repeatedly calling f.
  With one argument returns an infinite sequence of calls to f."
  [a & rest]
  (case (count rest)
    0 (php/:: Generators (repeatedly a))
    1 (let [n a
            f (get rest 0)]
        (for [i :range [n]] (f)))
    (throw (php/new InvalidArgumentException "repeatedly expects one or two arguments"))))

(defn iterate
  "Returns an infinite sequence of x, (f x), (f (f x)), and so on."
  [f x]
  (php/:: Generators (iterate f x)))

(defn group-by
  "Returns a map of the elements of xs keyed by the result of
  f on each element."
  [f xs]
  (persistent
   (for [x :in xs
         :let [k (f x)]
         :reduce [res (transient {})]]
     (when-not (get res k)
       (put res k []))
     (update-in res [k] push x))))

(defn zipcoll
  "Creates a map from two sequential data structures. Return a new map."
  [a b]
  (apply hash-map (interleave a b)))

(defn zipmap
  "Returns a new map with the keys mapped to the corresponding values. Stops when the shorter of `keys` or `vals` is exhausted."
  [keys vals]
  (loop [ks keys
         vs vals
         res {}]
    (if (or (empty? ks) (empty? vs))
      res
      (recur (next ks) (next vs) (put res (first ks) (first vs))))))

(defn merge
  "Merges multiple maps into one new map. If a key appears in more than one
  collection, then later values replace any previous ones."
  [& maps]
  (for [map :in maps
        [k v] :pairs map
        :reduce [res {}]]
    (put res k v)))

(defn select-keys
  "Returns a new map including key value pairs from `m` selected with of keys `ks`."
  [m ks]
  (let [result (for [[k v] :pairs m
                     :when (contains-value? ks k)
                     :reduce [acc {}]]
                 (put acc k v))]
    (with-meta m result)))

(defn invert
  "Returns a new map where the keys and values are swapped. If map has
  duplicated values, some keys will be ignored."
  [map]
  (for [[k v] :pairs map
        :reduce [res {}]]
    (put res v k)))

(defn split-at
  "Returns a vector of `[(take n coll) (drop n coll)]`."
  [n xs]
  [(take n xs) (drop n xs)])

(defn split-with
  "Returns a vector of `[(take-while pred coll) (drop-while pred coll)]`."
  [f xs]
  [(take-while f xs) (drop-while f xs)])

(defn partition-by
  "Applies `f` to each value in `xs`, splitting them each time the return value changes."
  [f xs]
  (loop [xs xs
         res []]
    (if (empty? xs)
      res
      (let [k (f (first xs))
            pred (fn [x] (= k (f x)))
            [part rest] (split-with pred xs)]
        (recur rest (push res part))))))

(defn dedupe
  "Returns a vector with consecutive duplicate values removed in `xs`."
  [xs]
  (map first (partition-by (fn [x] x) xs)))

(defn partition
  "Partition an indexed data structure into vectors of maximum size n. Returns a new vector."
  [n xs]
  (if (<= (count xs) n)
    (if (= (count xs) 0) [] [xs])
    (let [res (transient [])]
      (loop [xs xs]
        (let [[a b] (split-at n xs)]
          (push res a)
          (if (>= (count b) n)
            (recur b)
            (if (= (count b) 0)
              (persistent res)
              (do
                (push res b)
                (persistent res)))))))))

# -------------
# Set operation
# -------------

(defn union
  "Union multiple sets into a new one."
  [& sets]
  (let [target (transient (set))]
    (foreach [s sets]
      (foreach [v s]
        (php/-> target (add v))))
    (persistent target)))

(defn- intersection-pair
  [s1 s2]
  (if (< (count s2) (count s1))
    (recur s2 s1)
    (let [result (transient s1)]
      (foreach [item s1]
        (when-not (php/-> s2 (contains item))
          (php/-> result (remove item))))
      (persistent result))))

(defn intersection
  "Intersect multiple sets into a new one."
  [set & sets]
  (reduce intersection-pair set sets))

(defn difference-pair
  [s1 s2]
  (if (< (count s1) (count s2))
    (let [result (transient s1)]
      (foreach [item s1]
        (when (php/-> s2 (contains item))
          (php/-> result (remove item))))
      (persistent result))

    (let [result (transient s1)]
      (foreach [item s2]
        (php/-> result (remove item)))
      (persistent result))))

(defn difference
  "Difference between multiple sets into a new one."
  [set & sets]
  (reduce difference-pair set sets))

(defn symmetric-difference
  "Symmetric difference between multiple sets into a new one."
  [set & sets]
  (reduce |(union (difference $1 $2) (difference $2 $1)) set sets))

# ------------------
# Function operation
# ------------------

(defn identity
  "Returns its argument."
  [x]
  x)

(defn constantly
  "Returns a function that always returns `x` and ignores any passed arguments."
  [x]
  (fn [& _] x))

(defn comp
  "Takes a list of functions and returns a function that is the composition of those functions."
  [& fs]
  (case (count fs)
    0 identity
    1 (first fs)
    2 |((first fs) (apply (second fs) $&))
    (reduce comp fs)))

(defn complement
  "Returns a function that takes the same arguments as `f` and returns the opposite truth value."
  [f]
  |(not (apply f $&)))

(defn juxt
  "Takes a list of functions and returns a new function that is the juxtaposition of those functions.
  `((juxt a b c) x) => [(a x) (b x) (c x)]`."
  [& fs]
  (fn [& args]
    (reduce
     |(push $1 (apply $2 args))
     []
     fs)))

(defn partial
  "Takes a function `f` and fewer than normal arguments of `f` and returns a function
  that a variable number of additional arguments. When call `f` will be called
  with `args` and the additional arguments."
  [f & args]
  |(apply f (concat [] args $&)))

(defn memoize
  "Returns a memoized version of the function `f`. The memoized function
  caches the return value for each set of arguments."
  [f]
  (let [memoize-cache (var {})]
    (fn [& args]
      (let [c (deref memoize-cache)]
        (if (contains? c args)
          (get c args)
          (let [res (apply f args)]
            (set! memoize-cache (put c args res))
            res))))))

# -----------------------
# More sequence operation
# -----------------------

(defn tree-seq
  "Returns a vector of the nodes in the tree, via a depth-first walk.
  branch? is a function with one argument that returns true if the given node
  has children.
  children must be a function with one argument that returns the children of the node.
  root the root node of the tree."
  [branch? children root]
  (let [ret (transient [])]
    (loop [stack (php/array root)]
      (if (> (count stack) 0)
        (let [node (pop stack)]
          (push ret node)
          (if (branch? node)
            (recur (concat stack (reverse (children node))))
            (recur stack)))
        (with-meta root (persistent ret))))))

(defn flatten
  "Takes a nested sequential data structure `(tree)`, and returns their contents
  as a single, flat vector."
  [xs]
  (filter
   (complement indexed?)
   (rest (tree-seq indexed? identity xs))))

(defn- merge-with-2 [f left right]
  (for [[k v] :pairs right
        :reduce [acc left]]
    (if (contains? acc k)
      (put acc k (f (get acc k) v))
      (put acc k v))))

(defn merge-with
  "Merges multiple maps into one new map. If a key appears in more than one
   collection, the result of `(f current-val next-val)` is used."
  [f & hash-maps]
  (case (count hash-maps)
    0 {}
    1 (first hash-maps)
    2 (merge-with-2 f (first hash-maps) (second hash-maps))
    (reduce (partial merge-with f) (first hash-maps) (rest hash-maps))))

(declare deep-merge)

(defn- deep-merge-2 [left right]
  (cond
    (nil? left) right
    (nil? right) left
    (and (hash-map? left) (hash-map? right)) (merge-with deep-merge left right)
    (and (set? left) (set? right)) (union left right)
    (and (vector? left) (vector? right)) (concat left right)
    right))

(defn deep-merge
  "Recursively merges data structures."
  [& args]
  (case (count args)
    0 {}
    1 (first args)
    2 (deep-merge-2 (first args) (second args))
    (reduce deep-merge (first args) (rest args))))

# ---
# Math helpers
# ---

(defn assert-non-nil
  [& xs]
  (foreach [x xs]
    (when (php/=== nil x)
      (throw (php/new \InvalidArgumentException "Arithmetic functions do not accept nil values")))))

# -----------------
# Bitwise operation
# -----------------

(defn bit-and
  "Bitwise and."
  {:inline (fn [x y & args] `(do (assert-non-nil ,x ,y ,@args) (php/& ,x ,y ,@args)))}
  [x y & args]
  (apply assert-non-nil (concat [x y] args))
  (let [all (concat [x y] args)]
    (reduce |(php/& $1 $2) all)))

(defn bit-or
  "Bitwise or."
  {:inline (fn [x y & args] `(do (assert-non-nil ,x ,y ,@args) (php/| ,x ,y ,@args)))}
  [x y & args]
  (apply assert-non-nil (concat [x y] args))
  (let [all (concat [x y] args)]
    (reduce |(php/| $1 $2) all)))

(defn bit-xor
  "Bitwise xor."
  {:inline (fn [x y & args] `(do (assert-non-nil ,x ,y ,@args) (php/^ ,x ,y ,@args)))}
  [x y & args]
  (apply assert-non-nil (concat [x y] args))
  (let [all (concat [x y] args)]
    (reduce |(php/^ $1 $2) all)))

(defn bit-not
  "Bitwise complement."
  {:inline (fn [x] `(do (assert-non-nil ,x) (php/~ ,x)))}
  [x]
  (assert-non-nil x)
  (php/~ x))

(defn bit-shift-left
  "Bitwise shift left."
  {:inline (fn [x n] `(do (assert-non-nil ,x ,n) (php/<< ,x ,n)))}
  [x n]
  (assert-non-nil x n)
  (php/<< x n))

(defn bit-shift-right
  "Bitwise shift right."
  {:inline (fn [x n] `(do (assert-non-nil ,x ,n) (php/>> ,x ,n)))}
  [x n]
  (assert-non-nil x n)
  (php/>> x n))

(defn bit-set
  "Set bit an index `n`."
  [x n]
  (bit-or x (bit-shift-left 1 n)))

(defn bit-clear
  "Clear bit an index `n`."
  [x n]
  (bit-and x (bit-not (bit-shift-left 1 n))))

(defn bit-flip
  "Flip bit at index `n`."
  [x n]
  (bit-xor x (bit-shift-left 1 n)))

(defn bit-test
  "Test bit at index `n`."
  [x n]
  (php/!= 0 (bit-and x (bit-shift-left 1 n))))

# --------------
# Math operation
# --------------

(def NAN
  "Constant for Not a Number (NAN) values."
  php/NAN)

(defn +
  "Returns the sum of all elements in `xs`. All elements `xs` must be numbers.
  If `xs` is empty, return 0."
  {:inline (fn [& xs] `(do (assert-non-nil ,@xs) (php/+ ,@xs)))
   :inline-arity (fn [n] (> n 0))}
  [& xs]
  (apply assert-non-nil xs)
  (if (empty? xs)
    0
    (apply php/+ xs)))

(defn -
  "Returns the difference of all elements in `xs`. If `xs` is empty, return 0. If `xs`
  has one element, return the negative value of that element."
  {:inline (fn [& xs] `(do (assert-non-nil ,@xs) (php/- ,@xs)))
   :inline-arity (fn [n] (> n 1))}
  [& xs]
  (apply assert-non-nil xs)
  (case (count xs)
    0 0
    1 (php/* -1 (first xs))
    2 (php/- (first xs) (second xs))
    (reduce |(php/- $1 $2) xs)))

(defn *
  "Returns the product of all elements in `xs`. All elements in `xs` must be
numbers. If `xs` is empty, return 1."
  {:inline (fn [& xs] `(do (assert-non-nil ,@xs) (php/* ,@xs)))
   :inline-arity (fn [n] (> n 0))}
  [& xs]
  (apply assert-non-nil xs)
  (case (count xs)
    0 1
    1 (first xs)
    2 (php/* (first xs) (second xs))
    (reduce |(php/* $1 $2) xs)))

(defn /
  "Returns the nominator divided by all the denominators. If `xs` is empty,
returns 1. If `xs` has one value, returns the reciprocal of x."
  {:inline (fn [& xs] `(do (assert-non-nil ,@xs) (php// ,@xs)))
   :inline-arity (fn [n] (> n 1))}
  [& xs]
  (apply assert-non-nil xs)
  (case (count xs)
    0 1
    1 (php// 1 (first xs))
    2 (php// (first xs) (second xs))
    (reduce |(php// $1 $2) xs)))

(defn %
  "Return the remainder of `dividend` / `divisor`."
  {:inline (fn [dividend divisor] `(do (assert-non-nil ,dividend ,divisor) (php/% ,dividend ,divisor)))}
  [dividend divisor]
  (assert-non-nil dividend divisor)
  (php/% dividend divisor))

(defn **
  "Return `a` to the power of `x`."
  {:inline (fn [a x] `(do (assert-non-nil ,a ,x) (php/** ,a ,x)))}
  [a x]
  (assert-non-nil a x)
  (php/** a x))

(defn inc
  "Increments `x` by one."
  {:inline (fn [x] `(do (assert-non-nil ,x) (php/+ ,x 1)))}
  [x]
  (assert-non-nil x)
  (+ x 1))

(defn dec
  "Decrements `x` by one."
  {:inline (fn [x] `(do (assert-non-nil ,x) (php/- ,x 1)))}
  [x]
  (assert-non-nil x)
  (- x 1))

(defn even?
  "Checks if `x` is even."
  [x]
  (= 0 (% x 2)))

(defn odd?
  "Checks if `x` is odd."
  [x]
  (= 1 (% x 2)))

(defn zero?
  "Checks if `x` is zero."
  [x]
  (or (= x 0) (= x 0.0)))

(defn one?
  "Checks if `x` is one."
  [x]
  (or (= x 1) (= x 1.0)))

(defn pos?
  "Checks if `x` is greater than zero."
  [x]
  (> x 0))

(defn neg?
  "Checks if `x` is smaller than zero."
  [x]
  (< x 0))

(defn nan?
  "Checks if `x` is not a number."
  [x]
  (php/is_nan x))

(defn rand
  "Returns a random number between 0 and 1."
  []
  (/ (php/random_int 0 php/PHP_INT_MAX) php/PHP_INT_MAX))

(defn rand-int
  "Returns a random number between 0 and `n`."
  [n]
  (php/random_int 0 n))

(defn rand-nth
  "Returns a random item from xs."
  [xs]
  (get xs (rand-int (dec (count xs)))))

(defn extreme
  "Returns the most extreme value in `args` based on the binary `order` function."
  [order args]
  (reduce |(if (order $1 $2) $1 $2) args))

(defn min
  "Returns the numeric minimum of all numbers."
  [& numbers]
  (extreme < numbers))

(defn max
  "Returns the numeric maximum of all numbers."
  [& numbers]
  (extreme > numbers))

(defn coerce-in
  "Returns `v` if it is in the range, or `min` if `v` is less than `min`, or `max` if `v` is greater than `max`."
  [v min max]
  (when (< max min)
    (throw (php/new \InvalidArgumentException "Max values is bigger than min value")))
  (php/max (php/min v max) min))

(defn sum
  "Returns the sum of all elements is `xs`."
  [xs]
  (apply + xs))

(defn mean
  "Returns the mean of `xs`."
  [xs]
  (/ (sum xs) (count xs)))

(defn median
  "Returns the median of `xs`."
  [xs]
  (let [arr (to-php-array xs)
        cnt (count arr)]
    (when (zero? cnt)
      (throw (php/new \InvalidArgumentException "Cannot compute median of empty sequence")))
    (php/sort arr)
    (let [mid (php/intdiv cnt 2)]
      (if (odd? cnt)
        (php/aget arr mid)
        (/ (+ (php/aget arr (dec mid)) (php/aget arr mid)) 2)))))

# ---------------
# Print operation
# ---------------

(defmacro with-output-buffer
  "Everything that is printed inside the body will be stored in a buffer.
   The result of the buffer is returned."
  [& body]
  (let [res (gensym)]
    `(do
       (php/ob_start)
       ,@body
       (let [,res (php/ob_get_contents)]
         (php/ob_end_clean)
         ,res))))

(defn print-str
  "Same as print. But instead of writing it to an output stream, the resulting string is returned."
  [& xs]
  (let [len (count xs)
        printer (php/:: Printer (nonReadable))
        pp |(php/-> printer (print $))]
    (case (count xs)
      0 ""
      1 (pp (first xs))
      (loop [res (pp (first xs))
             seq (next xs)]
        (if seq
          (recur (str res " " (pp (first seq))) (next seq))
          res)))))

(defn print
  "Prints the given values to the default output stream. Returns nil."
  [& xs]
  (php/print (apply print-str xs))
  nil)

(defn println
  "Same as print followed by a newline."
  [& xs]
  (apply print xs)
  (php/print "\n")
  nil)

(defn format
  "Returns a formatted string. See PHP's [sprintf](https://www.php.net/manual/en/function.sprintf.php) for more information."
  [fmt & xs]
  (apply php/sprintf fmt xs))

(defn printf
  "Output a formatted string. See PHP's [printf](https://www.php.net/manual/en/function.printf.php) for more information."
  [fmt & xs]
  (apply php/printf fmt xs)
  nil)

# ---------------
# File operations
# ---------------

(defn slurp
  "Reads entire file into a string. Accepts `opts` map for overriding default
  PHP file_get_contents arguments.
  See PHP's [file_get_contents](https://www.php.net/manual/en/function.file-get-contents.php) for more information."
  [filename & [opts]]
  (when-not (php/is_file filename)
    (throw (php/new \InvalidArgumentException
                    "Argument filename should be a valid path to a file")))
  (let [opts             (or opts {})
        use-include-path (or (:use-include-path opts) false)
        context          (or (:context opts) nil)
        offset           (or (:offset opts) 0)
        length           (or (:length opts) nil)
        content (php/file_get_contents filename use-include-path context offset length)]
    (when content content)))

(defn spit
  "Writes data to file, returning number of bytest that were written or `nil`
  on failure. Accepts `opts` map for overriding default PHP file_put_contents
  arguments, as example to append to file use {:flags php/FILE_APPEND}.
  See PHP's [file_put_contents](https://www.php.net/manual/en/function.file-put-contents.php) for more information."
  [filename data & [opts]]
  (when (php/is_dir filename)
    (throw (php/new \InvalidArgumentException
                    "Argument filename should be a valid path to a file, directory given.")))
  (let [opts    (or opts {})
        flags   (or (:flags opts) 0)
        context (or (:context opts) nil)
        result (php/file_put_contents filename data flags context)]
    (when (int? result) result)))

# ----------------
# Threading macros
# ----------------

(defmacro ->
  "Threads the expr through the forms. Inserts `x` as the second item
  in the first form, making a list of it if it is not a list already.
  If there are more forms, insert the first form as the second item in
  the second form, etc."
  [x & forms]
  (loop [x x
         forms (if (empty? forms) nil forms)]
    (if forms
      (let [form (first forms)
            threaded (if (list? form)
                       (with-meta form `(,(first form) ,x ,@(next form)))
                       (with-meta form (list form x)))]
        (recur threaded (next forms)))
      x)))

(defmacro ->>
  "Threads the expr through the forms. Inserts `x` as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, insert the first form as the
  last item in the second form, etc."
  [x & forms]
  (loop [x x
         forms (if (empty? forms) nil forms)]
    (if forms
      (let [form (first forms)
            threaded (if (list? form)
                       (with-meta form `(,(first form) ,@(next form) ,x))
                       (with-meta form (list form x)))]
        (recur threaded (next forms)))
      x)))

(defmacro some->
  "Threads `x` through the forms like `->` but stops when a form returns `nil`."
  [x & forms]
  (loop [x x
         forms (if (empty? forms) nil forms)]
    (if forms
      (let [form (first forms)
            g (gensym)
            call (if (list? form)
                   (let [rest (next form)
                         args (if rest
                                (cons g rest)
                                [g])]
                     (with-meta form (apply list (cons (first form) args))))
                   (with-meta form (list form g)))
            threaded (list 'let
                           [g x]
                           (list 'if
                                 (list 'php/=== nil g)
                                 nil
                                 call))]
        (recur threaded (next forms)))
      x)))

(defmacro some->>
  "Threads `x` through the forms like `->>` but stops when a form returns `nil`."
  [x & forms]
  (loop [x x
         forms (if (empty? forms) nil forms)]
    (if forms
      (let [form (first forms)
            g (gensym)
            call (if (list? form)
                   (let [rest (next form)
                         args (if rest
                                (concat rest [g])
                                [g])]
                     (with-meta form (apply list (cons (first form) args))))
                   (with-meta form (list form g)))
            threaded (list 'let
                           [g x]
                           (list 'if
                                 (list 'php/=== nil g)
                                 nil
                                 call))]
        (recur threaded (next forms)))
      x)))

(defmacro as->
  "Binds `name` to `expr`, evaluates the first form in the lexical context
  of that binding, then binds name to that result, repeating for each
  successive form, returning the result of the last form."
  [expr name & forms]
  (let [x (gensym)]
    `(let [,name ,expr
           ,@(interleave (repeat (count forms) name) forms)]
       ,name)))

(defmacro doto
  "Evaluates x then calls all of the methods and functions with the
  value of x supplied at the front of the given arguments. The forms
  are evaluated in order. Returns x."
  [x & forms]
  (let [gx (gensym)]
    `(let [,gx ,x]
       ,@(map (fn [f]
                (if (list? f)
                  (with-meta f `(,(first f) ,gx ,@(next f)))
                  (with-meta f `(,f ,gx))))
              forms)
       ,gx)))

# ---------------
# Regex functions
# ---------------

(defn re-seq
  "Returns a sequence of successive matches of pattern in string."
  [re s]
  (let [matches (php/array)
        match-result (php/preg_match_all re s matches)]
    (apply vector (php/aget matches 0))))

# -------
# Binding
# -------

# inspired by Clojure's with-redefs
(defmacro binding
  "Temporary redefines definitions while executing the body.
  The value will be reset after the body was executed."
  [bindings & body]
  (let [names (take-nth 2 bindings)
        vals (take-nth 2 (drop 1 bindings))
        orig-val-syms (map gensym names)
        temp-val-syms (map gensym names)
        binds (map vector names temp-val-syms)
        resets (reverse (map vector names orig-val-syms))
        bind-value (fn [[k v]] (list 'set-var k v))]
    `(let [,@(interleave orig-val-syms names)
           ,@(interleave temp-val-syms vals)]
       ,@(map bind-value binds)
       (try
         (do ,@body)
         (finally
           ,@(map bind-value resets))))))

# ----------
# Interfaces
# ----------

(defmacro definterface
  "Defines an interface."
  [name & fns]
  (let [name-str (php/-> name (getName))
        munge (php/new Munge)
        class-name-str (php/. *ns* "\\" (php/-> munge (encode name-str)))
        defs (for [[fn-name args doc] :in fns
                   :let [fn-name-str (php/-> fn-name (getName))
                         munged-fn-name (php/-> munge (encode fn-name-str))
                         munged-fn-symbol (php/:: Symbol (create munged-fn-name))]]
               `(defn ,fn-name {:doc ,doc} ,args
                  (if (php/is_a ,(first args) ,class-name-str)
                    (php/-> ,(first args) (,munged-fn-symbol ,@(rest args)))
                    (throw (php/new \InvalidArgumentException ,(str "Value doesn't implement interface " name))))))]
    `(do
       (definterface* ,name ,@fns)
       ,@defs)))

(defmacro if-let
  "If test is true, evaluates then with binding-form bound to the value of test,
  if not, yields else"
  [bindings then & [else]]
  (let [err |(throw (php/new \InvalidArgumentException $))]
    (when-not
      (vector? bindings)
      (err (str "if-let requires a vector for it's bindings, "
                (type bindings) " given")))
    (when-not
      (= 2 (count bindings))
      (err (str "if-let requires bindings to have 2 elements, "
                (count bindings) " given"))))

  (let [form (bindings 0) tst (bindings 1) temp-sym (gensym)]
    `(let [temp-sym ,tst]
       (if temp-sym
         (let [,form temp-sym]
           ,then)
         ,else))))

(defmacro when-let
  "When test is true, evaluates body with binding-form bound to the value of test"
  [bindings & body]
  (let [err |(throw (php/new \InvalidArgumentException $))]
    (when-not
      (vector? bindings)
      (err (str "when-let requires a vector for it's bindings, "
                (type bindings) " given")))
    (when-not
      (= 2 (count bindings))
      (err (str "when-let requires bindings to have 2 elements, "
                (count bindings) " given"))))

  (let [form (bindings 0) tst (bindings 1) temp-sym (gensym)]
    `(let [temp-sym ,tst]
       (when temp-sym
         (let [,form temp-sym]
           ,@body)))))

(defmacro time
  "Evaluates expr and prints the time it took. Returns the value of expr."
  [expr]
  `(let [start$ (php/microtime true)
         ret$ ,expr]
     (println "Elapsed time:" (* 1000 (- (php/microtime true) start$)) "msecs")
     ret$))

(defn name
  "Returns the name string of a string, keyword or symbol."
  [x]
  (if (string? x) x (php/-> x (getName))))

(defn namespace
  "Return the namespace string of a symbol or keyword. Nil if not present."
  [x]
  (php/-> x (getNamespace)))

(defn full-name
  "Return the namespace and name string of a string, keyword or symbol."
  [x]
  (if (string? x) x (php/-> x (getFullName))))

(defn read-string
  "Reads the first phel expression from the string s."
  [s]
  (let [cf (php/new CompilerFacade)
        token-stream (php/-> cf (lexString s))
        node (php/-> cf (parseNext token-stream))]
    (when node
      (php/-> (php/-> cf (read node)) (getAst)))))

(defn eval
  "Evaluates a form and return the evaluated results."
  [form]
  (let [cf (php/new CompilerFacade)]
    (php/-> cf (evalForm form))))

(defn compile
  "Returns the compiled PHP code string for the given form."
  [form]
  (let [cf (php/new CompilerFacade)]
    (php/-> (php/-> cf (compileForm form)) (getPhpCode))))

(defn- get-global-env []
  (php/:: GlobalEnvironmentSingleton (getInstance)))

(defn- get-global-var-node [sym]
  (php/-> (get-global-env) (resolve sym (php/:: NodeEnvironment (empty)))))

(defn- inline-call? [meta arity]
  (and (:inline meta)
       (let [af (:inline-arity meta)]
         (if af
           (af arity)
           true))))

(defn macroexpand-1
  "Expands the given form once if it is a macro call."
  [form]
  (if (and (list? form) (not (empty? form)))
    (let [op (first form)]
      (if (symbol? op)
        (let [node (get-global-var-node op)]
          (if (php/instanceof node GlobalVarNode)
            (let [meta (php/-> node (getMeta))
                  ns (php/-> node (getNamespace))
                  name (php/-> (php/-> node (getName)) (getName))
                  args (rest form)]
              (cond
                (inline-call? meta (count args))
                (apply (:inline meta) args)
                (:macro meta)
                (let [macro-fn (php/:: Phel (getDefinition ns name))]
                  (apply macro-fn args))
                :else
                form))
            form))
        form))
    form))

(defn macroexpand
  "Recursively expands the given form until it is no longer a macro call."
  [form]
  (loop [f form]
    (let [e (macroexpand-1 f)]
      (if (= e f)
        e
        (recur e)))))
