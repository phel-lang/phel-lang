(ns phel\core
  (:use Countable)
  (:use Traversable)
  (:use InvalidArgumentException)
  (:use Phel)
  (:use Phel\Compiler\Application\Munge)
  (:use Phel\Compiler\CompilerFacade)
  (:use Phel\Compiler\Domain\Analyzer\Ast\GlobalVarNode)
  (:use Phel\Compiler\Domain\Analyzer\Environment\NodeEnvironment)
  (:use Phel\Compiler\Infrastructure\GlobalEnvironmentSingleton)
  (:use Phel\Lang\AbstractType)
  (:use Phel\Lang\CdrInterface)
  (:use Phel\Lang\Collections\HashSet\PersistentHashSetInterface)
  (:use Phel\Lang\Collections\HashSet\TransientHashSetInterface)
  (:use Phel\Lang\Collections\LinkedList\PersistentListInterface)
  (:use Phel\Lang\Collections\Map\PersistentMapInterface)
  (:use Phel\Lang\Collections\Map\TransientMapInterface)
  (:use Phel\Lang\Collections\Struct\AbstractPersistentStruct)
  (:use Phel\Lang\Collections\Vector\PersistentVectorInterface)
  (:use Phel\Lang\Collections\Vector\TransientVectorInterface)
  (:use Phel\Lang\ConcatInterface)
  (:use Phel\Lang\ConsInterface)
  (:use Phel\Lang\ContainsInterface)
  (:use Phel\Lang\FirstInterface)
  (:use Phel\Lang\IdenticalInterface)
  (:use Phel\Lang\Keyword)
  (:use Phel\Lang\MetaInterface)
  (:use Phel\Lang\PopInterface)
  (:use Phel\Lang\PushInterface)
  (:use Phel\Lang\RemoveInterface)
  (:use Phel\Lang\RestInterface)
  (:use Phel\Lang\SliceInterface)
  (:use Phel\Lang\Symbol)
  (:use Phel\Lang\Truthy)
  (:use Phel\Lang\Variable)
  (:use Phel\Lang\Generators)
  (:use Phel\Lang\Hasher)
  (:use Phel\Lang\Equalizer)
  (:use Phel\Lang\Collections\LazySeq\LazySeq)
  (:use Phel\Lang\Collections\LazySeq\LazySeqInterface)
  (:use Phel\Lang\Collections\LazySeq\ChunkedSeq)
  (:use Phel\Printer\Printer))

(def *ns*
  "Returns the namespace in the current scope."
  "\\phel\\core")

(def *file*
  "Returns the path to the current source file."
  "")

# --------------------------------------------
# Basic methods for quasiquote and destructure
# --------------------------------------------

(def list
  "Creates a new list from the given arguments. Shortcut: '()

  Example:
    (list 1 2 3)
    # => (1 2 3)"
  (fn [& xs] (php/:: Phel (list (apply php/array xs)))))

(def vector
  "Creates a new vector from the given arguments. Shortcut: []

  Example:
    (vector 1 2 3)
    # => [1 2 3]"
  (fn [& xs] (php/:: Phel (vector (apply php/array xs)))))

(def hash-map
  "Creates a new hash map from key-value pairs. Shortcut: {}

  Example:
    (hash-map :a 1 :b 2)
    # => {:a 1 :b 2}"
  (fn [& xs] (php/:: Phel (map (apply php/array xs)))))

(def next
  "Returns the sequence after the first element, or nil if empty.

  Example:
    (next [1 2 3])
    # => [2 3]"
  (fn [xs]
    (if (php/=== xs nil)
      nil
      (if (php/instanceof xs CdrInterface)
        (php/-> xs (cdr))
        (if (php/is_array xs)
          (let [sliced (php/array_slice xs 1)]
            (if (php/empty sliced)
              nil
              sliced))
          (throw (php/new InvalidArgumentException
                          (php/. "cannot call 'next on " (php/gettype xs)))))))))

(def first
  "Returns the first element of a sequence, or nil if empty.

  Example:
    (first [1 2 3])
    # => 1"
  (fn [xs]
    (if (php/instanceof xs FirstInterface)
      (php/-> xs (first))
      (php/aget xs 0))))

(def concat1
  {:private true
   :doc "Concatenates two sequential data structures."}
  (fn [xs ys]
    (if (php/=== nil ys)
      xs
      (if (php/instanceof xs ConcatInterface)
        (php/-> xs (concat ys))
        (do
          (foreach [y ys]
            (php/apush xs y))
          xs)))))

(def concat
  "Concatenates multiple sequential data structures."
  (fn [arr & others]
    (if (php/=== nil arr)
      '()
      (loop [res arr
             other others]
        (if (php/=== nil other)
          res
          (let [[y & ys] other]
            (recur (concat1 res y) ys)))))))

# quasiquote can be used down here

(def declare
  {:macro true
   :doc "Declare a global symbol before it is defined."}
  (fn [name]
    `(def ,name nil)))

(declare nil?)
(def argv
  "Vector of arguments passed to the script."
  (let [argv-raw (php/aget php/$GLOBALS "argv")]
    (if (php/=== argv-raw nil)
      []
      (php/:: Phel (vector argv-raw)))))

# ------------
# Meta helpers
# ------------

(declare =)
(declare symbol?)
(declare list?)
(declare second)
(declare conj)

(def meta
  {:macro true
   :doc "Gets the metadata of the given object or definition."}
  (fn [obj]
    (let [sym (if (symbol? obj)
                obj
                (if (list? obj)
                  (if (= (first obj) 'quote)
                    (if (symbol? (second obj))
                      (second obj)
                      nil)
                    nil)
                  nil))]
      (if sym
        (let [ns (php/-> sym (getNamespace))]
          (if ns
            `(php/:: \Phel (getDefinitionMetaData ,ns ,(php/-> sym (getName))))
            `(php/:: \Phel (getDefinitionMetaData *ns* ,(php/-> sym (getName))))))
        `(let [obj-meta ,obj]
           (if (php/instanceof obj-meta \Phel\Lang\MetaInterface)
             (php/-> obj-meta (getMeta))
             nil))))))

(def set-meta!
  "Sets the metadata to a given object."
  (fn [obj meta]
    (php/-> obj (withMeta meta))))

(def with-meta
  {:private true
   :doc "Returns `target` with the metadata from `source` when both implement `MetaInterface`."}
  (fn [source target]
    (if (php/instanceof source MetaInterface)
      (if (php/instanceof target MetaInterface)
        (php/-> target (withMeta (php/-> source (getMeta))))
        target)
      target)))

# ------------
# Basic macros
# ------------

(def defn-builder
  {:macro true
   :private true}
  (fn [name meta & fdecl]
    (let [meta (if (php/is_string (php/aget fdecl 0))
                 (php/-> meta (put :doc (php/aget fdecl 0)))
                 meta)
          fdecl (if (php/is_string (php/aget fdecl 0))
                  (next fdecl)
                  fdecl)
          meta (if (php/instanceof (php/aget fdecl 0) PersistentMapInterface)
                 (php/-> meta (merge (php/aget fdecl 0)))
                 meta)
          fdecl (if (php/instanceof (php/aget fdecl 0) PersistentMapInterface)
                  (next fdecl)
                  fdecl)
          args (if (php/instanceof (php/aget fdecl 0) PersistentVectorInterface)
                 (php/aget fdecl 0)
                 (php/aget (php/aget fdecl 0) 0))
          docstring (php/aget meta :doc)
          docstring (php/. "```phel\n(" name " " (php/implode " " (apply php/array args)) ")\n```\n" docstring)
          meta (php/-> meta (put :doc docstring))]
      `(def ,name ,meta (fn ,@fdecl)))))

(def defn
  {:macro true
   :doc "Define a new global function."}
  (fn [name & fdecl] (apply defn-builder name {} fdecl)))

(def def-
  {:macro true
   :doc "Define a private value that will not be exported."}
  (fn [name value] `(def ,name {:private true} ,value)))

(def defmacro
  {:macro true
   :doc "Define a macro."}
  (fn [name & fdecl] (apply defn-builder name {:macro true} fdecl)))

(defmacro defn-
  "Define a private function that will not be exported."
  [name & fdecl]
  (apply defn-builder name {:private true} fdecl))

(defmacro defmacro-
  "Define a private macro that will not be exported."
  [name & fdecl]
  (apply defn-builder name {:macro true :private true} fdecl))

(defmacro defstruct
  "Define a new struct."
  [name keys & implementations]
  (let [name-str (php/-> name (getName))
        munge (php/new Munge)
        class-name-str (php/. *ns* "\\" (php/-> munge (encode name-str)))
        is-name (php/:: Symbol (create (php/. name-str "?")))]
    `(do
       (defstruct* ,name ,keys ,@implementations)
       (defn ,name ,(php/. "Creates a new " name " struct.") ,keys (php/new ,class-name-str ,@keys))
       (defn ,is-name ,(php/. "Checks if `x` is an instance of the " name " struct.") [x] (php/is_a x ,class-name-str)))))

(defmacro defexception
  "Define a new exception."
  [name]
  (let [name-str (php/-> name (getName))
        munge (php/new Munge)
        class-name-str (php/. *ns* "\\" (php/-> munge (encode name-str)))
        is-name (php/:: Symbol (create (php/. name-str "?")))]
    `(do
       (defexception* ,name)
       (defn ,name ,(php/. "Creates a new " name " exception.") [& args] (apply php/new ,class-name-str args))
       (defn ,is-name ,(php/. "Checks if `x` is an instance of the " name " exception.") [x] (php/is_a x ,class-name-str)))))

(defmacro comment
  "Ignores the body of the comment."
  [&])

(defn symbol
  "Returns a new symbol for given string with optional namespace.
   Arity-1 returns a symbol without namespace. Arity-2 returns a symbol in given namespace."
  [name-or-ns & [name]]
  (if name
    (php/:: Symbol (createForNamespace name-or-ns name))
    (php/:: Symbol (create name-or-ns))))

(defn gensym
  "Generates a new unique symbol."
  []
  (php/:: Symbol (gen)))

(defn str
  "Creates a string by concatenating values together. If no arguments are
provided an empty string is returned. Nil and false are represented as an empty
string. True is represented as 1. Otherwise, it tries to call `__toString`.
This is PHP equivalent to `$args[0] . $args[1] . $args[2] ...`."
  {:inline (fn [& args] `(php/. "" ,@args))
   :inline-arity (fn [n] (php/> n 0))}
  [& args]
  (if (php/== (php/count args) 0)
    ""
    (apply php/. "" args)))

(defn transient
  "Converts a persistent collection to a transient collection."
  [coll]
  (php/-> coll (asTransient)))

(defn persistent
  "Converts a transient collection to a persistent collection."
  [coll]
  (php/-> coll (persistent)))

# ------------------
# Basic constructors
# ------------------

(defn set
  "Creates a new Set from the given arguments. Shortcut: #{}

  Example:
    (set 1 2 3)
    # => #{1 2 3}"
  [& xs]
  (php/:: Phel (set (apply php/array xs))))

(defn keyword
  "Creates a new Keyword from a given string."
  [x]
  (php/:: Keyword (create x)))

(defn php-indexed-array
  "Creates a PHP indexed array from the given values."
  [& xs]
  (apply php/array xs))

(defn php-associative-array
  "Creates a PHP associative array. An even number of parameters must be provided."
  [& xs]
  (let [cnt (php/count xs)
        res (php/array)]
    (if (php/=== 1 (php/% cnt 2))
      (throw (php/new InvalidArgumentException "An even number of parameters must be provided for 'php-associative-array'")))
    (loop [i 0]
      (if (php/< i cnt)
        (do
          (php/aset res (php/aget xs i) (php/aget xs (php/+ i 1)))
          (recur (php/+ i 2)))
        res))))

# ------------------------
# Basic sequence operation
# ------------------------

(defn- equals1 [a b]
  (if (php/instanceof a AbstractType)
    (php/-> a (equals b))
    (php/=== a b)))

(defn cons
  "Prepends an element to the beginning of a collection.

  Example:
    (cons 0 [1 2 3])
    # => [0 1 2 3]"
  [x coll]
  (if (php/is_array coll)
    (do
      (php/array_unshift coll x)
      coll)
    (if (php/instanceof coll ConsInterface)
      (php/-> coll (cons x))
      (if (php/=== coll nil)
        [x]
        (throw (php/new InvalidArgumentException
                        (php/. "cannot do cons " (php/print_r x true))))))))

(defn ffirst
  "Same as `(first (first coll))`."
  [coll]
  (first (first coll)))

(defn second
  "Returns the second element of a sequence, or nil if not present.

  Example:
    (second [1 2 3])
    # => 2"
  [coll]
  (first (next coll)))

(defn rest
  "Returns the sequence after the first element, or empty sequence if none.

  Example:
    (rest [1 2 3])
    # => [2 3]"
  [coll]
  (if (php/instanceof coll RestInterface)
    (php/-> coll (rest))
    (if (php/is_array coll)
      (php/array_slice coll 1)
      (throw (php/new InvalidArgumentException "cannot do rest")))))

(defn nfirst
  "Same as `(next (first coll))`."
  [coll]
  (next (first coll)))

(defn nnext
  "Same as `(next (next coll))`."
  [coll]
  (next (next coll)))

(defn count
  "Counts the number of elements in a sequence. Can be used on everything that implements the PHP Countable interface.

  Works with lists, vectors, hash-maps, sets, and PHP arrays.
  Returns 0 for nil. Throws an exception for strings (use `php/strlen` or `php/mb_strlen` instead).

  Examples:
    (count [1 2 3])
    # => 3

    (count '(:a :b))
    # => 2

    (count {:name \"Alice\" :age 30})
    # => 2

    (count #{1 2 3 4})
    # => 4

    (count [])
    # => 0

    (count nil)
    # => 0

  See also: empty?, seq"
  [coll]
  (if (php/instanceof coll Countable)
    (php/-> coll (count))
    (if (php/is_array coll)
      (php/count coll)
      (if (php/is_string coll)
        (throw (php/new InvalidArgumentException "strings are not supported. Consider using native PHP functions like `php/strlen` or `php/mb_strlen`."))
        (if (php/=== coll nil)
          0
          (throw (php/new InvalidArgumentException (str "object is not countable: " coll))))))))

# ------------------
# Control structures
# ------------------

(defmacro if-not
  "Evaluates then if test is false, else otherwise.

  Example:
    (if-not (< 5 3) \"not less\" \"less\")
    # => \"not less\""
  [test then & [else]]
  `(if ,test ,else ,then))

(defmacro when
  "Evaluates body if test is true, otherwise returns nil.

  Example:
    (when (> 10 5) \"greater\")
    # => \"greater\""
  [test & body]
  `(if ,test (do ,@body)))

(defmacro when-not
  "Evaluates body if test is false, otherwise returns nil.

  Example:
    (when-not (empty? [1 2 3]) \"has items\")
    # => \"has items\""
  [test & body]
  `(if ,test nil (do ,@body)))

(defmacro cond
  "Evaluates test/expression pairs, returning the first matching expression.

  Example:
    (cond (< x 0) \"negative\" (> x 0) \"positive\" \"zero\")
    # => \"negative\", \"positive\", or \"zero\" depending on x"
  [& pairs]
  (let [cnt (count pairs)]
    (if (php/=== cnt 0)
      nil
      (if (php/=== cnt 1)
        (first pairs)
        (list 'if
              (first pairs)
              (second pairs)
              (cons 'cond (apply list (next (next pairs)))))))))

(defmacro case
  "Evaluates expression and matches it against constant test values, returning the associated result.

  Example:
    (case x
      1 \"one\"
      2 \"two\"
      \"other\")
    # => \"one\" (when x is 1)"
  [e & pairs]
  (if (next pairs)
    (let [v (gensym)]
      `(let [,v ,e]
         (if (equals1 ,v ',(first pairs))
           ,(first (next pairs))
           (case ,v ,@(next (next pairs))))))
    (first pairs)))

# -----------------
# Boolean operation
# -----------------

(defmacro or
  "Evaluates expressions left to right, returning the first truthy value or the last value.

  Example:
    (or false nil 42 100)
    # => 42"
  [& args]
  (case (count args)
    0 nil
    1 (first args)
    (let [v (gensym)]
      `(let [,v ,(first args)]
         (if ,v ,v (or ,@(next args)))))))

(defmacro and
  "Evaluates expressions left to right, returning the first falsy value or the last value.

  Example:
    (and true 1 \"hello\")
    # => \"hello\""
  [& args]
  (case (count args)
    0 'true
    1 (first args)
    (let [v (gensym)]
      `(let [,v ,(first args)]
         (if ,v (and ,@(next args)) ,v)))))

(defn- id2 [a b]
  (if (php/instanceof a IdenticalInterface)
    (php/-> a (identical b))
    (php/=== a b)))

(defn id
  "Checks if all values are identical. Same as `a === b` in PHP."
  [a & more]
  (case (count more)
    0 true
    1 (id2 a (first more))
    (if (id2 a (first more))
      (recur (first more) (next more))
      false)))

(defn =
  "Checks if all values are equal (value equality, not identity).

  Example:
    (= [1 2 3] [1 2 3])
    # => true"
  [a & more]
  (case (count more)
    0 true
    1 (equals1 a (first more))
    (if (equals1 a (first more))
      (recur (first more) (next more))
      false)))

(defn not
  "Returns true if value is falsy (nil or false), false otherwise.

  Example:
    (not nil)
    # => true"
  [x]
  (if x false true))

(defn not=
  "Checks if all values are unequal. Same as `a != b` in PHP."
  [a & more]
  (case (count more)
    0 false
    1 (not (= a (first more)))
    (not (apply = a more))))

(defn <
  "Checks if each argument is strictly less than the following argument.

  Example:
    (< 1 2 3 4)
    # => true"
  {:inline (fn [a b] `(php/< ,a ,b))
   :inline-arity (fn [n] (php/=== n 2))}
  [a & more]
  (case (count more)
    0 true
    1 (php/< a (first more))
    (if (php/< a (first more))
      (recur (first more) (next more))
      false)))

(defn <=
  "Checks if each argument is less than or equal to the following argument. Returns a boolean."
  {:inline (fn [a b] `(php/<= ,a ,b))
   :inline-arity (fn [n] (php/=== n 2))}
  [a & more]
  (case (count more)
    0 true
    1 (php/<= a (first more))
    (if (php/<= a (first more))
      (recur (first more) (next more))
      false)))

(defn >
  "Checks if each argument is strictly greater than the following argument.

  Example:
    (> 4 3 2 1)
    # => true"
  {:inline (fn [a b] `(php/> ,a ,b))
   :inline-arity (fn [n] (php/=== n 2))}
  [a & more]
  (case (count more)
    0 true
    1 (php/> a (first more))
    (if (php/> a (first more))
      (recur (first more) (next more))
      false)))

(defn >=
  "Checks if each argument is greater than or equal to the following argument. Returns a boolean."
  {:inline (fn [a b] `(php/>= ,a ,b))
   :inline-arity (fn [n] (php/=== n 2))}
  [a & more]
  (case (count more)
    0 true
    1 (php/>= a (first more))
    (if (php/>= a (first more))
      (recur (first more) (next more))
      false)))

(defn <=>
  "Alias for the spaceship PHP operator in ascending order. Returns an int."
  {:inline (fn [a b] `(php/<=> ,a ,b))}
  [a b]
  (php/<=> a b))

(defn >=<
  "Alias for the spaceship PHP operator in descending order. Returns an int."
  {:inline (fn [a b] `(php/<=> ,b ,a))}
  [a b]
  (php/<=> b a))

(defn all?
  "Returns true if predicate is true for every element in collection, false otherwise.

  Example:
    (all? even? [2 4 6 8])
    # => true"
  [pred coll]
  (cond
    (php/=== (count coll) 0) true
    (pred (first coll))     (recur pred (next coll))
    false))

(defn every?
  "Alias for `all?`."
  [pred coll]
  (all? pred coll))

(defn not-every?
  "Returns false if `(pred x)` is logical true for every `x` in collection `coll`
   or if `coll` is empty. Otherwise returns true."
  [pred coll]
  (not (every? pred coll)))

(declare empty?)
(declare truthy?)
(declare name)

(defn some?
  "Returns true if predicate is true for at least one element in collection, false otherwise.

  Example:
    (some? even? [1 3 5 6 7])
    # => true"
  [pred coll]
  (if (empty? coll)
    false
    (if (truthy? (pred (first coll)))
      true
      (recur pred (next coll)))))

(defn not-any?
  "Returns true if `(pred x)` is logical false for every `x` in `coll`
   or if `coll` is empty. Otherwise returns false."
  [pred coll]
  (not (some? pred coll)))

(defn some
  "Returns the first truthy value of applying predicate to elements, or nil if none found.

  Example:
    (some #(when (> % 10) %) [5 15 8])
    # => 15"
  [pred coll]
  (if (empty? coll)
    nil
    (let [res (pred (first coll))]
      (if (truthy? res)
        res
        (recur pred (next coll))))))

(defn true?
  "Checks if value is exactly true (not just truthy).

  Example:
    (true? 1)
    # => false"
  [x]
  (id x true))

(defn truthy?
  "Checks if `x` is truthy. Same as `x == true` in PHP."
  [x]
  (php/:: Truthy (isTruthy x)))

(defn false?
  "Checks if value is exactly false (not just falsy).

  Example:
    (false? nil)
    # => false"
  [x]
  (id x false))

(defn nil?
  "Returns true if value is nil, false otherwise.

  Example:
    (nil? (get {:a 1} :b))
    # => true"
  [x]
  (id x nil))

(defn str-contains?
  "Returns true if str contains s."
  {:deprecated "Use phel\\str\\contains?"}
  [str s]
  (php/str_contains str s))

(defn contains?
  "Returns true if key is present in collection (checks keys/indices, not values).

  Example:
    (contains? [10 20 30] 1)
    # => true"
  [coll key]
  (cond
    (php/instanceof coll ContainsInterface) (php/-> coll (contains key))
    (php/is_array coll) (php/array_key_exists key coll)
    (throw (php/new InvalidArgumentException (php/. "cannot call 'contains?' on " (php/get_class coll))))))

(defn compare
  "Wrapper for PHP's spaceship operator (`php/<=>`).
  Returns an integer less than, equal to, or greater than zero
  when `x` is less than, equal to, or greater than `y`, respectively."
  {:inline (fn [x y] `(php/<=> ,x ,y))}
  [x y]
  (php/<=> x y))

# --------------
# Type operation
# --------------

(defn type
  "Returns the type of `x`. The following types can be returned:

* `:vector`
* `:list`
* `:struct`
* `:hash-map`
* `:set`
* `:keyword`
* `:symbol`
* `:var`
* `:int`
* `:float`
* `:string`
* `:nil`
* `:boolean`
* `:function`
* `:php/array`
* `:php/resource`
* `:php/object`
* `:unknown`"
  [x]
  (cond
    (php/instanceof x PersistentVectorInterface)  :vector
    (php/instanceof x PersistentListInterface)    :list
    (php/instanceof x AbstractPersistentStruct)   :struct
    (php/instanceof x PersistentMapInterface)     :hash-map
    (php/instanceof x PersistentHashSetInterface) :set
    (php/instanceof x Keyword)                    :keyword
    (php/instanceof x Symbol)                     :symbol
    (php/instanceof x Variable)                   :var
    (php/is_int x)                                :int
    (php/is_float x)                              :float
    (php/is_string x)                             :string
    (php/is_null x)                               :nil
    (php/is_bool x)                               :boolean
    (php/is_callable x)                           :function
    (php/is_array x)                              :php/array
    (php/is_resource x)                           :php/resource
    (php/is_object x)                             :php/object
    :unknown))

(defn float?
  "Returns true if `x` is float point number, false otherwise."
  [x]
  (= (type x) :float))

(defn int?
  "Returns true if `x` is an integer number, false otherwise."
  [x]
  (= (type x) :int))

(defn number?
  "Returns true if `x` is a number, false otherwise."
  [x]
  (or (= (type x) :int) (= (type x) :float)))

(defn string?
  "Returns true if `x` is a string, false otherwise."
  [x]
  (= (type x) :string))

(defn keyword?
  "Returns true if `x` is a keyword, false otherwise."
  [x]
  (= (type x) :keyword))

(defn symbol?
  "Returns true if `x` is a symbol, false otherwise."
  [x]
  (= (type x) :symbol))

(defn function?
  "Returns true if `x` is a function, false otherwise."
  [x]
  (= (type x) :function))

(defn struct?
  "Returns true if `x` is a struct, false otherwise."
  [x]
  (= (type x) :struct))

(defn hash-map?
  "Returns true if `x` is a hash map, false otherwise."
  [x]
  (= (type x) :hash-map))

(defn vector?
  "Returns true if `x` is a vector, false otherwise."
  [x]
  (= (type x) :vector))

(defn list?
  "Returns true if `x` is a list, false otherwise."
  [x]
  (= (type x) :list))

(defn boolean?
  "Returns true if `x` is a boolean, false otherwise."
  [x]
  (= (type x) :boolean))

(defn php-array?
  "Returns true if `x` is a PHP Array, false otherwise."
  [x]
  (= (type x) :php/array))

(defn php-resource?
  "Returns true if `x` is a PHP resource, false otherwise."
  [x]
  (= (type x) :php/resource))

(defn php-object?
  "Returns true if `x` is a PHP object, false otherwise."
  [x]
  (= (type x) :php/object))

(defn empty?
  "Returns true if x would be 0, \"\" or empty collection, false otherwise."
  [x]
  (if (php/is_numeric x)
    (= 0 x)
    (if (php/is_string x)
      (true? (php/empty x))
      (= 0 (count x)))))

(defn not-empty
  "Returns `coll` if it contains elements, otherwise nil."
  [coll]
  (if (empty? coll)
    nil
    coll))

(defn- indexed-php-array?
  [x]
  (and
   (= (type x) :php/array)
   (or
    (php/empty x)
    (php/=== (php/array_keys x) (php/range 0 (php/- (php/count x) 1))))))

(defn indexed?
  "Returns true if `x` is indexed sequence, false otherwise."
  [x]
  (let [t (type x)]
    (or
     (= t :list)
     (= t :vector)
     (indexed-php-array? x))))

(defn associative?
  "Returns true if `x` is an associative data structure, false otherwise."
  [x]
  (let [t (type x)]
    (or
     (= t :hash-map)
     (= t :struct)
     (and (= t :php/array) (not (indexed-php-array? x))))))

(defn set?
  "Returns true if `x` is a set, false otherwise."
  [x]
  (= (type x) :set))

# ------------------
# Sequence operation
# ------------------

(defn peek
  "Returns the last element of a sequence."
  [coll]
  (php/aget coll (php/- (count coll) 1)))


(defn push
  "Inserts `x` at the end of the sequence `coll`.

  Deprecated: Use `conj` instead for Clojure compatibility."
  {:deprecated "0.25.0"
   :superseded-by "conj"}
  [coll x]
  (conj coll x))

(defn pop
  "Removes the last element of the array `coll`. If the array is empty returns nil."
  [^:reference coll]
  (cond
    (php-array? coll) (php/array_pop coll)
    (php/instanceof coll PopInterface) (php/-> coll (pop))
    (throw (php/new InvalidArgumentException "Cannot pop"))))

(defn remove
  "Removes up to `n` element from array `coll` starting at index `offset`."
  [^:reference coll offset & [n]]
  (cond
    (php-array? coll) (if n (php/array_splice coll offset n) (php/array_splice coll offset))
    (php/instanceof coll RemoveInterface) (php/-> coll (remove offset n))
    (throw (php/new InvalidArgumentException "Cannot remove"))))

(defn get
  "Gets the value at key in a collection. Returns default if not found.

  Example:
    (get {:a 1} :a)
    # => 1"
  [ds k & [opt]]
  (cond
    (or (set? ds)
        (php/instanceof ds PersistentHashSetInterface)
        (php/instanceof ds TransientHashSetInterface))
    (if (php/-> ds (contains k))
      k
      opt)

    (php/instanceof ds LazySeqInterface)
    (loop [i k
           s ds]
      (if (or (nil? s) (php/< i 0))
        opt
        (if (php/=== i 0)
          (let [res (first s)]
            (if (nil? res)
              opt
              res))
          (recur (php/- i 1) (next s)))))

    :else
    (let [res (php/aget ds k)]
      (if (nil? res)
        opt
        res))))

(defn assoc
  "Associates a value with a key in a collection.

  Example:
    (assoc {:a 1} :b 2)
    # => {:a 1 :b 2}"
  [ds key value]
  (cond
    (php-array? ds)
    (throw (php/new InvalidArgumentException "Cannot call assoc on pure PHP arrays. Use (php/aset ds key value)"))

    (or (struct? ds) (hash-map? ds) (php/instanceof ds TransientMapInterface))
    (php/-> ds (put key value))

    (or (vector? ds) (php/instanceof ds TransientVectorInterface))
    (php/-> ds (update key value))

    (do
      (php/aset ds key value)
      ds)))

(defn put
  "Puts `value` mapped to `key` on the datastructure `ds`. Returns `ds`.

  Deprecated: Use `assoc` instead."
  {:deprecated "0.25.0"
   :superseded-by "assoc"}
  [ds key value]
  (assoc ds key value))

(defn dissoc
  "Dissociates `key` from the datastructure `ds`. Returns `ds` without `key`."
  [ds key]
  (cond
    (php-array? ds)
    (throw (php/new InvalidArgumentException "Cannot call dissoc on pure PHP arrays. Use (php/aunset ds key)"))

    (or (hash-map? ds) (php/instanceof ds TransientMapInterface))
    (php/-> ds (remove key))

    (or (set? ds) (php/instanceof ds TransientHashSetInterface))
    (php/-> ds (remove key))

    (let [x ds]
      (php/aunset x key)
      x)))

(defn unset
  "Returns `ds` without `key`.

  Deprecated: Use `dissoc` instead."
  {:deprecated "0.25.0"
   :superseded-by "dissoc"}
  [ds key]
  (dissoc ds key))

# --------
# Variable
# --------

(defn var
  "Creates a new variable with the given value."
  [value]
  (php/:: Phel (variable value)))

(defn var?
  "Checks if the given value is a variable."
  [x]
  (php/instanceof x Variable))

(defn set!
  "Sets a new value to the given variable."
  [variable value]
  (php/-> variable (set value)))

(defn deref
  "Return the value inside the variable."
  [variable]
  (php/-> variable (deref)))

(defn swap!
  "Swaps the value of the variable to `(apply f current-value args)`. Returns the values that are swapped in."
  [variable f & args]
  (let [current (deref variable)
        next (apply f current args)]
    (set! variable next)
    next))

# --------
# For loop
# --------

(defn- lazy-seq-from-generator
  "Wraps a PHP Generator in a ChunkedSeq for efficient lazy evaluation.
  ChunkedSeq realizes elements in batches for better performance."
  [generator]
  (php/:: ChunkedSeq (fromGenerator
                      (php/new Hasher)
                      (php/new Equalizer)
                      generator)))

(defn range
  "Creates a lazy sequence of numbers from start to end (exclusive).

  Example:
    (range 5)
    # => (0 1 2 3 4)"
  [a & rest]
  (case (count rest)
    0 (lazy-seq-from-generator (php/:: Generators (range 0 a 1)))
    1 (lazy-seq-from-generator (php/:: Generators (range a (get rest 0) 1)))
    2 (lazy-seq-from-generator (php/:: Generators (range a (get rest 0) (get rest 1))))
    (throw (php/new InvalidArgumentException "Range function expects one, two or three arguments"))))

(def- for-options (set :reduce))

(defn- for-builder-options [head i initial-options]
  (if (<= (count head) i)
    initial-options
    (let [binding (php/aget head i)
          verb (php/aget head (php/+ i 1))]
      (if (keyword? binding)
        (case binding
          :reduce (for-builder-options head (php/+ i 2) (assoc initial-options :reduce verb))
          (for-builder-options head (php/+ i 2) initial-options))
        (for-builder-options head (php/+ i 3) initial-options)))))

(defn- for-builder [body head i]
  (if (<= (count head) i)
    # No more heads, return the body
    body

    # Handle heads
    (let [binding (php/aget head i)
          verb (php/aget head (php/+ i 1))]
      (cond
        # Case 1: Options
        (and (keyword? binding) (contains? for-options binding))
        (for-builder body head (php/+ i 2))

        # Case 2: Modifiers
        (keyword? binding)
        (let [rest (for-builder body head (php/+ i 2))]
          (case binding
            :while  `(if ,verb ,rest php/break)
            :let    `(let ,verb ,rest)
            :when   `(when ,verb ,rest)
            (throw (php/new InvalidArgumentException (str "This modifier is not supported in for loop: " verb)))))

        # Case 3: Verbs
        (let [object (php/aget head (php/+ i 2))
              rest (for-builder body head (php/+ i 3))
              value-sym (gensym)]
          (case verb
            :range  `(foreach [,binding (apply range ,object)] ,rest)
            :in     `(foreach [,value-sym ,object] (let [,binding ,value-sym] ,rest))
            :keys   (let [key-sym (gensym)]
                      `(foreach [,key-sym ,value-sym ,object] (let [,binding ,key-sym] ,rest)))
            :pairs  (let [key-sym (gensym)]
                      `(foreach [,key-sym ,value-sym ,object]
                         (let [,binding [,key-sym ,value-sym]] ,rest)))
            (throw (php/new InvalidArgumentException (str "This verb is not supported in for loop " verb)))))))))

(defmacro for
  "List comprehension. The head of the loop is a vector that contains a
  sequence of bindings modifiers and options. A binding is a sequence of three
  values `binding :verb expr`. Where `binding` is a binding as
  in let and `:verb` is one of the following keywords:

  * `:range` loop over a range by using the range function.
  * `:in` loops over all values of a collection.
  * `:keys` loops over all keys/indexes of a collection.
  * `:pairs` loops over all key-value pairs of a collection.

  After each loop binding, additional modifiers can be applied. Modifiers
  have the form `:modifier argument`. The following modifiers are supported:

  * `:while` breaks the loop if the expression is falsy.
  * `:let` defines additional bindings.
  * `:when` only evaluates the loop body if the condition is true.

  Finally, additional options can be set:

  * `:reduce [accumulator initial-value]` Instead of returning a list,
     it reduces the values into `accumulator`. Initially `accumulator`
     is bound to `initial-value`."
  [head & body]
  (let [res-sym (gensym "res__")
        acc-sym (gensym "acc__")
        options (for-builder-options head 0 {})
        swap-body (if (:reduce options)
                    (let [[sym _] (:reduce options)]
                      `(swap! ,res-sym (fn [,sym] (do ,@body))))
                    `(swap! ,res-sym (fn [,acc-sym] (conj ,acc-sym (do ,@body)))))
        init (if (:reduce options)
               (second (:reduce options))
               [])
        loop-body (for-builder swap-body head 0)]
    `(let [,res-sym (var ,init)]
       ,loop-body
       (deref ,res-sym))))

(defmacro dofor
  "Repeatedly executes body for side effects with bindings and modifiers as
  provided by for. Returns nil."
  [head & body]
  (for-builder `(do ,@body) head 0))

(defmacro doseq
  "Alias for `dofor`."
  [seq-exprs & body]
  `(dofor ,seq-exprs ,@body))

# ------------------
# Sequence functions
# ------------------

(defn map
  "Returns a lazy sequence of the result of applying `f` to all of the first items in each coll,
   followed by applying `f` to all the second items in each coll until anyone of the colls is exhausted.

  When given a single collection, applies the function to each element.
  With multiple collections, applies the function to corresponding elements from each collection,
  stopping when the shortest collection is exhausted.

  Examples:
    (map inc [1 2 3])
    # => (2 3 4)

    (map #(* % 2) [1 2 3 4])
    # => (2 4 6 8)

    (map + [1 2 3] [10 20 30])
    # => (11 22 33)

    (map str [\"a\" \"b\" \"c\"] [1 2 3])
    # => (\"a1\" \"b2\" \"c3\")

    (map list [1 2] [3 4] [5 6])
    # => ((1 3 5) (2 4 6))

  See also: filter, reduce, map-indexed, mapcat"
  [f & colls]
  (case (count colls)
    0 (throw (php/new InvalidArgumentException "expected at least one indexed collection in map"))
    1 (let [coll (first colls)]
        (if (empty? coll)
          []
          (with-meta coll (lazy-seq-from-generator (php/:: Generators (map f coll))))))
    (let [result (lazy-seq-from-generator
                  (php/call_user_func_array
                   (php/array "\\Phel\\Lang\\Generators" "mapMulti")
                   (php/array_merge (php/array f) (apply php/array colls))))]
      (if (php/=== nil result)
        []
        (with-meta (first colls) result)))))

(defn map-indexed
  "Applies function to each element with its index, returning a lazy sequence.

  Example:
    (map-indexed (fn [i x] [i x]) [\"a\" \"b\" \"c\"])
    # => ([0 \"a\"] [1 \"b\"] [2 \"c\"])"
  [f coll]
  (let [result (for [[k v] :pairs coll] (f k v))]
    (with-meta coll result)))

(defn mapcat
  "Applies function to collections and concatenates the results.

  Example:
    (mapcat reverse [[1 2] [3 4]])
    # => (2 1 4 3)"
  [f & colls]
  (let [result (apply concat [] (apply map f colls))]
    (if (empty? colls)
      result
      (with-meta (first colls) result))))

(defn reduce
  "Reduces collection to a single value by repeatedly applying function to accumulator and elements.

  Example:
    (reduce + [1 2 3 4])
    # => 10"
  [f & args]
  (case (count args)
    1 (let [coll (first args)]
        (if (empty? coll)
          (f)
          (reduce f (first coll) (next coll))))
    2 (let [val (first args)
            coll (second args)]
        (for [x :in coll :reduce [acc val]]
          (f acc x)))
    (throw (php/new InvalidArgumentException "expected 2 or 3 arguments in reduce"))))

(defn into
  "Returns `to` with all elements of `from` added.

   When `from` is associative, it is treated as a sequence of key-value pairs.
   Supports persistent and transient collections."
  [to & rest]
  (case (count rest)
    0 to
    1 (let [from (first rest)]
        (if (php/=== nil from)
          to
          (let [entries (if (associative? from)
                          (for [entry :pairs from] entry)
                          from)
                assoc-entry (fn [acc entry]
                              (if (indexed? entry)
                                (if (php/!= (count entry) 2)
                                  (throw (php/new InvalidArgumentException
                                                  "into expects a collection of [key value] pairs"))
                                  (let [k (first entry)
                                        v (second entry)]
                                    (if (php-array? acc)
                                      (do
                                        (php/aset acc k v)
                                        acc)
                                      (assoc acc k v))))
                                (throw (php/new InvalidArgumentException
                                                "into expects a collection of [key value] pairs"))))
                map-target? (or (associative? to) (php/instanceof to TransientMapInterface))]
            (cond
              map-target?
              (for [entry :in entries
                    :reduce [acc to]]
                (assoc-entry acc entry))

              (php/instanceof to TransientVectorInterface)
              (for [value :in entries
                    :reduce [acc to]]
                (conj acc value))

              (php/instanceof to TransientHashSetInterface)
              (for [value :in entries
                    :reduce [acc to]]
                (conj acc value))

              (php/instanceof to PushInterface)
              (for [value :in entries
                    :reduce [acc to]]
                (conj acc value))

              (php/instanceof to ConcatInterface)
              (php/-> to (concat (apply php/array entries)))

              (php/is_array to)
              (concat to entries)

              (throw (php/new InvalidArgumentException
                              (php/. "Cannot convert into type " (type to))))))))
    (throw (php/new InvalidArgumentException "into expects one or two arguments"))))

(defn- conj-map-entry
  [coll entry]
  (let [assign (fn [acc key value]
                 (if (php-array? acc)
                   (do
                     (php/aset acc key value)
                     acc)
                   (php/-> acc (put key value))))]
    (cond
      (indexed? entry)
      (if (php/!= (count entry) 2)
        (throw (php/new InvalidArgumentException
                        "conj on a map expects entries of length 2"))
        (assign coll (first entry) (second entry)))

      (associative? entry)
      (for [[key value] :pairs entry
            :reduce [acc coll]]
        (assign acc key value))

      :else
      (throw (php/new InvalidArgumentException
                      "conj on a map expects a [key value] pair or an associative collection")))))

(defn- conj-single
  [coll value]
  (cond
    (php/=== coll nil) (list value)
    (list? coll) (cons value coll)
    (php-array? coll) (do (php/apush coll value) coll)
    (or (vector? coll) (php/instanceof coll TransientVectorInterface)) (php/-> coll (append value))
    (or (set? coll) (php/instanceof coll TransientHashSetInterface)) (php/-> coll (add value))
    (or (hash-map? coll)
        (struct? coll)
        (php/instanceof coll TransientMapInterface)) (conj-map-entry coll value)
    (php/instanceof coll PushInterface) (php/-> coll (push value))
    :else
    (throw (php/new InvalidArgumentException
                    (str "Cannot conj on type " (type coll))))))

(defn conj
    "Returns a new collection with values added. Appends to vectors/sets, prepends to lists.

    Examples:
      (conj [1 2] 3)
      # => [1 2 3]

      (conj {:a 1} [:b 2])
      # => {:a 1 :b 2}"
  ([] [])
  ([coll] coll)
  ([coll value]
   (conj-single coll value))
  ([coll value & more]
   (reduce conj-single (conj-single coll value) more)))

(defn slice
  "Extract a slice of `coll`."
  [coll & [offset & [length]]]
  (cond
    (php-array? coll) (php/array_slice coll offset length)
    (php/instanceof coll SliceInterface) (php/-> coll (slice offset length))
    (throw (php/new InvalidArgumentException "Cannot slice"))))

(defn get-in
  "Access a value in a nested data structure. Looks into the data structure via a sequence of keys."
  [ds ks & [opt]]
  (let [res (reduce get ds ks)]
    (if (nil? res) opt res)))

(defn assoc-in
  "Associates a value in a nested data structure."
  [ds [k & ks] v]
  (if-not (nil? ks)
    (assoc ds k (assoc-in (get ds k {}) ks v))
    (assoc ds k v)))

(defn put-in
  "Puts a value into a nested data structure.

  Deprecated: Use `assoc-in` instead."
  {:deprecated "0.25.0"
   :superseded-by "assoc-in"}
  [ds ks v]
  (assoc-in ds ks v))

(defn update
  "Updates a value in a datastructure by applying `f` to the current element and replacing it with the result of `f`."
  [ds k f & args]
  (assoc ds k (apply f (get ds k) args)))

(defn update-in
  "Updates a value into a nested data structure."
  [ds [k & ks] f & args]
  (if ks
    (assoc ds k (apply update-in (get ds k {}) ks f args))
    (let [current (get ds k)] # Extract value first for possible call-by-reference
      (assoc ds k (apply f current args)))))

(defn dissoc-in
  "Dissociates a value from a nested data structure."
  [ds [k & ks]]
  (if ks
    (let [sub (get ds k)]
      (if (nil? sub)
        ds
        (assoc ds k (dissoc-in sub ks))))
    (dissoc ds k)))

(defn unset-in
  "Removes a value from a nested data structure.

  Deprecated: Use `dissoc-in` instead."
  {:deprecated "0.25.0"
   :superseded-by "dissoc-in"}
  [ds ks]
  (dissoc-in ds ks))

(defn drop
  "Drops the first `n` elements of `coll`. Returns a lazy sequence."
  [n coll]
  (if (nil? coll)
    []
    (let [n (if (php/< n 0) 0 n)]
      (if (php/=== n 0)
        coll
        (let [result (lazy-seq-from-generator (php/:: Generators (drop n coll)))]
          (with-meta coll (or result [])))))))

(defn drop-last
  "Drops the last `n` elements of `coll`."
  [n coll]
  (let [n (if (php/< n 0) 0 n)
        end (php/- (count coll) n)]
    (slice coll 0 (php/max 0 end))))

(defn last
  "Returns the last element of `coll` or nil if `coll` is empty or nil."
  [coll]
  (if (or (php/=== coll nil) (empty? coll))
    nil
    (peek coll)))

(defn butlast
  "Returns all but the last item in `coll`."
  [coll]
  (drop-last 1 coll))

(defn drop-while
  "Drops all elements at the front of `coll` where `(pred x)` is true. Returns a lazy sequence."
  [pred coll]
  (if (nil? coll)
    []
    (let [result (lazy-seq-from-generator (php/:: Generators (dropWhile pred coll)))]
      (with-meta coll (or result [])))))

(defn take
  "Takes the first `n` elements of `coll`.

  Note: Metadata preservation works with inline calls but may be lost when binding
  to variables. Use inline calls or force realization with doall if metadata needed.
  See local/investigate-metadata-binding-issue.md for details."
  [n coll]
  (let [n (if (php/< n 0) 0 n)]
    (if (php/=== n 0)
      []
      (let [result (lazy-seq-from-generator (php/:: Generators (take n coll)))]
        (if (nil? result)
          []
          (with-meta coll result))))))

(defn take-last
  "Takes the last `n` elements of `coll`."
  [n coll]
  (if (php/<= n 0) [] (slice coll (php/* -1 n))))

(defn take-while
  "Takes all elements at the front of `coll` where `(pred x)` is true. Returns a lazy sequence."
  [pred coll]
  (if (nil? coll)
    []
    (let [result (lazy-seq-from-generator (php/:: Generators (takeWhile pred coll)))]
      (with-meta coll (or result [])))))

(defn take-nth
  "Returns every nth item in `coll`. Returns a lazy sequence."
  [n coll]
  (when (< n 1)
    (throw (php/new InvalidArgumentException "First argument of 'take-nth must be greater than 0")))
  (if (nil? coll)
    []
    (let [result (lazy-seq-from-generator (php/:: Generators (takeNth n coll)))]
      (with-meta coll (or result [])))))

(defn filter
  "Returns a lazy sequence of elements where predicate returns true.

  Example:
    (filter even? [1 2 3 4 5 6])
    # => (2 4 6)"
  [pred coll]
  (let [result (lazy-seq-from-generator (php/:: Generators (filter pred coll)))]
    (if (nil? result)
      []
      (with-meta coll result))))

(defn keep
  "Returns a lazy sequence of non-nil results of applying function to elements.

  Example:
    (keep #(when (even? %) (* % %)) [1 2 3 4 5])
    # => (4 16)"
  [pred coll]
  (if (nil? coll)
    []
    (let [result (lazy-seq-from-generator (php/:: Generators (keep pred coll)))]
      (with-meta coll (or result [])))))

(defn keep-indexed
  "Returns a lazy sequence of non-nil results of `(pred i x)`."
  [pred coll]
  (if (nil? coll)
    []
    (let [result (lazy-seq-from-generator (php/:: Generators (keepIndexed pred coll)))]
      (with-meta coll (or result [])))))

(defn find
  "Returns the first item in `coll` where `(pred item)` evaluates to true."
  [pred coll]
  (loop [s coll]
    (if (empty? s)
      nil
      (if (pred (first s))
        (first s)
        (recur (next s))))))

(defn find-index
  "Returns the index of the first item in `coll` where `(pred index item)` evaluates to true."
  [pred coll]
  (loop [s coll
         i 0]
    (if (empty? s)
      nil
      (if (pred (first s))
        i
        (recur (next s) (php/+ i 1))))))

(defn distinct
  "Returns a lazy sequence with duplicated values removed in `coll`."
  [coll]
  (if (nil? coll)
    []
    (let [result (lazy-seq-from-generator (php/:: Generators (distinct coll)))]
      (with-meta coll (or result [])))))


(defn reverse
  "Reverses the order of the elements in the given sequence."
  [coll]
  (let [result
        (for [i :range [(php/- (count coll) 1) -1 -1]
              :reduce [ret []]]
          (conj ret (get coll i)))]
    (with-meta coll result)))

(defn interleave
  "Returns a vector with the first items of each col, then the second items, etc."
  [& colls]
  (if (empty? colls)
    []
    (let [first-coll (first colls)
          size (count first-coll)
          result (loop [i 0
                        res []]
                   (let [nths (apply vector (map |(get $ i) colls))]
                     (if (<= size i)
                       res
                       (recur (php/+ i 1) (concat res nths)))))]
      (with-meta first-coll result))))

(defn interpose
  "Returns a vector of elements separated by `sep`."
  [sep coll]
  (let [result
        (persistent
         (for [[k v] :pairs coll
               :reduce [res (transient [])]]
           (when (> k 0)
             (conj res sep v))
           (conj res v)))]
    (with-meta coll result)))

(defn frequencies
  "Returns a map from distinct items in `coll` to the number of times they appear."
  [coll]
  (let [result (for [x :in coll
                     :reduce [res {}]]
                 (let [n (get res x 0)]
                   (assoc res x (php/+ 1 n))))]
    (with-meta coll result)))

(defn keys
  "Returns a sequence of all keys in a map.

  Example:
    (keys {:a 1 :b 2})
    # => (:a :b)"
  [coll]
  (let [result (for [k :keys coll] k)]
    (with-meta coll result)))

(defn values
  "Returns a sequence of all values in a map.

  Example:
    (values {:a 1 :b 2})
    # => (1 2)"
  [coll]
  (let [result (for [x :in coll] x)]
    (with-meta coll result)))

(defn pairs
  "Gets the pairs of an associative data structure."
  [coll]
  (let [result (for [p :pairs coll] p)]
    (with-meta coll result)))

(defn kvs
  "Returns a vector of key-value pairs like `[k1 v1 k2 v2 k3 v3 ...]`."
  [coll]
  (let [result
        (persistent
         (for [[k v] :pairs coll
               :reduce [res (transient [])]]
           (conj res k)
           (conj res v)))]
    (with-meta coll result)))

(defn to-php-array
  "Create a PHP Array from a sequential data structure."
  [coll]
  (apply php/array coll))

(defn php-array-to-map
  "Converts a PHP Array to a map."
  [arr]
  (let [res (transient {})]
    (foreach [k v arr]
      (assoc res k v))
    (persistent res)))


(defn phel->php
  "Recursively converts a Phel data structure to a PHP array."
  [x]
  (cond
    (php-array? x)
    (let [arr (php/array)]
      (foreach [k v x]
        (php/aset arr k (phel->php v)))
      arr)

    (indexed? x)
    (let [arr (php/array)]
      (foreach [v x]
        (php/apush arr (phel->php v)))
      arr)

    (associative? x)
    (let [arr (php/array)]
      (foreach [k v x]
        (php/aset arr (name k) (phel->php v)))
      arr)

    (set? x)
    (let [arr (php/array)]
      (foreach [v x]
        (php/apush arr (phel->php v)))
      arr)

    true x))

(defn php->phel
  "Recursively converts a PHP array to Phel data structures."
  [x]
  (cond
    (indexed-php-array? x)
    (let [res (transient [])]
      (foreach [v x]
        (conj res (php->phel v)))
      (persistent res))

    (php-array? x)
    (let [res (transient {})]
      (foreach [k v x]
        (assoc res k (php->phel v)))
      (persistent res))

    true x))

(defn contains-value?
  "Returns true if the value is present in the given collection, otherwise returns false."
  [coll val]
  (some? |(= $ val) (values coll)))

(defn sort
  "Returns a sorted vector. If no comparator is supplied compare is used."
  [coll & [comp]]
  (let [php-array (to-php-array coll)]
    (php/usort php-array (or comp compare))
    (with-meta coll (apply vector php-array))))

(defn sort-by
  "Returns a sorted vector where the sort order is determined by comparing
  `(keyfn item)`. If no comparator is supplied compare is used."
  [keyfn coll & [comp]]
  (let [php-array (to-php-array coll)
        cmp (or comp compare)]
    (php/usort php-array |(cmp (keyfn $1) (keyfn $2)))
    (with-meta coll (apply vector php-array))))

(defn shuffle
  "Returns a random permutation of coll."
  [coll]
  (let [php-array (to-php-array coll)]
    (php/shuffle php-array)
    (with-meta coll (apply vector php-array))))

(defn repeat
  "Returns a vector of length n where every element is x.
  With one argument returns an infinite lazy sequence of x."
  [a & rest]
  (case (count rest)
    0 (lazy-seq-from-generator (php/:: Generators (repeat a)))
    1 (for [i :range [a]] (get rest 0))
    (throw (php/new InvalidArgumentException "repeat expects one or two arguments"))))

(defn repeatedly
  "Returns a vector of length n with values produced by repeatedly calling f.
  With one argument returns an infinite lazy sequence of calls to f."
  [a & rest]
  (case (count rest)
    0 (lazy-seq-from-generator (php/:: Generators (repeatedly a)))
    1 (let [n a
            f (get rest 0)]
        (for [i :range [n]] (f)))
    (throw (php/new InvalidArgumentException "repeatedly expects one or two arguments"))))

(defmacro lazy-seq
  "Creates a lazy sequence that evaluates the body only when accessed.

  Example:
    (defn my-range [n]
      (when (> n 0)
        (lazy-seq (cons n (my-range (dec n))))))"
  [& body]
  `(php/new \Phel\Lang\Collections\LazySeq\LazySeq
            (php/new \Phel\Lang\Hasher)
            (php/new \Phel\Lang\Equalizer)
            (fn [] ,@body)))

(defmacro lazy-cat
  "Concatenates collections into a lazy sequence (expands to concat).

  Example:
    (lazy-cat [1 2] [3 4])
    # => (1 2 3 4)"
  [& colls]
  (apply list 'concat colls))

(defn iterate
  "Returns an infinite lazy sequence of x, (f x), (f (f x)), and so on."
  [f x]
  (lazy-seq-from-generator (php/:: Generators (iterate f x))))

(defn cycle
  "Returns an infinite lazy sequence that cycles through the elements of collection."
  [coll]
  (if (empty? coll)
    []
    (lazy-seq-from-generator (php/:: Generators (cycle coll)))))

(def concat
  "Concatenates multiple collections into a lazy sequence.

  Example:
    (concat [1 2] [3 4])
    # => (1 2 3 4)"
  (fn [& colls]
    (if (php/=== nil colls)
      '()
      (let [result (lazy-seq-from-generator
                    (php/call_user_func_array
                     (php/array "\\Phel\\Lang\\Generators" "concat")
                     (apply php/array colls)))]
        (if (php/=== nil result)
          '()
          result)))))

(def mapcat
  "Maps a function over a collection and concatenates the results. Returns a lazy sequence.

  Applies `f` to each element of the collection, where `f` should return a collection.
  All resulting collections are concatenated into a single lazy sequence.
  Works with infinite sequences.

  Example: (mapcat reverse [[1 2] [3 4]]) ; => (2 1 4 3)"
  (fn [f coll]
    (if (php/=== nil coll)
      '()
      (let [result (lazy-seq-from-generator
                    (php/:: \Phel\Lang\Generators (mapcat f coll)))]
        (if (php/=== nil result)
          '()
          (with-meta coll result))))))

(def interpose
  "Returns elements separated by a separator. Returns a lazy sequence.

  Inserts `sep` between each element of the collection.
  Works with infinite sequences.

  Example: (interpose 0 [1 2 3]) ; => (1 0 2 0 3)"
  (fn [sep coll]
    (if (php/=== nil coll)
      '()
      (let [result (lazy-seq-from-generator
                    (php/:: \Phel\Lang\Generators (interpose sep coll)))]
        (if (php/=== nil result)
          '()
          (with-meta coll result))))))

(def map-indexed
  "Maps a function over a collection with index. Returns a lazy sequence.

  Applies `f` to each element in `xs`. `f` is a two-argument function where
  the first argument is the index (0-based) and the second is the element itself.
  Works with infinite sequences.

  Example: (map-indexed vector [:a :b :c]) ; => ([0 :a] [1 :b] [2 :c])"
  (fn [f coll]
    (if (php/=== nil coll)
      '()
      (let [result (lazy-seq-from-generator
                    (php/:: \Phel\Lang\Generators (mapIndexed f coll)))]
        (if (php/=== nil result)
          '()
          (with-meta coll result))))))

# Redefine interleave as lazy
(def interleave
  "Interleaves multiple collections. Returns a lazy sequence.

  Returns elements by taking one from each collection in turn.
  Pads with nil when collections have different lengths.
  Works with infinite sequences.

  Example: (interleave [1 2 3] [:a :b :c]) ; => (1 :a 2 :b 3 :c)"
  (fn [& colls]
    (if (php/=== nil colls)
      '()
      (let [result (lazy-seq-from-generator
                    (php/call_user_func_array
                     (php/array "\\Phel\\Lang\\Generators" "interleave")
                     (apply php/array colls)))]
        (if (php/=== nil result)
          '()
          (with-meta (first colls) result))))))

(defn doall
  "Forces realization of a lazy sequence and returns it as a vector.

  Example:
    (doall (map println [1 2 3]))
    # => [nil nil nil]"
  [coll]
  (if (php/instanceof coll LazySeqInterface)
    (let [arr (php/-> coll (toArray))]
      (if (php/empty arr)
        nil
        (apply vector arr)))
    coll))

(defn dorun
  "Forces realization of a lazy sequence for side effects, returns nil.

  Example:
    (dorun (map println [1 2 3]))
    # => nil"
  [coll]
  (if (php/instanceof coll LazySeqInterface)
    (do
      (doseq [x :in coll] x)
      nil)
    nil))

(defn realized?
  "Returns true if a lazy sequence has been realized, false otherwise.

  Example:
    (realized? (take 5 (iterate inc 1)))
    # => false"
  [coll]
  (if (php/instanceof coll LazySeqInterface)
    (php/-> coll (isRealized))
    true))

(defn group-by
  "Returns a map of the elements of coll keyed by the result of
  f on each element."
  [f coll]
  (persistent
   (for [x :in coll
         :let [k (f x)]
         :reduce [res (transient {})]]
     (when-not (get res k)
       (assoc res k []))
     (update-in res [k] push x))))

(defn zipcoll
  "Creates a map from two sequential data structures. Return a new map."
  [a b]
  (apply hash-map (interleave a b)))

(defn zipmap
  "Returns a new map with the keys mapped to the corresponding values. Stops when the shorter of `keys` or `vals` is exhausted."
  [keys vals]
  (loop [ks keys
         vs vals
         res {}]
    (if (or (empty? ks) (empty? vs))
      res
      (recur (next ks) (next vs) (assoc res (first ks) (first vs))))))

(defn merge
  "Merges multiple maps into one new map. If a key appears in more than one
  collection, then later values replace any previous ones."
  [& maps]
  (for [map :in maps
        [k v] :pairs map
        :reduce [res {}]]
    (assoc res k v)))

(defn select-keys
  "Returns a new map including key value pairs from `m` selected with of keys `ks`."
  [m ks]
  (let [result (for [[k v] :pairs m
                     :when (contains-value? ks k)
                     :reduce [acc {}]]
                 (assoc acc k v))]
    (with-meta m result)))

(defn invert
  "Returns a new map where the keys and values are swapped. If map has
  duplicated values, some keys will be ignored."
  [map]
  (for [[k v] :pairs map
        :reduce [res {}]]
    (assoc res v k)))

(defn split-at
  "Returns a vector of `[(take n coll) (drop n coll)]`."
  [n coll]
  [(take n coll) (drop n coll)])

(defn split-with
  "Returns a vector of `[(take-while pred coll) (drop-while pred coll)]`."
  [f coll]
  [(take-while f coll) (drop-while f coll)])

(defn partition-by
  "Returns a lazy sequence of partitions. Applies `f` to each value in `coll`, splitting them each time the return value changes."
  [f coll]
  (cond
    (nil? coll) []
    (and (indexed? coll) (= 0 (count coll))) []
    true (lazy-seq-from-generator (php/:: Generators (partitionBy f coll)))))

(defn dedupe
  "Returns a lazy sequence with consecutive duplicate values removed in `coll`."
  [coll]
  (cond
    (nil? coll) []
    (and (indexed? coll) (= 0 (count coll))) []
    true (lazy-seq-from-generator (php/:: Generators (dedupe coll)))))

(defn partition
  "Partitions collection into chunks of size n, dropping incomplete final partition.

  Example:
    (partition 3 [1 2 3 4 5 6 7])
    # => ([1 2 3] [4 5 6])"
  [n coll]
  (let [result (lazy-seq-from-generator
                (php/call_user_func_array
                 (php/array "\\Phel\\Lang\\Generators" "partition")
                 (php/array n coll)))]
    (if (php/=== nil result)
      '()
      (with-meta coll result))))

(defn partition-all
  "Partitions collection into chunks of size n, including incomplete final partition.

  Example:
    (partition-all 3 [1 2 3 4 5 6 7])
    # => ([1 2 3] [4 5 6] [7])"
  [n coll]
  (let [result (lazy-seq-from-generator
                (php/call_user_func_array
                 (php/array "\\Phel\\Lang\\Generators" "partitionAll")
                 (php/array n coll)))]
    (if (php/=== nil result)
      '()
      (with-meta coll result))))

# -------------
# Set operation
# -------------

(defn union
  "Union multiple sets into a new one."
  [& sets]
  (let [target (transient (set))]
    (foreach [s sets]
      (foreach [v s]
        (php/-> target (add v))))
    (persistent target)))

(defn- intersection-pair
  [s1 s2]
  (if (< (count s2) (count s1))
    (recur s2 s1)
    (let [result (transient s1)]
      (foreach [item s1]
        (when-not (php/-> s2 (contains item))
          (php/-> result (remove item))))
      (persistent result))))

(defn intersection
  "Intersect multiple sets into a new one."
  [set & sets]
  (reduce intersection-pair set sets))

(defn difference-pair
  [s1 s2]
  (if (< (count s1) (count s2))
    (let [result (transient s1)]
      (foreach [item s1]
        (when (php/-> s2 (contains item))
          (php/-> result (remove item))))
      (persistent result))

    (let [result (transient s1)]
      (foreach [item s2]
        (php/-> result (remove item)))
      (persistent result))))

(defn difference
  "Difference between multiple sets into a new one."
  [set & sets]
  (reduce difference-pair set sets))

(defn symmetric-difference
  "Symmetric difference between multiple sets into a new one."
  [set & sets]
  (reduce |(union (difference $1 $2) (difference $2 $1)) set sets))

# ------------------
# Function operation
# ------------------

(defn identity
  "Returns its argument."
  [x]
  x)

(defn constantly
  "Returns a function that always returns `x` and ignores any passed arguments."
  [x]
  (fn [& _] x))

(defn comp
  "Takes a list of functions and returns a function that is the composition of those functions."
  [& fs]
  (case (count fs)
    0 identity
    1 (first fs)
    2 |((first fs) (apply (second fs) $&))
    (reduce comp fs)))

(defn complement
  "Returns a function that takes the same arguments as `f` and returns the opposite truth value."
  [f]
  |(not (apply f $&)))

(defn juxt
  "Takes a list of functions and returns a new function that is the juxtaposition of those functions.
  `((juxt a b c) x) => [(a x) (b x) (c x)]`."
  [& fs]
  (fn [& args]
    (reduce
     |(conj $1 (apply $2 args))
     []
     fs)))

(defn partial
  "Takes a function `f` and fewer than normal arguments of `f` and returns a function
  that a variable number of additional arguments. When call `f` will be called
  with `args` and the additional arguments."
  [f & args]
  |(apply f (concat [] args $&)))

(defn memoize
  "Returns a memoized version of the function `f`. The memoized function
  caches the return value for each set of arguments."
  [f]
  (let [memoize-cache (var {})]
    (fn [& args]
      (let [c (deref memoize-cache)]
        (if (contains? c args)
          (get c args)
          (let [res (apply f args)]
            (set! memoize-cache (assoc c args res))
            res))))))

# -----------------------
# More sequence operation
# -----------------------

(defn tree-seq
  "Returns a vector of the nodes in the tree, via a depth-first walk.
  branch? is a function with one argument that returns true if the given node
  has children.
  children must be a function with one argument that returns the children of the node.
  root the root node of the tree."
  [branch? children root]
  (let [ret (transient [])]
    (loop [stack (php/array root)]
      (if (> (count stack) 0)
        (let [node (pop stack)]
          (conj ret node)
          (if (branch? node)
            (let [reversed-children (reverse (children node))]
              (foreach [child reversed-children]
                (php/apush stack child))
              (recur stack))
            (recur stack)))
        (with-meta root (persistent ret))))))

(defn flatten
  "Flattens nested sequential structure into a lazy sequence of all leaf values.

  Example:
    (flatten [[1 2] [3 [4 5]] 6])
    # => (1 2 3 4 5 6)"
  [coll]
  (filter
   (complement indexed?)
   (rest (tree-seq indexed? identity coll))))

(defn- merge-with-2 [f left right]
  (for [[k v] :pairs right
        :reduce [acc left]]
    (if (contains? acc k)
      (assoc acc k (f (get acc k) v))
      (assoc acc k v))))

(defn merge-with
  "Merges multiple maps into one new map. If a key appears in more than one
   collection, the result of `(f current-val next-val)` is used."
  [f & hash-maps]
  (case (count hash-maps)
    0 {}
    1 (first hash-maps)
    2 (merge-with-2 f (first hash-maps) (second hash-maps))
    (reduce (partial merge-with f) (first hash-maps) (rest hash-maps))))

(declare deep-merge)

(defn- deep-merge-2 [left right]
  (cond
    (nil? left) right
    (nil? right) left
    (and (hash-map? left) (hash-map? right)) (merge-with deep-merge left right)
    (and (set? left) (set? right)) (union left right)
    (and (vector? left) (vector? right)) (apply vector (concat left right))
    right))

(defn deep-merge
  "Recursively merges data structures."
  [& args]
  (case (count args)
    0 {}
    1 (first args)
    2 (deep-merge-2 (first args) (second args))
    (reduce deep-merge (first args) (rest args))))

# ---
# Math helpers
# ---

(defn assert-non-nil
  [& xs]
  (foreach [x xs]
    (when (php/=== nil x)
      (throw (php/new \InvalidArgumentException "Arithmetic functions do not accept nil values")))))

# -----------------
# Bitwise operation
# -----------------

(defn bit-and
  "Bitwise and."
  {:inline (fn [x y & args] `(do (assert-non-nil ,x ,y ,@args) (php/& ,x ,y ,@args)))}
  [x y & args]
  (apply assert-non-nil (concat [x y] args))
  (let [all (concat [x y] args)]
    (reduce |(php/& $1 $2) all)))

(defn bit-or
  "Bitwise or."
  {:inline (fn [x y & args] `(do (assert-non-nil ,x ,y ,@args) (php/| ,x ,y ,@args)))}
  [x y & args]
  (apply assert-non-nil (concat [x y] args))
  (let [all (concat [x y] args)]
    (reduce |(php/| $1 $2) all)))

(defn bit-xor
  "Bitwise xor."
  {:inline (fn [x y & args] `(do (assert-non-nil ,x ,y ,@args) (php/^ ,x ,y ,@args)))}
  [x y & args]
  (apply assert-non-nil (concat [x y] args))
  (let [all (concat [x y] args)]
    (reduce |(php/^ $1 $2) all)))

(defn bit-not
  "Bitwise complement."
  {:inline (fn [x] `(do (assert-non-nil ,x) (php/~ ,x)))}
  [x]
  (assert-non-nil x)
  (php/~ x))

(defn bit-shift-left
  "Bitwise shift left."
  {:inline (fn [x n] `(do (assert-non-nil ,x ,n) (php/<< ,x ,n)))}
  [x n]
  (assert-non-nil x n)
  (php/<< x n))

(defn bit-shift-right
  "Bitwise shift right."
  {:inline (fn [x n] `(do (assert-non-nil ,x ,n) (php/>> ,x ,n)))}
  [x n]
  (assert-non-nil x n)
  (php/>> x n))

(defn bit-set
  "Set bit an index `n`."
  [x n]
  (bit-or x (bit-shift-left 1 n)))

(defn bit-clear
  "Clear bit an index `n`."
  [x n]
  (bit-and x (bit-not (bit-shift-left 1 n))))

(defn bit-flip
  "Flip bit at index `n`."
  [x n]
  (bit-xor x (bit-shift-left 1 n)))

(defn bit-test
  "Test bit at index `n`."
  [x n]
  (php/!= 0 (bit-and x (bit-shift-left 1 n))))

# --------------
# Math operation
# --------------

(def NAN
  "Constant for Not a Number (NAN) values."
  php/NAN)

(defn +
  "Returns the sum of all elements in `xs`. All elements `xs` must be numbers.
  If `xs` is empty, return 0."
  {:inline (fn [& xs] `(do (assert-non-nil ,@xs) (php/+ ,@xs)))
   :inline-arity (fn [n] (> n 0))}
  [& xs]
  (apply assert-non-nil xs)
  (if (empty? xs)
    0
    (apply php/+ xs)))

(defn -
  "Returns the difference of all elements in `xs`. If `xs` is empty, return 0. If `xs`
  has one element, return the negative value of that element."
  {:inline (fn [& xs] `(do (assert-non-nil ,@xs) (php/- ,@xs)))
   :inline-arity (fn [n] (> n 1))}
  [& xs]
  (apply assert-non-nil xs)
  (case (count xs)
    0 0
    1 (php/* -1 (first xs))
    2 (php/- (first xs) (second xs))
    (reduce |(php/- $1 $2) xs)))

(defn *
  "Returns the product of all elements in `xs`. All elements in `xs` must be
numbers. If `xs` is empty, return 1."
  {:inline (fn [& xs] `(do (assert-non-nil ,@xs) (php/* ,@xs)))
   :inline-arity (fn [n] (> n 0))}
  [& xs]
  (apply assert-non-nil xs)
  (case (count xs)
    0 1
    1 (first xs)
    2 (php/* (first xs) (second xs))
    (reduce |(php/* $1 $2) xs)))

(defn /
  "Returns the nominator divided by all the denominators. If `xs` is empty,
returns 1. If `xs` has one value, returns the reciprocal of x."
  {:inline (fn [& xs] `(do (assert-non-nil ,@xs) (php// ,@xs)))
   :inline-arity (fn [n] (> n 1))}
  [& xs]
  (apply assert-non-nil xs)
  (case (count xs)
    0 1
    1 (php// 1 (first xs))
    2 (php// (first xs) (second xs))
    (reduce |(php// $1 $2) xs)))

(defn %
  "Return the remainder of `dividend` / `divisor`."
  {:inline (fn [dividend divisor] `(do (assert-non-nil ,dividend ,divisor) (php/% ,dividend ,divisor)))}
  [dividend divisor]
  (assert-non-nil dividend divisor)
  (php/% dividend divisor))

(defn **
  "Return `a` to the power of `x`."
  {:inline (fn [a x] `(do (assert-non-nil ,a ,x) (php/** ,a ,x)))}
  [a x]
  (assert-non-nil a x)
  (php/** a x))

(defn inc
  "Increments `x` by one."
  {:inline (fn [x] `(do (assert-non-nil ,x) (php/+ ,x 1)))}
  [x]
  (assert-non-nil x)
  (+ x 1))

(defn dec
  "Decrements `x` by one."
  {:inline (fn [x] `(do (assert-non-nil ,x) (php/- ,x 1)))}
  [x]
  (assert-non-nil x)
  (- x 1))

(defn even?
  "Checks if `x` is even."
  [x]
  (= 0 (% x 2)))

(defn odd?
  "Checks if `x` is odd."
  [x]
  (= 1 (% x 2)))

(defn zero?
  "Checks if `x` is zero."
  [x]
  (or (= x 0) (= x 0.0)))

(defn one?
  "Checks if `x` is one."
  [x]
  (or (= x 1) (= x 1.0)))

(defn pos?
  "Checks if `x` is greater than zero."
  [x]
  (> x 0))

(defn neg?
  "Checks if `x` is smaller than zero."
  [x]
  (< x 0))

(defn nan?
  "Checks if `x` is not a number."
  [x]
  (php/is_nan x))

(defn rand
  "Returns a random number between 0 and 1."
  []
  (/ (php/random_int 0 php/PHP_INT_MAX) php/PHP_INT_MAX))

(defn rand-int
  "Returns a random number between 0 and `n`."
  [n]
  (php/random_int 0 n))

(defn rand-nth
  "Returns a random item from xs."
  [xs]
  (get xs (rand-int (dec (count xs)))))

(defn extreme
  "Returns the most extreme value in `args` based on the binary `order` function."
  [order args]
  (reduce |(if (order $1 $2) $1 $2) args))

(defn min
  "Returns the numeric minimum of all numbers."
  [& numbers]
  (extreme < numbers))

(defn max
  "Returns the numeric maximum of all numbers."
  [& numbers]
  (extreme > numbers))

(defn coerce-in
  "Returns `v` if it is in the range, or `min` if `v` is less than `min`, or `max` if `v` is greater than `max`."
  [v min max]
  (when (< max min)
    (throw (php/new \InvalidArgumentException "Max values is bigger than min value")))
  (php/max (php/min v max) min))

(defn sum
  "Returns the sum of all elements is `xs`."
  [xs]
  (apply + xs))

(defn mean
  "Returns the mean of `xs`."
  [xs]
  (/ (sum xs) (count xs)))

(defn median
  "Returns the median of `xs`."
  [xs]
  (let [arr (to-php-array xs)
        cnt (count arr)]
    (when (zero? cnt)
      (throw (php/new \InvalidArgumentException "Cannot compute median of empty sequence")))
    (php/sort arr)
    (let [mid (php/intdiv cnt 2)]
      (if (odd? cnt)
        (php/aget arr mid)
        (/ (+ (php/aget arr (dec mid)) (php/aget arr mid)) 2)))))

# ---------------
# Print operation
# ---------------

(defmacro with-output-buffer
  "Everything that is printed inside the body will be stored in a buffer.
   The result of the buffer is returned."
  [& body]
  (let [res (gensym)]
    `(do
       (php/ob_start)
       ,@body
       (let [,res (php/ob_get_contents)]
         (php/ob_end_clean)
         ,res))))

(defn print-str
  "Same as print. But instead of writing it to an output stream, the resulting string is returned."
  [& xs]
  (let [len (count xs)
        printer (php/:: Printer (nonReadable))
        pp |(php/-> printer (print $))]
    (case (count xs)
      0 ""
      1 (pp (first xs))
      (loop [res (pp (first xs))
             seq (next xs)]
        (if seq
          (recur (str res " " (pp (first seq))) (next seq))
          res)))))

(defn print
  "Prints the given values to the default output stream. Returns nil."
  [& xs]
  (php/print (apply print-str xs))
  nil)

(defn println
  "Same as print followed by a newline."
  [& xs]
  (apply print xs)
  (php/print "\n")
  nil)

(defn format
  "Returns a formatted string. See PHP's [sprintf](https://www.php.net/manual/en/function.sprintf.php) for more information."
  [fmt & xs]
  (apply php/sprintf fmt xs))

(defn printf
  "Output a formatted string. See PHP's [printf](https://www.php.net/manual/en/function.printf.php) for more information."
  [fmt & xs]
  (apply php/printf fmt xs)
  nil)

# ---------------
# File operations
# ---------------

(defn- file-get-contents-silenced
  "Wrapper around file_get_contents that suppresses PHP warnings.
  We handle errors by checking the return value."
  [path use-include-path context offset length]
  (let [old-error-level (php/error_reporting 0)
        content (php/file_get_contents path use-include-path context offset length)]
    (php/error_reporting old-error-level)
    content))

(defn slurp
  "Reads entire file or URL into a string.

  Example:
    (slurp \"file.txt\")
    # => \"file contents\""
  [path & [opts]]
  (let [is-url? (php/preg_match "/^(https?|ftp):\/\//i" path)]
    # Validate for non-URLs
    (when-not is-url?
      # Check if path is a directory
      (when (php/is_dir path)
        (throw (php/new \InvalidArgumentException
                        (str "Cannot read directory: " path))))
      # Check if file exists
      (when-not (php/is_file path)
        (throw (php/new \InvalidArgumentException
                        (str "File not found: " path)))))
    # Read content
    (let [opts             (or opts {})
          use-include-path (or (:use-include-path opts) false)
          context          (or (:context opts) nil)
          offset           (or (:offset opts) 0)
          length           (or (:length opts) nil)
          content (file-get-contents-silenced path use-include-path context offset length)]
      # Check if file_get_contents failed
      (when (= content false)
        (throw (php/new \InvalidArgumentException
                        (str "Failed to read from: " path))))
      content)))

(defn spit
  "Writes data to file, returning number of bytest that were written or `nil`
  on failure. Accepts `opts` map for overriding default PHP file_put_contents
  arguments, as example to append to file use {:flags php/FILE_APPEND}.
  See PHP's [file_put_contents](https://www.php.net/manual/en/function.file-put-contents.php) for more information."
  [filename data & [opts]]
  (when (php/is_dir filename)
    (throw (php/new \InvalidArgumentException
                    "Argument filename should be a valid path to a file, directory given.")))
  (let [opts    (or opts {})
        flags   (or (:flags opts) 0)
        context (or (:context opts) nil)
        result (php/file_put_contents filename data flags context)]
    (when (int? result) result)))

(defn line-seq
  "Returns a lazy sequence of lines from a file.

  Example:
    (take 10 (line-seq \"large-file.txt\"))
    # => [\"line1\" \"line2\" ...]"
  [filename]
  (let [result (lazy-seq-from-generator
                (php/call_user_func_array
                 (php/array "\\Phel\\Lang\\Generators" "fileLines")
                 (php/array filename)))]
    (if (php/=== nil result)
      '()
      result)))

(defn file-seq
  "Returns a lazy sequence of all files and directories in a directory tree.

  Example:
    (filter |(php/str_ends_with $ \".phel\") (file-seq \"src/\"))
    # => [\"src/file1.phel\" \"src/file2.phel\" ...]"
  [path]
  (let [result (lazy-seq-from-generator
                (php/call_user_func_array
                 (php/array "\\Phel\\Lang\\Generators" "fileSeq")
                 (php/array path)))]
    (if (php/=== nil result)
      '()
      result)))

(defn read-file-lazy
  "Returns a lazy sequence of byte chunks from a file.

  Example:
    (take 5 (read-file-lazy \"large-file.bin\" 1024))
    # => [\"chunk1\" \"chunk2\" ...]"
  ([filename]
   (read-file-lazy filename 8192))
  ([filename chunk-size]
   (let [result (lazy-seq-from-generator
                 (php/call_user_func_array
                  (php/array "\\Phel\\Lang\\Generators" "readFileChunks")
                  (php/array filename chunk-size)))]
     (if (php/=== nil result)
       '()
       result))))

(defn csv-seq
  "Returns a lazy sequence of rows from a CSV file.

  Example:
    (take 10 (csv-seq \"data.csv\"))
    # => [[\"col1\" \"col2\"] [\"val1\" \"val2\"] ...]"
  ([filename]
   (csv-seq filename {}))
  ([filename options]
   (let [separator (get options :separator ",")
         enclosure (get options :enclosure "\"")
         escape (get options :escape "\\")
         result (lazy-seq-from-generator
                 (php/call_user_func_array
                  (php/array "\\Phel\\Lang\\Generators" "csvLines")
                  (php/array filename separator enclosure escape)))]
     (if (php/=== nil result)
       '()
       result))))

# ----------------
# Threading macros
# ----------------

(defmacro ->
  "Threads the expr through the forms. Inserts `x` as the second item
  in the first form, making a list of it if it is not a list already.
  If there are more forms, insert the first form as the second item in
  the second form, etc."
  [x & forms]
  (loop [x x
         forms (if (empty? forms) nil forms)]
    (if forms
      (let [form (first forms)
            threaded (if (list? form)
                       (with-meta form `(,(first form) ,x ,@(next form)))
                       (with-meta form (list form x)))]
        (recur threaded (next forms)))
      x)))

(defmacro ->>
  "Threads the expr through the forms. Inserts `x` as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, insert the first form as the
  last item in the second form, etc."
  [x & forms]
  (loop [x x
         forms (if (empty? forms) nil forms)]
    (if forms
      (let [form (first forms)
            threaded (if (list? form)
                       (with-meta form `(,(first form) ,@(next form) ,x))
                       (with-meta form (list form x)))]
        (recur threaded (next forms)))
      x)))

(defmacro some->
  "Threads `x` through the forms like `->` but stops when a form returns `nil`."
  [x & forms]
  (loop [x x
         forms (if (empty? forms) nil forms)]
    (if forms
      (let [form (first forms)
            g (gensym)
            call (if (list? form)
                   (let [rest (next form)
                         args (if rest
                                (cons g rest)
                                [g])]
                     (with-meta form (apply list (cons (first form) args))))
                   (with-meta form (list form g)))
            threaded (list 'let
                           [g x]
                           (list 'if
                                 (list 'php/=== nil g)
                                 nil
                                 call))]
        (recur threaded (next forms)))
      x)))

(defmacro some->>
  "Threads `x` through the forms like `->>` but stops when a form returns `nil`."
  [x & forms]
  (loop [x x
         forms (if (empty? forms) nil forms)]
    (if forms
      (let [form (first forms)
            g (gensym)
            call (if (list? form)
                   (let [rest (next form)
                         args (if rest
                                (concat rest [g])
                                [g])]
                     (with-meta form (apply list (cons (first form) args))))
                   (with-meta form (list form g)))
            threaded (list 'let
                           [g x]
                           (list 'if
                                 (list 'php/=== nil g)
                                 nil
                                 call))]
        (recur threaded (next forms)))
      x)))

(defmacro as->
  "Binds `name` to `expr`, evaluates the first form in the lexical context
  of that binding, then binds name to that result, repeating for each
  successive form, returning the result of the last form."
  [expr name & forms]
  (let [x (gensym)]
    `(let [,name ,expr
           ,@(interleave (repeat (count forms) name) forms)]
       ,name)))

(defmacro doto
  "Evaluates x then calls all of the methods and functions with the
  value of x supplied at the front of the given arguments. The forms
  are evaluated in order. Returns x."
  [x & forms]
  (let [gx (gensym)]
    `(let [,gx ,x]
       ,@(map (fn [f]
                (if (list? f)
                  (with-meta f `(,(first f) ,gx ,@(next f)))
                  (with-meta f `(,f ,gx))))
              forms)
       ,gx)))

# ---------------
# Regex functions
# ---------------

(defn re-seq
  "Returns a sequence of successive matches of pattern in string."
  [re s]
  (let [matches (php/array)
        match-result (php/preg_match_all re s matches)]
    (apply vector (php/aget matches 0))))

# -------
# Binding
# -------

# inspired by Clojure's with-redefs
(defmacro binding
  "Temporary redefines definitions while executing the body.
  The value will be reset after the body was executed."
  [bindings & body]
  (let [names (take-nth 2 bindings)
        vals (take-nth 2 (drop 1 bindings))
        orig-val-syms (map gensym names)
        temp-val-syms (map gensym names)
        binds (map vector names temp-val-syms)
        resets (reverse (map vector names orig-val-syms))
        bind-value (fn [[k v]] (list 'set-var k v))]
    `(let [,@(interleave orig-val-syms names)
           ,@(interleave temp-val-syms vals)]
       ,@(map bind-value binds)
       (try
         (do ,@body)
         (finally
           ,@(map bind-value resets))))))

# ----------
# Interfaces
# ----------

(defmacro definterface
  "Defines an interface."
  [name & fns]
  (let [name-str (php/-> name (getName))
        munge (php/new Munge)
        class-name-str (php/. *ns* "\\" (php/-> munge (encode name-str)))
        defs (for [[fn-name args doc] :in fns
                   :let [fn-name-str (php/-> fn-name (getName))
                         munged-fn-name (php/-> munge (encode fn-name-str))
                         munged-fn-symbol (php/:: Symbol (create munged-fn-name))]]
               `(defn ,fn-name {:doc ,doc} ,args
                  (if (php/is_a ,(first args) ,class-name-str)
                    (php/-> ,(first args) (,munged-fn-symbol ,@(rest args)))
                    (throw (php/new \InvalidArgumentException ,(str "Value doesn't implement interface " name))))))]
    `(do
       (definterface* ,name ,@fns)
       ,@defs)))

(defmacro if-let
  "If test is true, evaluates then with binding-form bound to the value of test,
  if not, yields else"
  [bindings then & [else]]
  (let [err |(throw (php/new \InvalidArgumentException $))]
    (when-not
      (vector? bindings)
      (err (str "if-let requires a vector for it's bindings, "
                (type bindings) " given")))
    (when-not
      (= 2 (count bindings))
      (err (str "if-let requires bindings to have 2 elements, "
                (count bindings) " given"))))

  (let [form (bindings 0) tst (bindings 1) temp-sym (gensym)]
    `(let [temp-sym ,tst]
       (if temp-sym
         (let [,form temp-sym]
           ,then)
         ,else))))

(defmacro when-let
  "When test is true, evaluates body with binding-form bound to the value of test"
  [bindings & body]
  (let [err |(throw (php/new \InvalidArgumentException $))]
    (when-not
      (vector? bindings)
      (err (str "when-let requires a vector for it's bindings, "
                (type bindings) " given")))
    (when-not
      (= 2 (count bindings))
      (err (str "when-let requires bindings to have 2 elements, "
                (count bindings) " given"))))

  (let [form (bindings 0) tst (bindings 1) temp-sym (gensym)]
    `(let [temp-sym ,tst]
       (when temp-sym
         (let [,form temp-sym]
           ,@body)))))

(defmacro time
  "Evaluates expr and prints the time it took. Returns the value of expr."
  [expr]
  `(let [start$ (php/microtime true)
         ret$ ,expr]
     (println "Elapsed time:" (* 1000 (- (php/microtime true) start$)) "msecs")
     ret$))

(defn name
  "Returns the name string of a string, keyword or symbol."
  [x]
  (if (string? x) x (php/-> x (getName))))

(defn namespace
  "Return the namespace string of a symbol or keyword. Nil if not present."
  [x]
  (php/-> x (getNamespace)))

(defn full-name
  "Return the namespace and name string of a string, keyword or symbol."
  [x]
  (if (string? x) x (php/-> x (getFullName))))

(defn read-string
  "Reads the first phel expression from the string s."
  [s]
  (let [cf (php/new CompilerFacade)
        token-stream (php/-> cf (lexString s))
        node (php/-> cf (parseNext token-stream))]
    (when node
      (php/-> (php/-> cf (read node)) (getAst)))))

(defn eval
  "Evaluates a form and return the evaluated results."
  [form]
  (let [cf (php/new CompilerFacade)]
    (php/-> cf (evalForm form))))

(defn compile
  "Returns the compiled PHP code string for the given form."
  [form]
  (let [cf (php/new CompilerFacade)]
    (php/-> (php/-> cf (compileForm form)) (getPhpCode))))

(defn- get-global-env []
  (php/:: GlobalEnvironmentSingleton (getInstance)))

(defn- get-global-var-node [sym]
  (php/-> (get-global-env) (resolve sym (php/:: NodeEnvironment (empty)))))

(defn- inline-call? [meta arity]
  (and (:inline meta)
       (let [af (:inline-arity meta)]
         (if af
           (af arity)
           true))))

(defn macroexpand-1
  "Expands the given form once if it is a macro call."
  [form]
  (if (and (list? form) (not (empty? form)))
    (let [op (first form)]
      (if (symbol? op)
        (let [node (get-global-var-node op)]
          (if (php/instanceof node GlobalVarNode)
            (let [meta (php/-> node (getMeta))
                  ns (php/-> node (getNamespace))
                  name (php/-> (php/-> node (getName)) (getName))
                  args (rest form)]
              (cond
                (inline-call? meta (count args))
                (apply (:inline meta) args)
                (:macro meta)
                (let [macro-fn (php/:: Phel (getDefinition ns name))]
                  (apply macro-fn args))
                :else
                form))
            form))
        form))
    form))

(defn macroexpand
  "Recursively expands the given form until it is no longer a macro call."
  [form]
  (loop [f form]
    (let [e (macroexpand-1 f)]
      (if (= e f)
        e
        (recur e)))))
