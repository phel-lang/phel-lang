(ns phel-test\test\core\infinite-seqs
  (:require phel\test :refer [deftest is]))

(deftest test-repeat-infinite
  (is (= [:a :a :a] (take 3 (repeat :a)))
      "(take 3 (repeat :a))"))

(deftest test-repeatedly-infinite
  (is (= [:x :x :x] (take 3 (repeatedly (fn [] :x))))
      "(take 3 (repeatedly (fn [] :x)))"))

(deftest test-iterate
  (is (= [1 2 4 8] (take 4 (iterate (fn [x] (* 2 x)) 1)))
      "(take 4 (iterate (fn [x] (* 2 x)) 1))"))

(deftest test-doall-with-lazy-sequence-from-iterate
  (is (= [1 2 3 4 5] (doall (take 5 (iterate inc 1))))
      "doall should realize lazy sequence and return vector"))

(deftest test-doall-with-lazy-sequence-from-repeat
  (is (= [:a :a :a] (doall (take 3 (repeat :a))))
      "doall should work with repeat"))

(deftest test-doall-with-lazy-sequence-from-repeatedly
  (is (= [:x :x :x] (doall (take 3 (repeatedly (fn [] :x)))))
      "doall should return realized values from repeatedly"))

(deftest test-doall-with-vector
  (is (= [1 2 3] (doall [1 2 3]))
      "doall should return vectors unchanged"))

(deftest test-doall-with-list
  (is (= '(1 2 3) (doall '(1 2 3)))
      "doall should return lists unchanged"))

(deftest test-dorun-with-lazy-sequence-returns-nil
  (is (= nil (dorun (take 5 (iterate inc 1))))
      "dorun should return nil"))

(deftest test-dorun-executes-lazy-sequence
  (is (= nil (dorun (take 5 (repeatedly (fn [] :x)))))
      "dorun should execute lazy sequence and return nil"))

(deftest test-dorun-with-vector-returns-nil
  (is (= nil (dorun [1 2 3]))
      "dorun should return nil for vectors"))

(deftest test-dorun-with-list-returns-nil
  (is (= nil (dorun '(1 2 3)))
      "dorun should return nil for lists"))

(deftest test-doall-with-empty-lazy-sequence
  (is (= [] (doall (take 0 (iterate inc 1))))
      "doall should return empty vector for empty sequences"))

(deftest test-chained-lazy-operations-with-doall
  (is (= [2 4 6 8 10]
         (doall (take 5 (iterate (fn [x] (+ x 2)) 2))))
      "doall should work with chained lazy operations"))

(deftest test-realized-with-vector
  (is (= true (realized? [1 2 3]))
      "realized? should return true for vectors"))

(deftest test-realized-with-list
  (is (= true (realized? '(1 2 3)))
      "realized? should return true for lists"))

(deftest test-realized-with-lazy-sequence-from-iterate
  (is (= true (realized? (take 5 (iterate inc 1))))
      "realized? returns true for ChunkedSeq (first chunk is always realized)"))

(deftest test-realized-with-lazy-sequence-from-repeat
  (is (= true (realized? (take 3 (repeat :a))))
      "realized? returns true for ChunkedSeq from repeat"))

(deftest test-realized-with-nil
  (is (= true (realized? nil))
      "realized? should return true for nil"))

(deftest test-realized-with-empty-vector
  (is (= true (realized? []))
      "realized? should return true for empty vectors"))

(deftest test-get-on-infinite-lazy-seq
  (is (= 5 (get (iterate inc 0) 5))
      "get should work on infinite lazy sequences without hanging"))

(deftest test-get-on-finite-lazy-seq
  (is (= 2 (get (map inc [1 2 3]) 0))
      "get should work on finite lazy sequences"))

(deftest test-get-on-lazy-seq-out-of-bounds
  (is (= nil (get (map inc [1 2 3]) 10))
      "get should return nil for out of bounds index"))

(deftest test-get-on-lazy-seq-with-default
  (is (= :default (get (map inc [1 2 3]) 10 :default))
      "get should return default value for out of bounds index"))

(deftest test-filter-on-vector-returns-lazy
  (is (= [2 4] (doall (filter even? [1 2 3 4])))
      "filter on vector should return lazy sequence"))

(deftest test-filter-on-infinite-seq
  (is (= [0 2 4 6 8] (take 5 (filter even? (iterate inc 0))))
      "filter on infinite sequence should work without hanging"))

(deftest test-filter-empty-collection
  (is (= [] (filter even? []))
      "filter on empty collection should return empty vector"))

(deftest test-filter-preserves-metadata
  (let [m {:foo "bar"}
        data (set-meta! [1 2 3 4] m)]
    (is (= m (meta (filter even? data)))
        "filter should preserve metadata")))

(deftest test-take-on-vector-returns-lazy
  (is (= [1 2 3] (doall (take 3 [1 2 3 4 5])))
      "take on vector should return lazy sequence"))

(deftest test-take-on-infinite-seq
  (is (= [0 1 2 3 4] (doall (take 5 (iterate inc 0))))
      "take on infinite sequence should work"))

(deftest test-take-zero
  (is (= [] (take 0 [1 2 3]))
      "take 0 should return empty vector"))

(deftest test-take-negative
  (is (= [] (take -5 [1 2 3]))
      "take negative should return empty vector"))

(deftest test-take-empty-collection
  (is (= [] (take 5 []))
      "take on empty collection should return empty vector"))

(deftest test-take-preserves-metadata
  (let [m {:foo "bar"}
        data (set-meta! [1 2 3 4 5] m)]
    (is (= m (meta (take 3 data)))
        "take should preserve metadata")))

# Tests for drop always lazy
(deftest test-drop-on-vector-returns-lazy
  (is (= [3 4 5] (doall (drop 2 [1 2 3 4 5])))
      "drop on vector should return lazy sequence"))

(deftest test-drop-on-infinite-seq
  (is (= [5 6 7 8 9] (take 5 (drop 5 (iterate inc 0))))
      "drop on infinite sequence should work"))

(deftest test-drop-zero
  (is (= [1 2 3] (drop 0 [1 2 3]))
      "drop 0 should return original sequence"))

(deftest test-drop-negative
  (is (= [1 2 3] (doall (drop -5 [1 2 3])))
      "drop negative should return full sequence"))

(deftest test-drop-empty-collection
  (is (= [] (drop 5 []))
      "drop on empty collection should return empty vector"))

(deftest test-drop-preserves-metadata
  (let [m {:foo "bar"}
        data (set-meta! [1 2 3 4 5] m)]
    (is (= m (meta (drop 2 data)))
        "drop should preserve metadata")))

# Tests for drop-while always lazy
(deftest test-drop-while-on-vector-returns-lazy
  (is (= [3 4 5] (doall (drop-while |(< $ 3) [1 2 3 4 5])))
      "drop-while on vector should return lazy sequence"))

(deftest test-drop-while-on-infinite-seq
  (is (= [0 1 2 3 4] (take 5 (drop-while neg? (iterate inc -10))))
      "drop-while on infinite sequence should work"))

(deftest test-drop-while-empty-collection
  (is (= [] (drop-while |(< $ 10) []))
      "drop-while on empty collection should return empty vector"))

(deftest test-drop-while-all-dropped
  (is (= [] (drop-while |(< $ 10) [1 2 3]))
      "drop-while should return empty when all elements match"))

(deftest test-drop-while-none-dropped
  (is (= [1 2 3] (doall (drop-while |(> $ 10) [1 2 3])))
      "drop-while should return full sequence when no elements match"))

(deftest test-drop-while-preserves-metadata
  (let [m {:foo "bar"}
        data (set-meta! [1 2 3 4 5] m)]
    (is (= m (meta (drop-while |(< $ 3) data)))
        "drop-while should preserve metadata")))

# Tests for take-while always lazy
(deftest test-take-while-on-vector-returns-lazy
  (is (= [1 2] (doall (take-while |(< $ 3) [1 2 3 4 5])))
      "take-while on vector should return lazy sequence"))

(deftest test-take-while-on-infinite-seq
  (is (= [-5 -4 -3 -2 -1] (doall (take-while neg? (iterate inc -5))))
      "take-while on infinite sequence should work"))

(deftest test-take-while-empty-collection
  (is (= [] (take-while |(< $ 10) []))
      "take-while on empty collection should return empty vector"))

(deftest test-take-while-nothing-taken
  (is (= [] (doall (take-while |(> $ 10) [1 2 3])))
      "take-while should return empty when first element doesn't match"))

(deftest test-take-while-all-taken
  (is (= [1 2 3] (doall (take-while |(< $ 10) [1 2 3])))
      "take-while should return full sequence when all elements match"))

(deftest test-take-while-preserves-metadata
  (let [m {:foo "bar"}
        data (set-meta! [1 2 3 4 5] m)]
    (is (= m (meta (take-while |(< $ 3) data)))
        "take-while should preserve metadata")))

# Tests for take-nth always lazy
(deftest test-take-nth-on-vector-returns-lazy
  (is (= [1 3 5] (doall (take-nth 2 [1 2 3 4 5 6])))
      "take-nth on vector should return lazy sequence"))

(deftest test-take-nth-on-infinite-seq
  (is (= [0 2 4 6 8] (take 5 (take-nth 2 (iterate inc 0))))
      "take-nth on infinite sequence should work"))

(deftest test-take-nth-empty-collection
  (is (= [] (take-nth 2 []))
      "take-nth on empty collection should return empty vector"))

(deftest test-take-nth-every-element
  (is (= [1 2 3 4 5] (doall (take-nth 1 [1 2 3 4 5])))
      "take-nth 1 should return all elements"))

(deftest test-take-nth-larger-than-collection
  (is (= [1] (doall (take-nth 10 [1 2 3])))
      "take-nth larger than collection should return first element"))

(deftest test-take-nth-preserves-metadata
  (let [m {:foo "bar"}
        data (set-meta! [1 2 3 4 5 6] m)]
    (is (= m (meta (take-nth 2 data)))
        "take-nth should preserve metadata")))

# Tests for chaining lazy operations
(deftest test-chained-drop-take-on-infinite-seq
  (is (= [10 11 12 13 14] (take 5 (drop 10 (iterate inc 0))))
      "chaining drop and take on infinite sequence should work"))

(deftest test-chained-take-while-filter-on-infinite-seq
  (is (= [0 2 4] (doall (take-while |(< $ 5) (filter even? (iterate inc 0)))))
      "chaining take-while and filter on infinite sequence should work"))

(deftest test-chained-drop-while-take-nth-on-infinite-seq
  (is (= [0 2 4 6 8] (take 5 (take-nth 2 (drop-while neg? (iterate inc -10)))))
      "chaining drop-while, take-nth, and take on infinite sequence should work"))

(deftest test-drop-with-nil
  (is (= [] (drop 5 nil))
      "drop with nil should return empty vector"))

(deftest test-drop-while-with-nil
  (is (= [] (drop-while pos? nil))
      "drop-while with nil should return empty vector"))

(deftest test-take-while-with-nil
  (is (= [] (take-while pos? nil))
      "take-while with nil should return empty vector"))

(deftest test-take-nth-with-nil
  (is (= [] (take-nth 2 nil))
      "take-nth with nil should return empty vector"))

# Tests for cycle
(deftest test-cycle-basic
  (is (= [1 2 3 1 2 3 1 2] (take 8 (cycle [1 2 3])))
      "cycle should repeat elements indefinitely"))

(deftest test-cycle-single-element
  (is (= [:a :a :a :a :a] (take 5 (cycle [:a])))
      "cycle with single element should work"))

(deftest test-cycle-empty-collection
  (is (= [] (take 5 (cycle [])))
      "cycle with empty collection should return empty"))

(deftest test-cycle-with-doall
  (is (= [1 2 1 2 1] (doall (take 5 (cycle [1 2]))))
      "cycle should work with doall"))

(deftest test-cycle-with-drop
  (is (= [3 1 2 3 1] (take 5 (drop 2 (cycle [1 2 3]))))
      "cycle should work with drop"))

(deftest test-cycle-with-filter
  (is (= [2 4 2 4 2] (take 5 (filter even? (cycle [1 2 3 4]))))
      "cycle should work with filter"))
