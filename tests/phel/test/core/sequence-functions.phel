(ns phel-test\test\core\sequence-functions
  (:require phel\test :refer [deftest is]))

(defn naturals []
  (loop [i 0]
    (php/yield i)
    (recur (inc i))))

# =============================================================================
# Transformation Functions (map, mapcat, into, reduce)
# =============================================================================

(deftest test-map
  (is (= [] (map str [])) "map1 with empty collection")
  (is (= ["1" "2"] (map str [1 2])) "map1")
  (is (= ["13" "24"] (map str [1 2] [3 4])) "map2")
  (is (= ["13" "24"] (map str [1 2 10] [3 4])) "map2 unequal size")
  (is (= [] (map str [] [])) "map2 with empty collections")
  (is (= [] (map str [1 2 3] [])) "map2 with empty and non-empty collection"))

(deftest test-map-indexed
  (is (= [[0 "a"] [1 "b"] [2 "c"]] (map-indexed vector ["a" "b" "c"])) "map-indexed"))

(deftest test-map-empty-element
  (is (= [] (map |(throw (php/new \Exception)) [])) "`pred` is not executed when searching for empty vectors."))

(deftest test-mapcat
  (is (= [1 2 3 4 5 6] (mapcat reverse [[3 2 1] [6 5 4]])) "mapcat")
  (is (= [] (mapcat identity [])) "mapcat on empty vector"))

(deftest test-into
  (is (= [1 2 3 4] (into [] '(1 2 3 4))) "into vector from list")
  (is (= [1 2 3 4 5] (into [1 2] [3 4 5])) "into vector from vector")
  (is (= (hash-set 1 2 3) (into (hash-set) [1 2 3 2 1])) "into set removes duplicates")
  (is (= {:a 1 :b 2} (into {} [[:a 1] [:b 2]])) "into map from pairs")
  (is (= [[:a 1] [:b 2]] (into [] {:a 1 :b 2})) "into vector from map")
  (is (= {:a 1 :b 2 :c 3} (into {:a 1} {:b 2 :c 3})) "into map from map"))

(deftest test-reduce
  (is (= "abc" (reduce str "" ["a" "b" "c"])) "reduce three elements vector")
  (is (= "abc" (reduce str "" [nil "a" "b" "c"])) "reduce vector containing a nil value")
  (is (= "x" (reduce str "x" [])) "reduce empty vector")
  (is (= 6 (reduce + 0 (for [x :in (hash-set 1 2 3)] x))) "reduce on set"))

(deftest test-reduce-without-init
  (is (= "abc" (reduce str ["a" "b" "c"])) "reduce without init three elements vector")
  (is (= "abc" (reduce str [nil "a" "b" "c"])) "reduce without init vector containing a nil value")
  (is (= "a" (reduce str ["a"])) "reduce without init one element vector")
  (is (= "" (reduce str [])) "reduce without init empty vector")
  (is (= 6 (reduce + (for [x :in (hash-set 1 2 3)] x))) "reduce without init on set vector")
  (is (= 0 (reduce + [])) "reduce without init on empty vector with +"))

# =============================================================================
# Path Navigation (assoc-in, update-in, dissoc-in)
# =============================================================================

(deftest test-assoc-in
  (is (= {:a {:b {:c 1}}} (assoc-in {:a {}} [:a :b :c] 1)) "assoc-in: autocreate tables")
  (is (= {:a {:b {:c 2}}} (assoc-in {:a {:b {:c 1}}} [:a :b :c] 2)) "assoc-in: update value of table")
  (is (= {:a {:b [2]}} (assoc-in {:a {:b [1]}} [:a :b 0] 2)) "assoc-in: update value of array"))

(deftest test-update-in
  (is (= {:a 2} (update-in {:a 1} [:a] inc)) "update-in: update value of table")
  (is (= {:a {:b {:c 1}}}
         (update-in {:a {}} [:a :b :c] (fn [x] (inc (or x 0)))))
      "update-in: autocreate tables")
  (is (= {:a {:b [2]}} (update-in {:a {:b [1]}} [:a :b 0] inc)) "update-in: update value of array"))

(deftest test-dissoc-in
  (is (= {:a {:b {}}} (dissoc-in {:a {:b {:c 1}}} [:a :b :c])) "dissoc-in: nested map")
  (is (= {:a {:b {:c 1}}} (dissoc-in {:a {:b {:c 1}}} [:a :x])) "dissoc-in: missing key"))

# =============================================================================
# Taking & Dropping Elements
# =============================================================================

(deftest test-drop
  (is (= ["a" "b" "c"] (doall (drop 0 ["a" "b" "c"]))) "drop zero elements")
  (is (= ["c"] (doall (drop 2 ["a" "b" "c"]))) "drop two elements")
  (is (= [] (drop 3 ["a" "b" "c"])) "drop three elements")
  (is (= [] (drop 4 ["a" "b" "c"])) "drop four elements")
  (is (= ["a" "b" "c"] (doall (drop -1 ["a" "b" "c"]))) "drop with negative number")
  (is (= ["c"] (doall (drop 2 ["a" "b" "c"]))) "drop on vector")
  (is (= ["c"] (doall (drop 2 (php/array "a" "b" "c")))) "drop on php array (returns lazy seq)"))

(deftest test-drop-last
  (is (= ["a" "b"] (drop-last 1 ["a" "b" "c"])) "drop-last element")
  (is (= ["a"] (drop-last 2 ["a" "b" "c"])) "drop-last two elements")
  (is (= [] (drop-last 3 ["a" "b" "c"])) "drop-last three elements")
  (is (= [] (drop-last 4 ["a" "b" "c"])) "drop-last four elements")
  (is (= ["a" "b" "c"] (drop-last 0 ["a" "b" "c"])) "drop-last zero elements")
  (is (= ["a" "b" "c"] (drop-last -1 ["a" "b" "c"])) "drop-last with negative number")
  (is (= [] (drop-last 1 [])) "drop-last on empty vector")
  (is (= (php/array "a" "b") (drop-last 1 (php/array "a" "b" "c"))) "drop-last on php array")
  (is (= (php/array) (drop-last 1 (php/array))) "drop-last on empty php array"))

(deftest test-last
  (is (= "c" (last ["a" "b" "c"])) "last element")
  (is (nil? (last [])) "last on empty vector")
  (is (= "c" (last (php/array "a" "b" "c"))) "last on php array")
  (is (nil? (last (php/array))) "last on empty php array"))

(deftest test-butlast
  (is (= ["a" "b"] (butlast ["a" "b" "c"])) "butlast element")
  (is (= [] (butlast ["a"])) "butlast single element")
  (is (= [] (butlast [])) "butlast empty vector")
  (is (= (php/array "a" "b") (butlast (php/array "a" "b" "c"))) "butlast on php array"))

(deftest test-drop-while
  (is (= [1 2 3 4 -1 -2 -3] (doall (drop-while neg? [-1 -2 -3 1 2 3 4 -1 -2 -3]))) "drop-while: first three element")
  (is (= [] (drop-while neg? [-1 -2 -3])) "drop-while: everything")
  (is (= [] (drop-while neg? [])) "drop-while: empty array")
  (is (= [1 2 3 4] (doall (drop-while neg? [1 2 3 4]))) "drop-while: nothing")
  (is (= [1 2 3 4 -1 -2 -3] (doall (drop-while neg? [-1 -2 -3 1 2 3 4 -1 -2 -3]))) "drop-while: vector")
  (is (= [1 2 3 4 -1 -2 -3] (doall (drop-while neg? (php/array -1 -2 -3 1 2 3 4 -1 -2 -3)))) "drop-while: php array (returns lazy seq)"))

(deftest test-drop-while-empty-element
  (is (= [] (drop-while |(throw (php/new \Exception)) [])) "`pred` is not executed when searching for empty vectors."))

(deftest test-take
  (is (= ["a" "b"] (take 2 ["a" "b" "c"])) "take two elements")
  (is (= ["a" "b" "c"] (take 3 ["a" "b" "c"])) "take three elements")
  (is (= ["a" "b" "c"] (take 4 ["a" "b" "c"])) "take four elements")
  (is (= [] (take 0 ["a" "b" "c"])) "take zero elements")
  (is (= [] (take -1 ["a" "b" "c"])) "take with negative number")
  (is (= ["a" "b"] (doall (take 2 ["a" "b" "c"]))) "take on vector")
  (is (= [] (take -1 ["a" "b" "c"])) "take on vector")
  (is (= ["a" "b"] (doall (take 2 (php/array "a" "b" "c")))) "take on php array returns lazy seq")
  (is (= [] (take -1 (php/array "a" "b" "c"))) "take on php array with negative"))

(deftest test-take-generator
  (is (= [0 1 2] (take 3 (naturals))) "take on generator"))

(deftest test-iterate
  (is (= [0 1 2] (take 3 (iterate inc 0))) "iterate infinite sequence"))

(deftest test-take-last
  (is (= ["c"] (take-last 1 ["a" "b" "c"])) "take-last element")
  (is (= ["b" "c"] (take-last 2 ["a" "b" "c"])) "take-last two elements")
  (is (= ["a" "b" "c"] (take-last 3 ["a" "b" "c"])) "take-last three elements")
  (is (= ["a" "b" "c"] (take-last 4 ["a" "b" "c"])) "take-last four elements")
  (is (= [] (take-last 0 ["a" "b" "c"])) "take-last zero elements")
  (is (= [] (take-last -1 ["a" "b" "c"])) "take-last with negative number")
  (is (= ["b" "c"] (take-last 2 ["a" "b" "c"])) "take-last on vector")
  (is (= [] (take-last 1 [])) "take-last on empty vector")
  (is (= [] (take-last -1 ["a" "b" "c"])) "take-last with negative number on vector")
  (is (= (php/array "b" "c") (take-last 2 (php/array "a" "b" "c"))) "take-last on php array")
  (is (= (php/array) (take-last 1 (php/array))) "take-last on empty php array")
  (is (= [] (take-last -1 (php/array "a" "b" "c"))) "take-last with negative number on php array"))

(deftest test-take-while
  (is (= [-1 -2 -3] (take-while neg? [-1 -2 -3 1 2 3 4 -4 -5 -6])) "take-while: first three element")
  (is (= [-1 -2 -3] (take-while neg? [-1 -2 -3])) "take-while: everything")
  (is (= [] (take-while neg? [1 2 3 4])) "take-while: nothing")
  (is (= [] (take-while neg? [])) "take-while: empty array")
  (is (= [-1 -2 -3] (take-while neg? [-1 -2 -3 1 2 3 4 -4 -5 -6])) "take-while on vector")
  (is (= [-1 -2 -3] (take-while neg? (php/array -1 -2 -3 1 2 3 4 -4 -5 -6))) "take-while on php array"))

# =============================================================================
# Filtering & Searching
# =============================================================================

(deftest test-filter
  (is (= [-1 -2 -3] (filter neg? [-1 2 3 -2 -3 4 5])) "filter: neg?")
  (is (= [-1 -2 -3] (filter neg? [-1 2 3 -2 -3 4 5])) "filter on vector")
  (is (= [-1 -2 -3] (filter neg? (php/array -1 2 3 -2 -3 4 5))) "filter on php array"))

(deftest test-filter-empty-element
  (is (= [] (filter |(throw (php/new \Exception)) [])) "`pred` is not executed when searching for empty vectors."))

(deftest test-keep
  (is (= [true false false true true false false] (keep neg? [-1 2 3 -2 -3 4 5])) "keep: neg?")
  (is (= [-1 -2 -3] (keep (fn [x] (if (neg? x) x nil)) [-1 2 3 -2 -3 4 5])) "keep: filter nil"))

(deftest test-keep-indexed
  (is (= [:b :d] (keep-indexed (fn [idx x] (if (odd? idx) x)) [:a :b :c :d :e])) "keep-indexed"))

(deftest test-neg?
  (is (= -1 (find neg? [1 2 3 -1 2 3])) "find first neg number")
  (is (nil? (find neg? [1 2 3 2 3])) "find: nothing to find")
  (is (nil? (find neg? [])) "find on empty array"))

(deftest test-find-empty-element
  (is (nil? (find |(throw (php/new \Exception)) [])) "`pred` is not executed when searching for empty vectors."))

(deftest test-find-index?
  (is (= 3 (find-index neg? [1 2 3 -1 2 3])) "find-index first neg number")
  (is (nil? (find-index neg? [1 2 3 2 3])) "find-index: nothing to find")
  (is (nil? (find-index neg? [])) "find-index on empty array"))

(deftest test-find-index-empty-element
  (is (nil? (find-index |(throw (php/new \Exception)) [])) "`pred` is not executed when searching for empty vectors."))

# =============================================================================
# Collection Utilities (distinct, dedupe, reverse, interleave, etc.)
# =============================================================================

(deftest test-distinct
  (is (= [1 2 3] (distinct [1 1 2 3 2 2 3 1])) "distinct: array")
  (is (= [1 2 3] (distinct (php/array 1 1 2 3 2 2 3 1))) "distinct: php array"))

(deftest test-dedupe
  (is (= [1 2 3 2 1] (dedupe [1 1 2 3 3 2 1 1])) "dedupe removes consecutive duplicates")
  (is (= [] (dedupe [])) "dedupe empty"))

(deftest test-reverse
  (is (= [3 2 1] (reverse [1 2 3])) "reverse: vector")
  (is (= [] (reverse nil)) "reverse: nil"))

(deftest test-interleave
  (is (= [:a 1 :b 2 :c 3] (interleave [:a :b :c] [1 2 3])) "interleave equal size")
  (is (= [:a 1 :b 2 :c nil] (interleave [:a :b :c] [1 2])) "interleave different size; more keys")
  (is (= [:a 1 :b 2] (interleave [:a :b] [1 2 3])) "interleave different size; more values")
  (is (= [:a 1 nil 2 :c 3] (interleave [:a nil :c] [1 2 3])) "interleave include nil keys")
  (is (= [:a 1 :b nil :c 3] (interleave [:a :b :c] [1 nil 3])) "interleave include nil values"))

(deftest test-interpose
  (is (= ["a" "," "b" "," "c"] (interpose "," ["a" "b" "c"])) "interpose"))

(deftest test-frequencies
  (is (= {1 2 2 3 3 2 4 1} (frequencies [1 1 2 3 2 2 3 4])) "frequencies on vector")
  (is (= {"h" 1 "e" 1 "l" 2 "o" 1} (frequencies "hello")) "frequencies on string"))

(deftest test-seq
  (is (= ["h" "e" "l" "l" "o"] (seq "hello")) "seq on string")
  (is (= [1 2 3] (seq [1 2 3])) "seq on vector")
  (is (nil? (seq "")) "seq on empty string")
  (is (nil? (seq nil)) "seq on nil")
  (is (nil? (seq [])) "seq on empty vector"))

(deftest test-count-string
  (is (= 5 (count "hello")) "count string")
  (is (= 0 (count "")) "count empty string")
  (is (= 4 (count "caf√©")) "count multibyte string"))

# =============================================================================
# Map/Collection Operations (keys, values, pairs, merge, etc.)
# =============================================================================

(deftest test-keys
  (is (= [:a :b :c] (keys {:a 1 :b 2 :c 3})) "keys of map")
  (is (= [0 1 2] (keys [3 2 1])) "keys of vector"))

(deftest test-values
  (is (= [1 2 3] (values {:a 1 :b 2 :c 3})) "values of map")
  (is (= [3 2 1] (values [3 2 1])) "values of vector"))

(deftest test-not-empty
  (is (= [1] (not-empty [1])) "not-empty returns coll")
  (is (nil? (not-empty [])) "not-empty empty"))

(deftest test-pairs
  (is (= [[:a 1] [:b 2] [:c 3]] (pairs {:a 1 :b 2 :c 3})) "pairs of maps")
  (is (= [[0 3] [1 2] [2 1]] (pairs [3 2 1])) "pairs of vector"))

(deftest test-kvs
  (is (= [:a 1 :b 2 :c 3] (kvs {:a 1 :b 2 :c 3})) "kvs of maps")
  (is (= [0 3 1 2 2 1] (kvs [3 2 1])) "kvs of vector"))

(deftest test-to-php-array
  (is (= (php/array 3 2 1) (to-php-array [3 2 1])) "to-php-array"))

(deftest test-sort
  (is (= [1 2 3] (sort [3 2 1])) "sort")
  (is (= [1 2 2 3 3] (sort [3 2 1 2 3] <=>)) "sort ascending order")
  (is (= [3 3 2 2 1] (sort [3 2 1 2 3] >=<)) "sort descending order")
  (is (= [1 2 3] (sort-by identity [3 2 1])) "sort-by identity")
  (is (= [3 2 1] (sort-by - [3 2 1])) "sort-by reversed"))

(deftest test-group-by
  (is (= {1 ["a"] 2 ["as" "aa"] 3 ["asd"] 4 ["asdf" "qwer"]}
         (group-by php/strlen ["a" "as" "asd" "aa" "asdf" "qwer"])) "group-by"))

(deftest test-zipcoll
  (is (= {:a 1 :b 2 :c 3} (zipcoll [:a :b :c] [1 2 3])) "zipcoll"))

(deftest test-zipmap
  (is (= {:a 1 :b 2} (zipmap [:a :b :c] [1 2])) "zipmap drops extra keys")
  (is (= {:a 1 :b 2} (zipmap [:a :b] [1 2 3])) "zipmap drops extra values")
  (is (= {:a 1 :b 2} (zipmap [:a :b] [1 2])) "zipmap equal length"))

(deftest test-merge
  (is (= {:a -1 :b 2 :c 3 :d 4} (merge {:a 1 :b 2} {:a -1 :c 3} {:d 4})) "merge"))

(deftest test-merge-with-zero-args
  (is (= {} (merge-with identity))))

(deftest test-merge-with-one-args
  (is (= {:a 1} (merge-with identity {:a 1}))))

(deftest test-merge-with-sum
  (is (= {:a 1 :b 5 :c 4} (merge-with + {:a 1 :b 2} {:b 3 :c 4}))))

(deftest test-merge-with-mulitple-maps
  (is (= {:a 3 :b 2 :c 3} (merge-with + {:a 1} {:a 1 :b 2} {:a 1 :c 3}))))

(deftest test-select-keys
  (is (= {:a 1 :b 2} (select-keys {:a 1 :b 2 :c 3} [:a :b])) "select-keys for map with matching ks keys")
  (is (= {} (select-keys {:a 1 :b 2 :c 3} [])) "select-keys for map without ks keys")
  (is (= {:a 1} (select-keys {:a 1 :b 2 :c 3} [:a :d])) "select-keys for map with one ks key not found")
  (is (= {} (select-keys {:a 1 :b 2 :c 3} [:d])) "select-keys for map with ks key not found")
  (is (= {:a 1 :b 2 :c 3} (select-keys {:a 1 :b 2 :c 3} [:a :b :c])) "select-keys for map with all keys present")
  (is (= {} (select-keys {} [:a :b])) "select-keys for empty map")
  (is (= {1 10 2 20} (select-keys {1 10 2 20 3 30} [1 2])) "select-keys with numeric keys")
  (is (= {:a 1} (select-keys {:a 1 :b 2 :c 3} [:a nil])) "select-keys with nil key in ks")
  (is (= {:a 1 nil 4} (select-keys {:a 1 :b 2 :c 3 nil 4} [:a nil])) "select-keys with nil key in m"))

(deftest test-simple-deep-merge
  (is (= {:a 1 :b 3 :c 4} (deep-merge {:a 1 :b 2} {:b 3 :c 4}))))

(deftest test-inner-map-deep-merge
  (is (= {:a {:b 1 :c 3}} (deep-merge {:a {:b 1 :c 2}} {:a {:c 3}}))))

(deftest test-inner-set-deep-merge
  (is (= {:a (hash-set :b :c :d)} (deep-merge {:a (hash-set :b :c)} {:a (hash-set :c :d)}))))

(deftest test-inner-vector-deep-merge
  (is (= {:a [:b :c :d]} (deep-merge {:a [:b :c]} {:a [:d]}))))

(deftest test-deep-inner-merge
  (is (= {:a {:b {:c [:d :e] :f :g}}} (deep-merge {:a {:b {:c [:d]}}} {:a {:b {:c [:e] :f :g}}}))))

(deftest test-collection-stay-the-same-in-deep-merge
  (is (hash-map? (deep-merge {:a :b} {:c :d})))
  (is (vector? (deep-merge [:a :b] [:c])))
  (is (set? (deep-merge (hash-set :a :b) (hash-set :c))))
  (is (list? (deep-merge '(:a :b) '(:c)))))

(deftest test-different-args-in-deep-merge
  (is (= {} (deep-merge)))
  (is (= {:a :b} (deep-merge {:a :b})))
  (is (= {:a :d :x 1 :y 2} (deep-merge {:a :b :x 1} {:a :c :y 2} {:a :d})))
  (is (= {:a :d :x 1 :y 4 :z 3} (deep-merge {:a :b :x 1} {:a :c :y 2} {:a :d} {:y 4 :z 3}))))

(deftest test-invert
  (is (= {1 :a 2 :b} (invert {:a 1 :b 2})) "invert")
  (is (= {1 :a 2 :c} (invert {:a 1 :b 2 :c 2})) "invert duplicate values"))

(deftest test-split-at
  (is (= [[1 2] [3 4 5]] (split-at 2 [1 2 3 4 5])) "split-at")
  (is (= [[1 2] []] (split-at 3 [1 2])) "split-at empty"))

(deftest test-split-with
  (is (= [[1 2 3] [4 5]] (split-with (partial >= 3) [1 2 3 4 5])) "split-with"))

(deftest test-partition-by
  (is (= [[1 1] [2] [3 3]] (partition-by identity [1 1 2 3 3])) "partition-by identity")
  (is (= [] (partition-by identity [])) "partition-by empty"))

(deftest test-partition
  (is (= [] (partition 2 [])) "partition-2 empty")
  (is (= [] (partition 2 [1])) "partition-2 one element drops incomplete")
  (is (= [[1 2]] (partition 2 [1 2])) "partition-2 two elements")
  (is (= [[1 2]] (partition 2 [1 2 3])) "partition-2 three elements drops incomplete")
  (is (= [[1 2] [3 4]] (partition 2 [1 2 3 4])) "partition-2 four elements")
  (is (= [[1 2] [3 4]] (partition 2 [1 2 3 4 5])) "partition-2 five elements drops incomplete"))

(deftest test-partition-all
  (is (= [] (partition-all 2 [])) "partition-all-2 empty")
  (is (= [[1]] (partition-all 2 [1])) "partition-all-2 one element keeps incomplete")
  (is (= [[1 2]] (partition-all 2 [1 2])) "partition-all-2 two elements")
  (is (= [[1 2] [3]] (partition-all 2 [1 2 3])) "partition-all-2 three elements keeps incomplete")
  (is (= [[1 2] [3 4]] (partition-all 2 [1 2 3 4])) "partition-all-2 four elements")
  (is (= [[1 2] [3 4] [5]] (partition-all 2 [1 2 3 4 5])) "partition-all-2 five elements keeps incomplete"))

# =============================================================================
# Type Conversion & Interop (phel->php, php->phel)
# =============================================================================

(deftest test-phel-php-roundtrip
  (let [data {:a [1 {:b 2}]}]
    (let [arr (phel->php data)]
      (is (php-array? arr) "phel->php returns php array")
      (is (= {"a" [1 {"b" 2}]} (php->phel arr)) "phel->php -> php->phel roundtrip"))))

(deftest test-php-phel-roundtrip
  (let [m (php/array)
        inner (php/array)]
    (php/aset inner "b" 2)
    (php/aset m "a" (php/array 1 inner))
    (is (= m (phel->php (php->phel m))) "php->phel -> phel->php roundtrip")))

# =============================================================================
# String Seqability Tests
# Strings are fully seqable in Phel - all sequence functions work directly
# =============================================================================

# --- Basic Sequence Operations ---

(deftest test-map-with-string
  (is (= ["H" "I"] (map php/strtoupper "hi")) "map works with strings"))

(deftest test-filter-with-string
  (is (= ["h" "e" "o"] (filter |(not= $ "l") "hello")) "filter works with strings"))

(deftest test-take-with-string
  (is (= ["h" "i"] (take 2 "hi")) "take works with strings")
  (is (= [] (take 5 "")) "take from empty string"))

(deftest test-drop-with-string
  (is (= ["l" "o"] (drop 3 "hello")) "drop works with strings")
  (is (= [] (drop 5 "")) "drop from empty string"))

# --- Core Sequence Functions (first, next, rest, reduce) ---

(deftest test-first-with-strings
  (is (= "h" (first "hello")) "first works with string")
  (is (nil? (first "")) "first returns nil for empty string")
  (is (= "üéâ" (first "üéâüéä")) "first works with multibyte UTF-8"))

(deftest test-next-with-strings
  (is (= ["e" "l" "l" "o"] (next "hello")) "next works with string")
  (is (nil? (next "a")) "next returns nil for single character")
  (is (nil? (next "")) "next returns nil for empty string")
  (is (= ["i"] (next "hi")) "next returns vector for remaining chars"))

(deftest test-rest-with-strings
  (is (= ["e" "l" "l" "o"] (rest "hello")) "rest works with string")
  (is (= [] (rest "a")) "rest returns empty vector for single character")
  (is (= [] (rest "")) "rest returns empty vector for empty string"))

(deftest test-reduce-with-strings
  (is (= "hello" (reduce str "" "hello")) "reduce works with string")
  (is (= "HELLO" (reduce (fn [acc c] (str acc (php/strtoupper c))) "" "hello")) "reduce can transform string chars"))

(deftest test-sequence-ops-with-strings
  (is (= ["h" "e" "l" "l" "o"] (map identity "hello")) "map identity on string")
  (is (= ["l" "l"] (filter |(= $ "l") "hello")) "filter on string")
  (is (= ["h" "e"] (take 2 "hello")) "take from string")
  (is (= ["l" "l" "o"] (drop 2 "hello")) "drop from string")
  (is (= ["h" "e" "l" "o"] (distinct "hheelloo")) "distinct removes duplicate chars")
  (is (= 5 (count "hello")) "count on string")
  (is (= ["o" "l" "l" "e" "h"] (reverse "hello")) "reverse on string"))

# --- Lazy Operations ---

(deftest test-lazy-operations-with-strings
  (is (= ["h" "e"] (take 2 (concat "hello" "world"))) "concat with strings")
  (is (= ["h" "e"] (take-while |(not= $ "l") "hello")) "take-while stops before l")
  (is (= ["l" "l" "o"] (drop-while |(not= $ "l") "hello")) "drop-while drops until l"))

# --- Iterator-Based Operations (interleave, mapcat) ---

(deftest test-interleave-with-strings
  (is (= ["a" "c" "b" "d"] (interleave "ab" "cd")) "interleave with two strings")
  (is (= ["h" "w" "e" "o" "l" "r"] (take 6 (interleave "hello" "world"))) "interleave with different lengths")
  (is (= ["a" 1 "b" 2] (interleave "ab" [1 2])) "interleave mixes string and vector")
  (is (= [] (interleave "" "abc")) "interleave with empty string")
  (is (= ["‰Ω†" "w" "Â•Ω" "o"] (interleave "‰Ω†Â•Ω" "world")) "interleave with unicode"))

(deftest test-mapcat-with-strings
  (is (= ["a" "a" "b" "b"] (mapcat (fn [c] (str c c)) "ab")) "mapcat with string-returning function")
  (is (= ["h" "i" "!" "!" "!"] (mapcat (fn [c] (if (= c "!") "!!!" c)) "hi!")) "mapcat flattens string results")
  (is (= ["a" "b" "c" "d"] (mapcat identity ["ab" "cd"])) "mapcat identity on vector of strings")
  (is (= [] (mapcat (fn [_] "") "abc")) "mapcat with empty string results")
  (is (= ["üéâ" "üéâ" "üéä" "üéä"] (mapcat (fn [c] (str c c)) "üéâüéä")) "mapcat with emoji"))

# --- Unicode/Multibyte Support ---

(deftest test-unicode-string-support
  (is (= "‰Ω†" (first "‰Ω†Â•Ω")) "first works with Chinese characters")
  (is (= ["Â•Ω"] (next "‰Ω†Â•Ω")) "next works with Chinese characters")
  (is (= ["üéâ" "üéä" "üéà"] (map identity "üéâüéäüéà")) "map works with emoji")
  (is (= 3 (count "‰Ω†Â•ΩÂêó")) "count works with multibyte strings"))

# --- seq function (backward compatibility & laziness) ---

(deftest test-seq-preserves-laziness
  (is (= 0 (first (seq (range 1000000)))) "seq with large range returns immediately")
  (is (= [0 1 2] (take 3 (seq (range 1000000)))) "take works on seq of large range")
  (is (nil? (seq (filter (fn [x] false) (range 10)))) "seq returns nil for empty lazy seq")
  (is (= 0 (first (seq (filter (fn [x] (= 0 (php/% x 2))) (range 1000000))))) "seq preserves laziness for filtered sequences"))
