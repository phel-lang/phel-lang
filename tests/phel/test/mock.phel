(ns phel-test\test\mock
  (:require phel\test :refer [deftest is])
  (:require phel\mock :refer [mock mock-fn spy mock-returning mock-throwing
                              calls call-count called? called-with? called-once?
                              called-times? never-called? last-call first-call
                              reset-mock! mock? with-mocks]))

# -----------
# Mock Creation Tests
# -----------

(deftest test-mock-returns-value
  (let [my-mock (mock :result)]
    (is (= :result (my-mock)) "mock returns fixed value")
    (is (= :result (my-mock 1 2 3)) "mock ignores arguments")))

(deftest test-mock-tracks-calls
  (let [my-mock (mock :result)]
    (my-mock 1 2)
    (my-mock 3)
    (is (= [[1 2] [3]] (calls my-mock)) "tracks all calls with arguments")))

(deftest test-mock-fn-uses-custom-behavior
  (let [my-mock (mock-fn (fn [x] (* x 2)))]
    (is (= 10 (my-mock 5)) "uses custom function")
    (is (= [[5]] (calls my-mock)) "tracks calls")))

(deftest test-spy-preserves-behavior
  (let [original (fn [x] (* x 2))
        spied (spy original)]
    (is (= 10 (spied 5)) "preserves original behavior")
    (is (= [[5]] (calls spied)) "tracks calls")))

(deftest test-mock-returning-cycles-values
  (let [my-mock (mock-returning [1 2 3])]
    (is (= 1 (my-mock)) "returns first value")
    (is (= 2 (my-mock)) "returns second value")
    (is (= 3 (my-mock)) "returns third value")
    (is (= 3 (my-mock)) "returns last value when exhausted")
    (is (= 4 (call-count my-mock)) "tracks all calls")))

(deftest test-mock-throwing
  (let [my-mock (mock-throwing (php/new \Exception "API error"))]
    (is (thrown? \Exception (my-mock)) "throws exception when called")
    (is (= 1 (call-count my-mock)) "tracks call even when throwing")))

# -----------
# Mock Inspection Tests
# -----------

(deftest test-mock-predicate
  (let [my-mock (mock :result)
        regular-fn (fn [] :result)]
    (is (= true (mock? my-mock)) "identifies mock")
    (is (= false (mock? regular-fn)) "identifies non-mock")))

(deftest test-call-count
  (let [my-mock (mock :result)]
    (is (= 0 (call-count my-mock)) "zero calls initially")
    (my-mock)
    (is (= 1 (call-count my-mock)) "increments on call")
    (my-mock)
    (my-mock)
    (is (= 3 (call-count my-mock)) "tracks multiple calls")))

(deftest test-called
  (let [my-mock (mock :result)]
    (is (= false (called? my-mock)) "not called initially")
    (my-mock)
    (is (= true (called? my-mock)) "called after invocation")))

(deftest test-called-with
  (let [my-mock (mock :result)]
    (my-mock 1 2 3)
    (my-mock 4 5)
    (is (called-with? my-mock 1 2 3) "finds exact match")
    (is (called-with? my-mock 4 5) "finds second call")
    (is (not (called-with? my-mock 1 2)) "rejects partial match")
    (is (not (called-with? my-mock 6 7)) "rejects non-existent call")))

(deftest test-called-once
  (let [my-mock (mock :result)]
    (is (= false (called-once? my-mock)) "not called once initially")
    (my-mock)
    (is (= true (called-once? my-mock)) "called once after one call")
    (my-mock)
    (is (= false (called-once? my-mock)) "not called once after two calls")))

(deftest test-called-times
  (let [my-mock (mock :result)]
    (is (= true (called-times? my-mock 0)) "zero calls")
    (my-mock)
    (my-mock)
    (is (= true (called-times? my-mock 2)) "two calls")
    (is (= false (called-times? my-mock 3)) "not three calls")))

(deftest test-never-called
  (let [my-mock (mock :result)]
    (is (= true (never-called? my-mock)) "never called initially")
    (my-mock)
    (is (= false (never-called? my-mock)) "called after invocation")))

(deftest test-first-and-last-call
  (let [my-mock (mock :result)]
    (my-mock 1 2)
    (my-mock 3 4)
    (my-mock 5 6)
    (is (= [1 2] (first-call my-mock)) "gets first call")
    (is (= [5 6] (last-call my-mock)) "gets last call")))

(deftest test-reset-mock
  (let [my-mock (mock :result)]
    (my-mock 1)
    (my-mock 2)
    (is (= 2 (call-count my-mock)) "has calls")
    (reset-mock! my-mock)
    (is (= 0 (call-count my-mock)) "resets to zero")
    (is (= [] (calls my-mock)) "clears call history")))

# -----------
# Integration Tests
# -----------

(defn fetch-user [http-client id]
  "Simulates fetching a user via HTTP"
  (http-client (str "/users/" id)))

(defn save-user [db user]
  "Simulates saving a user to database"
  (db user))

(deftest test-mocking-with-binding
  (let [mock-http (mock {:id 1 :name "Alice"})]
    (binding [fetch-user (fn [_ id] (mock-http id))]
      (let [result (fetch-user nil 123)]
        (is (= {:id 1 :name "Alice"} result) "uses mocked response")
        (is (called-with? mock-http 123) "verifies call arguments")))))

(deftest test-with-mocks-macro
  (let [mock-http (mock {:status 200})
        mock-db (mock :ok)]
    (with-mocks [fetch-user (fn [_ _] (mock-http))
                 save-user  (fn [_] (mock-db))]
      (is (= {:status 200} (fetch-user nil 1)) "uses first mock")
      (is (= :ok (save-user {})) "uses second mock")
      (is (called? mock-http) "first mock was called")
      (is (called? mock-db) "second mock was called"))))

(deftest test-with-mocks-auto-reset
  # Create mocks outside and use them inside with-mocks bindings directly
  (let [mock-http (mock {:id 1})
        mock-db (mock :ok)]
    # First call - mocks get used
    (with-mocks [fetch-user mock-http
                 save-user mock-db]
      (fetch-user nil 123)
      (save-user {})
      (is (= 1 (call-count mock-http)) "http called once inside with-mocks")
      (is (= 1 (call-count mock-db)) "db called once inside with-mocks"))

    # After with-mocks, call history should be reset
    (is (= 0 (call-count mock-http)) "http call history reset after with-mocks")
    (is (= 0 (call-count mock-db)) "db call history reset after with-mocks")

    # Second call - starts fresh
    (with-mocks [fetch-user mock-http
                 save-user mock-db]
      (fetch-user nil 123)
      (fetch-user nil 456)
      (save-user {})
      (is (= 2 (call-count mock-http)) "http called twice in second with-mocks")
      (is (= 1 (call-count mock-db)) "db called once in second with-mocks"))

    # Should be reset again
    (is (= 0 (call-count mock-http)) "http call history reset again")
    (is (= 0 (call-count mock-db)) "db call history reset again")))

# -----------
# Real-world Example Tests
# -----------

(defn send-email [email-service to subject body]
  "Simulates sending an email"
  (email-service to subject body))

(defn register-user [email-service user]
  "Simulates user registration with email notification"
  (send-email email-service (:email user) "Welcome!" "Thanks for signing up"))

(deftest test-email-sending-mock
  (let [mock-email (mock :sent)]
    (binding [send-email (fn [_ to subject body] (mock-email to subject body))]
      (register-user nil {:email "user@example.com"})
      (is (called-once? mock-email) "sends exactly one email")
      (is (called-with? mock-email "user@example.com" "Welcome!" "Thanks for signing up")
          "sends correct email"))))

(defn fetch-from-api [url]
  "Simulates API call"
  {:url url :status 200})

(deftest test-api-failure-with-mock-throwing
  (let [mock-api (mock-throwing (php/new \RuntimeException "API unavailable"))]
    (binding [fetch-from-api (fn [url] (mock-api url))]
      (is (thrown? \RuntimeException (fetch-from-api "http://api.example.com"))
          "throws when API fails")
      (is (called-with? mock-api "http://api.example.com") "attempted call with URL"))))

(defn retry-fetch [fetch-fn url max-retries]
  "Simulates retry logic"
  (try
    (fetch-fn url)
    (catch \Exception e
      (if (> max-retries 0)
        (retry-fetch fetch-fn url (dec max-retries))
        (throw e)))))

(deftest test-retry-logic-with-mock-returning
  (let [mock-api (mock-returning [nil nil {:status 200}])]
    (binding [fetch-from-api (fn [url]
                               (let [result (mock-api url)]
                                 (when (nil? result)
                                   (throw (php/new \Exception "Failed")))
                                 result))]
      (is (= {:status 200} (retry-fetch fetch-from-api "http://api.example.com" 3))
          "succeeds after retries")
      (is (= 3 (call-count mock-api)) "retries correct number of times"))))
